// --------------------------------------
// 
//    _  _ _/ .  _  _/ /_ _  _  _        
//   /_|/_ / /|//_  / / //_ /_// /_/     
//   https://activetheory.net    _/      
// 
// --------------------------------------
//   11/1/22 11:25a
// --------------------------------------

window.ASSETS = ["assets/data/uil.json", "assets/shaders/compiled.vs"], ASSETS.SW = ["assets/fonts/Manrope-SemiBold.json", "assets/fonts/Manrope-SemiBold.png", "assets/fonts/Manrope-SemiBold.ttf", "assets/fonts/proxima-nova.json", "assets/fonts/proxima-nova.png", "assets/fonts/proxima-nova.ttf", "assets/fonts/red-hat-display-medium.json", "assets/fonts/red-hat-display-medium.png", "assets/fonts/red-hat-display-medium.ttf", "assets/css/style-scss.css", "assets/css/style.css", "assets/js/app.js"], window.UIL_ASSETS_GEOMETRIES = [{
	filename: "HOKUSAI_ID.bin",
	bytes: 1138,
	lastChange: "2022-11-01T18:24:56.055Z"
}, {
	filename: "HOKUSAI_ID.json",
	bytes: 183274,
	lastChange: "2022-11-01T18:24:56.055Z"
}, {
	filename: "avatar/avatar_dance.json",
	bytes: 234154,
	lastChange: "2022-11-01T18:24:56.055Z"
}, {
	filename: "avatar/avatar_idle.json",
	bytes: 412359,
	lastChange: "2022-11-01T18:24:56.059Z"
}, {
	filename: "avatar/avatar_inactive.json",
	bytes: 508196,
	lastChange: "2022-11-01T18:24:56.059Z"
}, {
	filename: "avatar/avatar_jump.json",
	bytes: 32976,
	lastChange: "2022-11-01T18:24:56.059Z"
}, {
	filename: "avatar/avatar_skinned.json",
	bytes: 82772,
	lastChange: "2022-11-01T18:24:56.059Z"
}, {
	filename: "avatar/avatar_walk.json",
	bytes: 49316,
	lastChange: "2022-11-01T18:24:56.059Z"
}, {
	filename: "blossom/backgroundmountains.bin",
	bytes: 21875,
	lastChange: "2022-11-01T18:24:56.059Z"
}, {
	filename: "blossom/backgroundmountains.json",
	bytes: 2217900,
	lastChange: "2022-11-01T18:24:56.071Z"
}, {
	filename: "blossom/bridge.bin",
	bytes: 18095,
	lastChange: "2022-11-01T18:24:56.071Z"
}, {
	filename: "blossom/bridge.json",
	bytes: 1170031,
	lastChange: "2022-11-01T18:24:56.075Z"
}, {
	filename: "blossom/bridge_instance.bin",
	bytes: 459,
	lastChange: "2022-11-01T18:24:56.075Z"
}, {
	filename: "blossom/bridge_instance.json",
	bytes: 706,
	lastChange: "2022-11-01T18:24:56.075Z"
}, {
	filename: "blossom/grass.bin",
	bytes: 451,
	lastChange: "2022-11-01T18:24:56.075Z"
}, {
	filename: "blossom/grass.json",
	bytes: 2400,
	lastChange: "2022-11-01T18:24:56.075Z"
}, {
	filename: "blossom/grass1.json",
	bytes: 2438,
	lastChange: "2022-11-01T18:24:56.075Z"
}, {
	filename: "blossom/grass_instance_19_color.json",
	bytes: 6251523,
	lastChange: "2022-11-01T18:24:56.107Z"
}, {
	filename: "blossom/land.bin",
	bytes: 41524,
	lastChange: "2022-11-01T18:24:56.107Z"
}, {
	filename: "blossom/land.json",
	bytes: 2380387,
	lastChange: "2022-11-01T18:24:56.119Z"
}, {
	filename: "blossom/patch1_instance.bin",
	bytes: 211876,
	lastChange: "2022-11-01T18:24:56.123Z"
}, {
	filename: "blossom/patch1_instance.json",
	bytes: 2791527,
	lastChange: "2022-11-01T18:24:56.143Z"
}, {
	filename: "blossom/patch1_instance_19_color.json",
	bytes: 1864107,
	lastChange: "2022-11-01T18:24:56.179Z"
}, {
	filename: "blossom/patch2_instance.bin",
	bytes: 209606,
	lastChange: "2022-11-01T18:24:56.179Z"
}, {
	filename: "blossom/patch2_instance.json",
	bytes: 2790064,
	lastChange: "2022-11-01T18:24:56.183Z"
}, {
	filename: "blossom/patch2_instance_19_color.json",
	bytes: 1865756,
	lastChange: "2022-11-01T18:24:56.191Z"
}, {
	filename: "blossom/rock.bin",
	bytes: 16138,
	lastChange: "2022-11-01T18:24:56.191Z"
}, {
	filename: "blossom/rock.json",
	bytes: 1207945,
	lastChange: "2022-11-01T18:24:56.199Z"
}, {
	filename: "blossom/rock_instance.bin",
	bytes: 933,
	lastChange: "2022-11-01T18:24:56.199Z"
}, {
	filename: "blossom/rock_instance.json",
	bytes: 4430,
	lastChange: "2022-11-01T18:24:56.199Z"
}, {
	filename: "blossom/singleleaf.bin",
	bytes: 279,
	lastChange: "2022-11-01T18:24:56.199Z"
}, {
	filename: "blossom/singleleaf.json",
	bytes: 394,
	lastChange: "2022-11-01T18:24:56.199Z"
}, {
	filename: "blossom/stonelamp.bin",
	bytes: 15402,
	lastChange: "2022-11-01T18:24:56.199Z"
}, {
	filename: "blossom/stonelamp.json",
	bytes: 1146509,
	lastChange: "2022-11-01T18:24:56.203Z"
}, {
	filename: "blossom/stonelamp_instance.json",
	bytes: 478,
	lastChange: "2022-11-01T18:24:56.203Z"
}, {
	filename: "blossom/torri.bin",
	bytes: 57051,
	lastChange: "2022-11-01T18:24:56.203Z"
}, {
	filename: "blossom/torri.json",
	bytes: 5297357,
	lastChange: "2022-11-01T18:24:56.231Z"
}, {
	filename: "blossom/tree_instance.bin",
	bytes: 481,
	lastChange: "2022-11-01T18:24:56.231Z"
}, {
	filename: "blossom/tree_instance.json",
	bytes: 1041,
	lastChange: "2022-11-01T18:24:56.231Z"
}, {
	filename: "blossom/tree_leaves_instance_19_color.json",
	bytes: 3333290,
	lastChange: "2022-11-01T18:24:56.251Z"
}, {
	filename: "blossom/treeleaves.bin",
	bytes: 34580,
	lastChange: "2022-11-01T18:24:56.251Z"
}, {
	filename: "blossom/treeleaves.json",
	bytes: 3437403,
	lastChange: "2022-11-01T18:24:56.271Z"
}, {
	filename: "blossom/treetrunk.bin",
	bytes: 29903,
	lastChange: "2022-11-01T18:24:56.271Z"
}, {
	filename: "blossom/treetrunk.json",
	bytes: 2124005,
	lastChange: "2022-11-01T18:24:56.283Z"
}, {
	filename: "blossom/water.bin",
	bytes: 1602,
	lastChange: "2022-11-01T18:24:56.283Z"
}, {
	filename: "blossom/water.json",
	bytes: 132735,
	lastChange: "2022-11-01T18:24:56.283Z"
}, {
	filename: "castle.bin",
	bytes: 292491,
	lastChange: "2022-11-01T18:24:56.283Z"
}, {
	filename: "coin_axie.bin",
	bytes: 26505,
	lastChange: "2022-11-01T18:24:56.283Z"
}, {
	filename: "coin_axie.json",
	bytes: 3638538,
	lastChange: "2022-11-01T18:24:56.299Z"
}, {
	filename: "coin_axie_remesh.bin",
	bytes: 5661,
	lastChange: "2022-11-01T18:24:56.299Z"
}, {
	filename: "coin_axie_remesh.json",
	bytes: 425676,
	lastChange: "2022-11-01T18:24:56.299Z"
}, {
	filename: "controller.json",
	bytes: 94725,
	lastChange: "2022-11-01T18:24:56.303Z"
}, {
	filename: "cube/cube.bin",
	bytes: 5151,
	lastChange: "2022-11-01T18:24:56.303Z"
}, {
	filename: "cube/cube.json",
	bytes: 188671,
	lastChange: "2022-11-01T18:24:56.303Z"
}, {
	filename: "cube/floor.bin",
	bytes: 52814,
	lastChange: "2022-11-01T18:24:56.303Z"
}, {
	filename: "cube/floor.json",
	bytes: 10518063,
	lastChange: "2022-11-01T18:24:56.351Z"
}, {
	filename: "cube/hand.json",
	bytes: 3429173,
	lastChange: "2022-11-01T18:24:56.363Z"
}, {
	filename: "cube/hemisphere.json",
	bytes: 187703,
	lastChange: "2022-11-01T18:24:56.367Z"
}, {
	filename: "cube/hitmesh.bin",
	bytes: 29866,
	lastChange: "2022-11-01T18:24:56.367Z"
}, {
	filename: "cube/hitmesh.json",
	bytes: 5762852,
	lastChange: "2022-11-01T18:24:56.391Z"
}, {
	filename: "cube/lands.bin",
	bytes: 29864,
	lastChange: "2022-11-01T18:24:56.391Z"
}, {
	filename: "cube/lands.json",
	bytes: 5762852,
	lastChange: "2022-11-01T18:24:56.415Z"
}, {
	filename: "cube/monolith.json",
	bytes: 16910,
	lastChange: "2022-11-01T18:24:56.415Z"
}, {
	filename: "cube/mountain.json",
	bytes: 2573999,
	lastChange: "2022-11-01T18:24:56.427Z"
}, {
	filename: "cube/pillars.json",
	bytes: 3919257,
	lastChange: "2022-11-01T18:24:56.443Z"
}, {
	filename: "cube/planet.json",
	bytes: 414051,
	lastChange: "2022-11-01T18:24:56.447Z"
}, {
	filename: "cube/poles.json",
	bytes: 447882,
	lastChange: "2022-11-01T18:24:56.447Z"
}, {
	filename: "cube/screen.json",
	bytes: 312,
	lastChange: "2022-11-01T18:24:56.447Z"
}, {
	filename: "cube/screen_back.json",
	bytes: 212280,
	lastChange: "2022-11-01T18:24:56.447Z"
}, {
	filename: "cube/screen_land.json",
	bytes: 289865,
	lastChange: "2022-11-01T18:24:56.451Z"
}, {
	filename: "cube/spotlight.json",
	bytes: 28401,
	lastChange: "2022-11-01T18:24:56.451Z"
}, {
	filename: "cube/spotlight_instances.json",
	bytes: 2720,
	lastChange: "2022-11-01T18:24:56.451Z"
}, {
	filename: "cube/stage.json",
	bytes: 826886,
	lastChange: "2022-11-01T18:24:56.455Z"
}, {
	filename: "cube/statues.json",
	bytes: 2203937,
	lastChange: "2022-11-01T18:24:56.463Z"
}, {
	filename: "cube/walls.json",
	bytes: 274928,
	lastChange: "2022-11-01T18:24:56.467Z"
}, {
	filename: "cube/water.json",
	bytes: 892122,
	lastChange: "2022-11-01T18:24:56.467Z"
}, {
	filename: "cyber/cyber_building.json",
	bytes: 280764,
	lastChange: "2022-11-01T18:24:56.471Z"
}, {
	filename: "cyber/cyber_building_2.bin",
	bytes: 7087,
	lastChange: "2022-11-01T18:24:56.471Z"
}, {
	filename: "cyber/cyber_building_2.json",
	bytes: 346156,
	lastChange: "2022-11-01T18:24:56.471Z"
}, {
	filename: "cyber/cyber_building_3.bin",
	bytes: 5801,
	lastChange: "2022-11-01T18:24:56.471Z"
}, {
	filename: "cyber/cyber_building_3.json",
	bytes: 319037,
	lastChange: "2022-11-01T18:24:56.471Z"
}, {
	filename: "cyber/cyber_building_instances.json",
	bytes: 3880,
	lastChange: "2022-11-01T18:24:56.471Z"
}, {
	filename: "cyber/cyber_ring_border.json",
	bytes: 276549,
	lastChange: "2022-11-01T18:24:56.475Z"
}, {
	filename: "cyber/cyber_ring_floor.json",
	bytes: 16119,
	lastChange: "2022-11-01T18:24:56.475Z"
}, {
	filename: "cyber/cyber_ring_hitmesh.json",
	bytes: 179332,
	lastChange: "2022-11-01T18:24:56.475Z"
}, {
	filename: "cyber/cyber_screen_instances.json",
	bytes: 1318,
	lastChange: "2022-11-01T18:24:56.475Z"
}, {
	filename: "dnastrand.bin",
	bytes: 11009,
	lastChange: "2022-11-01T18:24:56.475Z"
}, {
	filename: "dnastrand.json",
	bytes: 1012984,
	lastChange: "2022-11-01T18:24:56.479Z"
}, {
	filename: "fantasy/floor.bin",
	bytes: 255,
	lastChange: "2022-11-01T18:24:56.479Z"
}, {
	filename: "fantasy/floor.json",
	bytes: 511,
	lastChange: "2022-11-01T18:24:56.479Z"
}, {
	filename: "fantasy/grass_instances.json",
	bytes: 3205484,
	lastChange: "2022-11-01T18:24:56.495Z"
}, {
	filename: "fantasy/hitmesh.bin",
	bytes: 333958,
	lastChange: "2022-11-01T18:24:56.499Z"
}, {
	filename: "fantasy/hitmesh.json",
	bytes: 7030263,
	lastChange: "2022-11-01T18:24:56.543Z"
}, {
	filename: "fantasy/objects.bin",
	bytes: 56768,
	lastChange: "2022-11-01T18:24:56.543Z"
}, {
	filename: "fantasy/objects.json",
	bytes: 1858095,
	lastChange: "2022-11-01T18:24:56.559Z"
}, {
	filename: "fantasy/sweep.json",
	bytes: 370096,
	lastChange: "2022-11-01T18:24:56.559Z"
}, {
	filename: "fantasy/terrain.bin",
	bytes: 294162,
	lastChange: "2022-11-01T18:24:56.563Z"
}, {
	filename: "fantasy/terrain.json",
	bytes: 8798674,
	lastChange: "2022-11-01T18:24:56.619Z"
}, {
	filename: "fantasy/whale.json",
	bytes: 129095,
	lastChange: "2022-11-01T18:24:56.619Z"
}, {
	filename: "floor_plans.bin",
	bytes: 413379,
	lastChange: "2022-11-01T18:24:56.619Z"
}, {
	filename: "floor_plans_circles.bin",
	bytes: 8522,
	lastChange: "2022-11-01T18:24:56.619Z"
}, {
	filename: "floor_plans_hitmesh.bin",
	bytes: 355220,
	lastChange: "2022-11-01T18:24:56.623Z"
}, {
	filename: "fun/borders.bin",
	bytes: 33344,
	lastChange: "2022-11-01T18:24:56.623Z"
}, {
	filename: "fun/borders.json",
	bytes: 2567295,
	lastChange: "2022-11-01T18:24:56.631Z"
}, {
	filename: "fun/circles.bin",
	bytes: 27749,
	lastChange: "2022-11-01T18:24:56.631Z"
}, {
	filename: "fun/circles.json",
	bytes: 3008529,
	lastChange: "2022-11-01T18:24:56.647Z"
}, {
	filename: "fun/cloud1.bin",
	bytes: 23021,
	lastChange: "2022-11-01T18:24:56.647Z"
}, {
	filename: "fun/cloud1.json",
	bytes: 2344689,
	lastChange: "2022-11-01T18:24:56.659Z"
}, {
	filename: "fun/cloud1_instance.bin",
	bytes: 528,
	lastChange: "2022-11-01T18:24:56.659Z"
}, {
	filename: "fun/cloud1_instance.json",
	bytes: 1324,
	lastChange: "2022-11-01T18:24:56.659Z"
}, {
	filename: "fun/cloud2.bin",
	bytes: 18393,
	lastChange: "2022-11-01T18:24:56.659Z"
}, {
	filename: "fun/cloud2.json",
	bytes: 1806477,
	lastChange: "2022-11-01T18:24:56.671Z"
}, {
	filename: "fun/cloud2_instance.bin",
	bytes: 531,
	lastChange: "2022-11-01T18:24:56.671Z"
}, {
	filename: "fun/cloud2_instance.json",
	bytes: 1327,
	lastChange: "2022-11-01T18:24:56.671Z"
}, {
	filename: "fun/connector.bin",
	bytes: 4172,
	lastChange: "2022-11-01T18:24:56.671Z"
}, {
	filename: "fun/connector.json",
	bytes: 261218,
	lastChange: "2022-11-01T18:24:56.671Z"
}, {
	filename: "fun/course1.bin",
	bytes: 20775,
	lastChange: "2022-11-01T18:24:56.671Z"
}, {
	filename: "fun/course1.json",
	bytes: 1237923,
	lastChange: "2022-11-01T18:24:56.675Z"
}, {
	filename: "fun/fenceposts.bin",
	bytes: 6706,
	lastChange: "2022-11-01T18:24:56.675Z"
}, {
	filename: "fun/fenceposts.json",
	bytes: 638146,
	lastChange: "2022-11-01T18:24:56.675Z"
}, {
	filename: "fun/fencewall.bin",
	bytes: 349,
	lastChange: "2022-11-01T18:24:56.675Z"
}, {
	filename: "fun/fencewall.json",
	bytes: 3143,
	lastChange: "2022-11-01T18:24:56.679Z"
}, {
	filename: "fun/fencewalls_instance.bin",
	bytes: 982,
	lastChange: "2022-11-01T18:24:56.679Z"
}, {
	filename: "fun/fencewalls_instance.json",
	bytes: 2817,
	lastChange: "2022-11-01T18:24:56.679Z"
}, {
	filename: "fun/finish.bin",
	bytes: 29597,
	lastChange: "2022-11-01T18:24:56.679Z"
}, {
	filename: "fun/finish.json",
	bytes: 2951375,
	lastChange: "2022-11-01T18:24:56.691Z"
}, {
	filename: "fun/frame.bin",
	bytes: 2359,
	lastChange: "2022-11-01T18:24:56.691Z"
}, {
	filename: "fun/frame.json",
	bytes: 149270,
	lastChange: "2022-11-01T18:24:56.691Z"
}, {
	filename: "fun/hitmesh.bin",
	bytes: 32918,
	lastChange: "2022-11-01T18:24:56.691Z"
}, {
	filename: "fun/hitmesh.json",
	bytes: 3034020,
	lastChange: "2022-11-01T18:24:56.703Z"
}, {
	filename: "fun/horizonclouds.bin",
	bytes: 16931,
	lastChange: "2022-11-01T18:24:56.703Z"
}, {
	filename: "fun/horizonclouds.json",
	bytes: 5769678,
	lastChange: "2022-11-01T18:24:56.723Z"
}, {
	filename: "fun/maze.bin",
	bytes: 16265,
	lastChange: "2022-11-01T18:24:56.723Z"
}, {
	filename: "fun/maze.json",
	bytes: 1461280,
	lastChange: "2022-11-01T18:24:56.739Z"
}, {
	filename: "fun/platforms.bin",
	bytes: 7216,
	lastChange: "2022-11-01T18:24:56.739Z"
}, {
	filename: "fun/platforms.json",
	bytes: 472179,
	lastChange: "2022-11-01T18:24:56.743Z"
}, {
	filename: "fun/shaderball.bin",
	bytes: 102551,
	lastChange: "2022-11-01T18:24:56.743Z"
}, {
	filename: "fun/shaderball.json",
	bytes: 14824157,
	lastChange: "2022-11-01T18:24:56.811Z"
}, {
	filename: "fun/spinner1.bin",
	bytes: 3832,
	lastChange: "2022-11-01T18:24:56.811Z"
}, {
	filename: "fun/spinner1.json",
	bytes: 273104,
	lastChange: "2022-11-01T18:24:56.811Z"
}, {
	filename: "fun/spinner1_bounds.json",
	bytes: 427,
	lastChange: "2022-11-01T18:24:56.811Z"
}, {
	filename: "fun/spinner1_bounds_dynamic.json",
	bytes: 681,
	lastChange: "2022-11-01T18:24:56.811Z"
}, {
	filename: "fun/spinner2.bin",
	bytes: 3943,
	lastChange: "2022-11-01T18:24:56.811Z"
}, {
	filename: "fun/spinner2.json",
	bytes: 272579,
	lastChange: "2022-11-01T18:24:56.815Z"
}, {
	filename: "fun/spinner2_bounds.json",
	bytes: 428,
	lastChange: "2022-11-01T18:24:56.815Z"
}, {
	filename: "fun/spinner2_bounds_dynamic.json",
	bytes: 681,
	lastChange: "2022-11-01T18:24:56.815Z"
}, {
	filename: "fun/spinner3.bin",
	bytes: 5640,
	lastChange: "2022-11-01T18:24:56.815Z"
}, {
	filename: "fun/spinner3.json",
	bytes: 449975,
	lastChange: "2022-11-01T18:24:56.815Z"
}, {
	filename: "fun/spinner3_bounds.json",
	bytes: 499,
	lastChange: "2022-11-01T18:24:56.815Z"
}, {
	filename: "fun/spinner3_bounds_dynamic.json",
	bytes: 788,
	lastChange: "2022-11-01T18:24:56.815Z"
}, {
	filename: "galaxy/centerpiece.bin",
	bytes: 14932,
	lastChange: "2022-11-01T18:24:56.815Z"
}, {
	filename: "galaxy/centerpiece.json",
	bytes: 1135889,
	lastChange: "2022-11-01T18:24:56.823Z"
}, {
	filename: "galaxy/crystal.bin",
	bytes: 4883,
	lastChange: "2022-11-01T18:24:56.823Z"
}, {
	filename: "galaxy/crystal.json",
	bytes: 269518,
	lastChange: "2022-11-01T18:24:56.823Z"
}, {
	filename: "galaxy/double_portal.json",
	bytes: 130682,
	lastChange: "2022-11-01T18:24:56.823Z"
}, {
	filename: "galaxy/hitmesh.bin",
	bytes: 98303,
	lastChange: "2022-11-01T18:24:56.823Z"
}, {
	filename: "galaxy/hitmesh.json",
	bytes: 9244807,
	lastChange: "2022-11-01T18:24:56.871Z"
}, {
	filename: "galaxy/intro_inner.json",
	bytes: 335328,
	lastChange: "2022-11-01T18:24:56.875Z"
}, {
	filename: "galaxy/platform.bin",
	bytes: 16567,
	lastChange: "2022-11-01T18:24:56.875Z"
}, {
	filename: "galaxy/platform.json",
	bytes: 1778382,
	lastChange: "2022-11-01T18:24:56.883Z"
}, {
	filename: "galaxy/portals.bin",
	bytes: 59429,
	lastChange: "2022-11-01T18:24:56.883Z"
}, {
	filename: "galaxy/portals.json",
	bytes: 6071405,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/A_lobby.bin",
	bytes: 25645,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/A_lobby_curtains.bin",
	bytes: 15108,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/A_lobby_floor.bin",
	bytes: 380,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/B_museum.bin",
	bytes: 30579,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/B_museum_floor.bin",
	bytes: 289,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/C_octagon.bin",
	bytes: 35800,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/C_octagon_cushions.bin",
	bytes: 5055,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/C_octagon_floors.bin",
	bytes: 24434,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/C_octagon_walls.bin",
	bytes: 11071,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/D_transition.bin",
	bytes: 42427,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/D_transition_crystal.bin",
	bytes: 27927,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/E_island.bin",
	bytes: 81006,
	lastChange: "2022-11-01T18:24:56.915Z"
}, {
	filename: "gallery/F_end.bin",
	bytes: 233629,
	lastChange: "2022-11-01T18:24:56.919Z"
}, {
	filename: "gallery/G_floating_islands.bin",
	bytes: 22349,
	lastChange: "2022-11-01T18:24:56.919Z"
}, {
	filename: "gallery/hitmesh.bin",
	bytes: 135567,
	lastChange: "2022-11-01T18:24:56.919Z"
}, {
	filename: "gallery/island_gates.bin",
	bytes: 30681,
	lastChange: "2022-11-01T18:24:56.919Z"
}, {
	filename: "gallery/octagon_waterfall.bin",
	bytes: 11230,
	lastChange: "2022-11-01T18:24:56.919Z"
}, {
	filename: "gallery/singleleaf.json",
	bytes: 394,
	lastChange: "2022-11-01T18:24:56.919Z"
}, {
	filename: "gallery/tree_foliage.bin",
	bytes: 6375,
	lastChange: "2022-11-01T18:24:56.919Z"
}, {
	filename: "gallery/water_mesh.bin",
	bytes: 2097,
	lastChange: "2022-11-01T18:24:56.919Z"
}, {
	filename: "gallery/waterfalls_outside.bin",
	bytes: 17451,
	lastChange: "2022-11-01T18:24:56.919Z"
}, {
	filename: "garden/butterfly.json",
	bytes: 689,
	lastChange: "2022-11-01T18:24:56.919Z"
}, {
	filename: "garden/grass_instances.json",
	bytes: 6362679,
	lastChange: "2022-11-01T18:24:56.955Z"
}, {
	filename: "garden/grass_instances06.json",
	bytes: 7635754,
	lastChange: "2022-11-01T18:24:56.999Z"
}, {
	filename: "garden/grass_instances_UVs.json",
	bytes: 4124730,
	lastChange: "2022-11-01T18:24:57.019Z"
}, {
	filename: "garden/grass_mesh.json",
	bytes: 1626,
	lastChange: "2022-11-01T18:24:57.023Z"
}, {
	filename: "garden/ground.bin",
	bytes: 229550,
	lastChange: "2022-11-01T18:24:57.023Z"
}, {
	filename: "garden/ground_2.bin",
	bytes: 290550,
	lastChange: "2022-11-01T18:24:57.023Z"
}, {
	filename: "garden/hitmesh.bin",
	bytes: 192763,
	lastChange: "2022-11-01T18:24:57.023Z"
}, {
	filename: "garden/simplebird.json",
	bytes: 6217,
	lastChange: "2022-11-01T18:24:57.023Z"
}, {
	filename: "garden/var8_billboard_LOD3.json",
	bytes: 662,
	lastChange: "2022-11-01T18:24:57.023Z"
}, {
	filename: "garden/water.json",
	bytes: 14764,
	lastChange: "2022-11-01T18:24:57.023Z"
}, {
	filename: "garden/water2.json",
	bytes: 892122,
	lastChange: "2022-11-01T18:24:57.027Z"
}, {
	filename: "grass_instancesUV.json",
	bytes: 4247231,
	lastChange: "2022-11-01T18:24:57.051Z"
}, {
	filename: "hitmesh.bin",
	bytes: 135567,
	lastChange: "2022-11-01T18:24:57.051Z"
}, {
	filename: "hitmesh_merged.bin",
	bytes: 301312,
	lastChange: "2022-11-01T18:24:57.051Z"
}, {
	filename: "hitmesh_merged.json",
	bytes: 29958897,
	lastChange: "2022-11-01T18:24:57.199Z"
}, {
	filename: "hotspot/screens.json",
	bytes: 16988,
	lastChange: "2022-11-01T18:24:57.203Z"
}, {
	filename: "init/hitmesh.bin",
	bytes: 428184,
	lastChange: "2022-11-01T18:24:57.203Z"
}, {
	filename: "init/roomA.bin",
	bytes: 14568,
	lastChange: "2022-11-01T18:24:57.203Z"
}, {
	filename: "init/roomB.bin",
	bytes: 33307,
	lastChange: "2022-11-01T18:24:57.203Z"
}, {
	filename: "init/roomC.bin",
	bytes: 19380,
	lastChange: "2022-11-01T18:24:57.203Z"
}, {
	filename: "kinetic/torus.bin",
	bytes: 969,
	lastChange: "2022-11-01T18:24:57.203Z"
}, {
	filename: "kinetic/torus.json",
	bytes: 39339,
	lastChange: "2022-11-01T18:24:57.207Z"
}, {
	filename: "lidar/arsham/arsham-128.json",
	bytes: 547594,
	lastChange: "2022-11-01T18:24:57.207Z"
}, {
	filename: "lidar/arsham/arsham-256.json",
	bytes: 2189865,
	lastChange: "2022-11-01T18:24:57.219Z"
}, {
	filename: "lidar/arsham/arsham-512.json",
	bytes: 8756502,
	lastChange: "2022-11-01T18:24:57.263Z"
}, {
	filename: "lidar/arsham2/arsham2-128.json",
	bytes: 547302,
	lastChange: "2022-11-01T18:24:57.263Z"
}, {
	filename: "lidar/arsham2/arsham2-256.json",
	bytes: 2189516,
	lastChange: "2022-11-01T18:24:57.275Z"
}, {
	filename: "lidar/arsham2/arsham2-512.json",
	bytes: 8756064,
	lastChange: "2022-11-01T18:24:57.319Z"
}, {
	filename: "lidar/decentraland2/skyline2-128.json",
	bytes: 581368,
	lastChange: "2022-11-01T18:24:57.323Z"
}, {
	filename: "lidar/decentraland2/skyline2-256.json",
	bytes: 2324937,
	lastChange: "2022-11-01T18:24:57.335Z"
}, {
	filename: "lidar/decentraland2/skyline2-512.json",
	bytes: 9299606,
	lastChange: "2022-11-01T18:24:57.383Z"
}, {
	filename: "lidar/fairground/fairground-128.json",
	bytes: 569177,
	lastChange: "2022-11-01T18:24:57.387Z"
}, {
	filename: "lidar/fairground/fairground-256.json",
	bytes: 2279846,
	lastChange: "2022-11-01T18:24:57.395Z"
}, {
	filename: "lidar/fairground/fairground-512.json",
	bytes: 9129236,
	lastChange: "2022-11-01T18:24:57.439Z"
}, {
	filename: "lidar/house/house-128.json",
	bytes: 536696,
	lastChange: "2022-11-01T18:24:57.443Z"
}, {
	filename: "lidar/house/house-256.json",
	bytes: 2145968,
	lastChange: "2022-11-01T18:24:57.451Z"
}, {
	filename: "lidar/house/house-512.json",
	bytes: 8588983,
	lastChange: "2022-11-01T18:24:57.491Z"
}, {
	filename: "lidar/subway/subway-128.json",
	bytes: 529295,
	lastChange: "2022-11-01T18:24:57.495Z"
}, {
	filename: "lidar/subway/subway-256.json",
	bytes: 2116614,
	lastChange: "2022-11-01T18:24:57.503Z"
}, {
	filename: "lidar/subway/subway-512.json",
	bytes: 8462018,
	lastChange: "2022-11-01T18:24:57.543Z"
}, {
	filename: "lidar/sushi/sushi-128.json",
	bytes: 548748,
	lastChange: "2022-11-01T18:24:57.547Z"
}, {
	filename: "lidar/sushi/sushi-256.json",
	bytes: 2194984,
	lastChange: "2022-11-01T18:24:57.555Z"
}, {
	filename: "lidar/sushi/sushi-512.json",
	bytes: 8778360,
	lastChange: "2022-11-01T18:24:57.599Z"
}, {
	filename: "lidar/tvstudio/tvstudio-128.json",
	bytes: 555303,
	lastChange: "2022-11-01T18:24:57.603Z"
}, {
	filename: "lidar/tvstudio/tvstudio-256.json",
	bytes: 2221556,
	lastChange: "2022-11-01T18:24:57.611Z"
}, {
	filename: "lidar/tvstudio/tvstudio-512.json",
	bytes: 8886052,
	lastChange: "2022-11-01T18:24:57.659Z"
}, {
	filename: "light_shafts.bin",
	bytes: 13335,
	lastChange: "2022-11-01T18:24:57.659Z"
}, {
	filename: "middle_earth.bin",
	bytes: 110235,
	lastChange: "2022-11-01T18:24:57.659Z"
}, {
	filename: "npcs/1/base-npc.json",
	bytes: 1769559,
	lastChange: "2022-11-01T18:24:57.667Z"
}, {
	filename: "npcs/1/idle.json",
	bytes: 296134,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "npcs/1/talking.json",
	bytes: 291655,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "npcs/1/text-complete.vtt",
	bytes: 117,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "npcs/1/text-progress.vtt",
	bytes: 77,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "npcs/1/text.vtt",
	bytes: 123,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "path.bin",
	bytes: 4146,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "path.json",
	bytes: 18372,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "platform/12m_disc.bin",
	bytes: 506,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "platform/12m_disc.json",
	bytes: 7644,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "platforms.bin",
	bytes: 362287,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "roomA.bin",
	bytes: 14568,
	lastChange: "2022-11-01T18:24:57.671Z"
}, {
	filename: "roomA_hitmesh.bin",
	bytes: 115468,
	lastChange: "2022-11-01T18:24:57.675Z"
}, {
	filename: "roomA_hitmesh.json",
	bytes: 14985085,
	lastChange: "2022-11-01T18:24:57.739Z"
}, {
	filename: "roomB.bin",
	bytes: 33307,
	lastChange: "2022-11-01T18:24:57.739Z"
}, {
	filename: "roomC.bin",
	bytes: 19521,
	lastChange: "2022-11-01T18:24:57.739Z"
}, {
	filename: "tree_instancesUV.json",
	bytes: 2596506,
	lastChange: "2022-11-01T18:24:57.755Z"
}, {
	filename: "tvstudiolight.bin",
	bytes: 20197,
	lastChange: "2022-11-01T18:24:57.755Z"
}, {
	filename: "tvstudiolight.json",
	bytes: 1841419,
	lastChange: "2022-11-01T18:24:57.763Z"
}, {
	filename: "water.bin",
	bytes: 3383,
	lastChange: "2022-11-01T18:24:57.763Z"
}], window.UIL_ASSETS_TEXTURES = [{
	filename: "A_lobby/A_lobby-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:57.775Z"
}, {
	filename: "A_lobby/A_lobby-astc.ktx.gz",
	bytes: 366971,
	lastChange: "2022-11-01T18:24:57.779Z"
}, {
	filename: "A_lobby/A_lobby-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:57.791Z"
}, {
	filename: "A_lobby/A_lobby-dxt.ktx.gz",
	bytes: 616620,
	lastChange: "2022-11-01T18:24:57.795Z"
}, {
	filename: "A_lobby/A_lobby-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:57.811Z"
}, {
	filename: "A_lobby/A_lobby-pvrtc.ktx.gz",
	bytes: 1053939,
	lastChange: "2022-11-01T18:24:57.819Z"
}, {
	filename: "A_lobby.jpg",
	bytes: 538274,
	lastChange: "2022-11-01T18:24:57.767Z"
}, {
	filename: "A_lobby_curtains/A_lobby_curtains-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:57.823Z"
}, {
	filename: "A_lobby_curtains/A_lobby_curtains-astc.ktx.gz",
	bytes: 182749,
	lastChange: "2022-11-01T18:24:57.823Z"
}, {
	filename: "A_lobby_curtains/A_lobby_curtains-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:57.827Z"
}, {
	filename: "A_lobby_curtains/A_lobby_curtains-dxt.ktx.gz",
	bytes: 249242,
	lastChange: "2022-11-01T18:24:57.831Z"
}, {
	filename: "A_lobby_curtains/A_lobby_curtains-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:57.835Z"
}, {
	filename: "A_lobby_curtains/A_lobby_curtains-pvrtc.ktx.gz",
	bytes: 304066,
	lastChange: "2022-11-01T18:24:57.839Z"
}, {
	filename: "A_lobby_curtains.jpg",
	bytes: 236520,
	lastChange: "2022-11-01T18:24:57.819Z"
}, {
	filename: "A_lobby_envMap-diffuse-sRGB/A_lobby_envMap-diffuse-sRGB-astc.ktx",
	bytes: 16484,
	lastChange: "2022-11-01T18:24:57.839Z"
}, {
	filename: "A_lobby_envMap-diffuse-sRGB/A_lobby_envMap-diffuse-sRGB-astc.ktx.gz",
	bytes: 10443,
	lastChange: "2022-11-01T18:24:57.839Z"
}, {
	filename: "A_lobby_envMap-diffuse-sRGB/A_lobby_envMap-diffuse-sRGB-dxt.ktx",
	bytes: 16504,
	lastChange: "2022-11-01T18:24:57.839Z"
}, {
	filename: "A_lobby_envMap-diffuse-sRGB/A_lobby_envMap-diffuse-sRGB-dxt.ktx.gz",
	bytes: 3553,
	lastChange: "2022-11-01T18:24:57.839Z"
}, {
	filename: "A_lobby_envMap-diffuse-sRGB/A_lobby_envMap-diffuse-sRGB-pvrtc.ktx",
	bytes: 8292,
	lastChange: "2022-11-01T18:24:57.839Z"
}, {
	filename: "A_lobby_envMap-diffuse-sRGB/A_lobby_envMap-diffuse-sRGB-pvrtc.ktx.gz",
	bytes: 4544,
	lastChange: "2022-11-01T18:24:57.839Z"
}, {
	filename: "A_lobby_envMap-diffuse-sRGB.png",
	bytes: 7351,
	lastChange: "2022-11-01T18:24:57.839Z"
}, {
	filename: "A_lobby_envMap-specular-sRGB/A_lobby_envMap-specular-sRGB-astc.ktx",
	bytes: 262244,
	lastChange: "2022-11-01T18:24:57.843Z"
}, {
	filename: "A_lobby_envMap-specular-sRGB/A_lobby_envMap-specular-sRGB-astc.ktx.gz",
	bytes: 146338,
	lastChange: "2022-11-01T18:24:57.843Z"
}, {
	filename: "A_lobby_envMap-specular-sRGB/A_lobby_envMap-specular-sRGB-dxt.ktx",
	bytes: 262264,
	lastChange: "2022-11-01T18:24:57.847Z"
}, {
	filename: "A_lobby_envMap-specular-sRGB/A_lobby_envMap-specular-sRGB-dxt.ktx.gz",
	bytes: 53294,
	lastChange: "2022-11-01T18:24:57.847Z"
}, {
	filename: "A_lobby_envMap-specular-sRGB/A_lobby_envMap-specular-sRGB-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:57.847Z"
}, {
	filename: "A_lobby_envMap-specular-sRGB/A_lobby_envMap-specular-sRGB-pvrtc.ktx.gz",
	bytes: 69973,
	lastChange: "2022-11-01T18:24:57.847Z"
}, {
	filename: "A_lobby_envMap-specular-sRGB.png",
	bytes: 420444,
	lastChange: "2022-11-01T18:24:57.843Z"
}, {
	filename: "A_lobby_floor_BaseColor/A_lobby_floor_BaseColor-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:57.855Z"
}, {
	filename: "A_lobby_floor_BaseColor/A_lobby_floor_BaseColor-astc.ktx.gz",
	bytes: 330077,
	lastChange: "2022-11-01T18:24:57.855Z"
}, {
	filename: "A_lobby_floor_BaseColor/A_lobby_floor_BaseColor-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:57.859Z"
}, {
	filename: "A_lobby_floor_BaseColor/A_lobby_floor_BaseColor-dxt.ktx.gz",
	bytes: 362154,
	lastChange: "2022-11-01T18:24:57.863Z"
}, {
	filename: "A_lobby_floor_BaseColor/A_lobby_floor_BaseColor-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:57.867Z"
}, {
	filename: "A_lobby_floor_BaseColor/A_lobby_floor_BaseColor-pvrtc.ktx.gz",
	bytes: 364782,
	lastChange: "2022-11-01T18:24:57.871Z"
}, {
	filename: "A_lobby_floor_BaseColor.jpg",
	bytes: 208949,
	lastChange: "2022-11-01T18:24:57.847Z"
}, {
	filename: "A_lobby_floor_MRO/A_lobby_floor_MRO-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:57.871Z"
}, {
	filename: "A_lobby_floor_MRO/A_lobby_floor_MRO-astc.ktx.gz",
	bytes: 8244,
	lastChange: "2022-11-01T18:24:57.871Z"
}, {
	filename: "A_lobby_floor_MRO/A_lobby_floor_MRO-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:57.871Z"
}, {
	filename: "A_lobby_floor_MRO/A_lobby_floor_MRO-dxt.ktx.gz",
	bytes: 46406,
	lastChange: "2022-11-01T18:24:57.875Z"
}, {
	filename: "A_lobby_floor_MRO/A_lobby_floor_MRO-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:57.875Z"
}, {
	filename: "A_lobby_floor_MRO/A_lobby_floor_MRO-pvrtc.ktx.gz",
	bytes: 120521,
	lastChange: "2022-11-01T18:24:57.875Z"
}, {
	filename: "A_lobby_floor_MRO.jpg",
	bytes: 25679,
	lastChange: "2022-11-01T18:24:57.871Z"
}, {
	filename: "A_lobby_floor_diffuse.jpg",
	bytes: 2797094,
	lastChange: "2022-11-01T18:24:57.895Z"
}, {
	filename: "A_lobby_floor_lightmap/A_lobby_floor_lightmap-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:57.907Z"
}, {
	filename: "A_lobby_floor_lightmap/A_lobby_floor_lightmap-astc.ktx.gz",
	bytes: 235956,
	lastChange: "2022-11-01T18:24:57.907Z"
}, {
	filename: "A_lobby_floor_lightmap/A_lobby_floor_lightmap-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:57.919Z"
}, {
	filename: "A_lobby_floor_lightmap/A_lobby_floor_lightmap-dxt.ktx.gz",
	bytes: 454553,
	lastChange: "2022-11-01T18:24:57.919Z"
}, {
	filename: "A_lobby_floor_lightmap/A_lobby_floor_lightmap-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:57.939Z"
}, {
	filename: "A_lobby_floor_lightmap/A_lobby_floor_lightmap-pvrtc.ktx.gz",
	bytes: 985688,
	lastChange: "2022-11-01T18:24:57.943Z"
}, {
	filename: "A_lobby_floor_lightmap.jpg",
	bytes: 340817,
	lastChange: "2022-11-01T18:24:57.899Z"
}, {
	filename: "A_lobby_floor_normal/A_lobby_floor_normal-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:57.947Z"
}, {
	filename: "A_lobby_floor_normal/A_lobby_floor_normal-astc.ktx.gz",
	bytes: 202896,
	lastChange: "2022-11-01T18:24:57.951Z"
}, {
	filename: "A_lobby_floor_normal/A_lobby_floor_normal-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:57.955Z"
}, {
	filename: "A_lobby_floor_normal/A_lobby_floor_normal-dxt.ktx.gz",
	bytes: 277227,
	lastChange: "2022-11-01T18:24:57.955Z"
}, {
	filename: "A_lobby_floor_normal/A_lobby_floor_normal-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:57.959Z"
}, {
	filename: "A_lobby_floor_normal/A_lobby_floor_normal-pvrtc.ktx.gz",
	bytes: 318921,
	lastChange: "2022-11-01T18:24:57.963Z"
}, {
	filename: "A_lobby_floor_normal.jpg",
	bytes: 145074,
	lastChange: "2022-11-01T18:24:57.943Z"
}, {
	filename: "B_museum/B_museum-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:57.979Z"
}, {
	filename: "B_museum/B_museum-astc.ktx.gz",
	bytes: 529270,
	lastChange: "2022-11-01T18:24:57.983Z"
}, {
	filename: "B_museum/B_museum-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:57.999Z"
}, {
	filename: "B_museum/B_museum-dxt.ktx.gz",
	bytes: 819649,
	lastChange: "2022-11-01T18:24:58.003Z"
}, {
	filename: "B_museum/B_museum-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.023Z"
}, {
	filename: "B_museum/B_museum-pvrtc.ktx.gz",
	bytes: 1173718,
	lastChange: "2022-11-01T18:24:58.031Z"
}, {
	filename: "B_museum.jpg",
	bytes: 724202,
	lastChange: "2022-11-01T18:24:57.967Z"
}, {
	filename: "B_museum_envMap-diffuse-sRGB/B_museum_envMap-diffuse-sRGB-astc.ktx",
	bytes: 16484,
	lastChange: "2022-11-01T18:24:58.031Z"
}, {
	filename: "B_museum_envMap-diffuse-sRGB/B_museum_envMap-diffuse-sRGB-astc.ktx.gz",
	bytes: 14487,
	lastChange: "2022-11-01T18:24:58.031Z"
}, {
	filename: "B_museum_envMap-diffuse-sRGB/B_museum_envMap-diffuse-sRGB-dxt.ktx",
	bytes: 16504,
	lastChange: "2022-11-01T18:24:58.035Z"
}, {
	filename: "B_museum_envMap-diffuse-sRGB/B_museum_envMap-diffuse-sRGB-dxt.ktx.gz",
	bytes: 5090,
	lastChange: "2022-11-01T18:24:58.035Z"
}, {
	filename: "B_museum_envMap-diffuse-sRGB/B_museum_envMap-diffuse-sRGB-pvrtc.ktx",
	bytes: 8292,
	lastChange: "2022-11-01T18:24:58.035Z"
}, {
	filename: "B_museum_envMap-diffuse-sRGB/B_museum_envMap-diffuse-sRGB-pvrtc.ktx.gz",
	bytes: 5372,
	lastChange: "2022-11-01T18:24:58.035Z"
}, {
	filename: "B_museum_envMap-diffuse-sRGB.png",
	bytes: 9349,
	lastChange: "2022-11-01T18:24:58.031Z"
}, {
	filename: "B_museum_envMap-specular-sRGB/B_museum_envMap-specular-sRGB-astc.ktx",
	bytes: 262244,
	lastChange: "2022-11-01T18:24:58.039Z"
}, {
	filename: "B_museum_envMap-specular-sRGB/B_museum_envMap-specular-sRGB-astc.ktx.gz",
	bytes: 164502,
	lastChange: "2022-11-01T18:24:58.039Z"
}, {
	filename: "B_museum_envMap-specular-sRGB/B_museum_envMap-specular-sRGB-dxt.ktx",
	bytes: 262264,
	lastChange: "2022-11-01T18:24:58.043Z"
}, {
	filename: "B_museum_envMap-specular-sRGB/B_museum_envMap-specular-sRGB-dxt.ktx.gz",
	bytes: 65848,
	lastChange: "2022-11-01T18:24:58.043Z"
}, {
	filename: "B_museum_envMap-specular-sRGB/B_museum_envMap-specular-sRGB-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:58.043Z"
}, {
	filename: "B_museum_envMap-specular-sRGB/B_museum_envMap-specular-sRGB-pvrtc.ktx.gz",
	bytes: 82474,
	lastChange: "2022-11-01T18:24:58.043Z"
}, {
	filename: "B_museum_envMap-specular-sRGB.png",
	bytes: 533662,
	lastChange: "2022-11-01T18:24:58.039Z"
}, {
	filename: "B_museum_floor.jpg",
	bytes: 695281,
	lastChange: "2022-11-01T18:24:58.047Z"
}, {
	filename: "B_museum_floor_BaseColor/B_museum_floor_BaseColor-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:58.055Z"
}, {
	filename: "B_museum_floor_BaseColor/B_museum_floor_BaseColor-astc.ktx.gz",
	bytes: 350609,
	lastChange: "2022-11-01T18:24:58.055Z"
}, {
	filename: "B_museum_floor_BaseColor/B_museum_floor_BaseColor-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:58.063Z"
}, {
	filename: "B_museum_floor_BaseColor/B_museum_floor_BaseColor-dxt.ktx.gz",
	bytes: 367638,
	lastChange: "2022-11-01T18:24:58.063Z"
}, {
	filename: "B_museum_floor_BaseColor/B_museum_floor_BaseColor-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:58.071Z"
}, {
	filename: "B_museum_floor_BaseColor/B_museum_floor_BaseColor-pvrtc.ktx.gz",
	bytes: 373327,
	lastChange: "2022-11-01T18:24:58.071Z"
}, {
	filename: "B_museum_floor_BaseColor.jpg",
	bytes: 209166,
	lastChange: "2022-11-01T18:24:58.051Z"
}, {
	filename: "B_museum_floor_MRO/B_museum_floor_MRO-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:58.075Z"
}, {
	filename: "B_museum_floor_MRO/B_museum_floor_MRO-astc.ktx.gz",
	bytes: 229528,
	lastChange: "2022-11-01T18:24:58.079Z"
}, {
	filename: "B_museum_floor_MRO/B_museum_floor_MRO-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:58.083Z"
}, {
	filename: "B_museum_floor_MRO/B_museum_floor_MRO-dxt.ktx.gz",
	bytes: 312368,
	lastChange: "2022-11-01T18:24:58.083Z"
}, {
	filename: "B_museum_floor_MRO/B_museum_floor_MRO-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:58.091Z"
}, {
	filename: "B_museum_floor_MRO/B_museum_floor_MRO-pvrtc.ktx.gz",
	bytes: 315004,
	lastChange: "2022-11-01T18:24:58.091Z"
}, {
	filename: "B_museum_floor_MRO.jpg",
	bytes: 157166,
	lastChange: "2022-11-01T18:24:58.071Z"
}, {
	filename: "B_museum_floor_Normal/B_museum_floor_Normal-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:58.099Z"
}, {
	filename: "B_museum_floor_Normal/B_museum_floor_Normal-astc.ktx.gz",
	bytes: 63906,
	lastChange: "2022-11-01T18:24:58.099Z"
}, {
	filename: "B_museum_floor_Normal/B_museum_floor_Normal-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:58.103Z"
}, {
	filename: "B_museum_floor_Normal/B_museum_floor_Normal-dxt.ktx.gz",
	bytes: 143188,
	lastChange: "2022-11-01T18:24:58.103Z"
}, {
	filename: "B_museum_floor_Normal/B_museum_floor_Normal-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:58.107Z"
}, {
	filename: "B_museum_floor_Normal/B_museum_floor_Normal-pvrtc.ktx.gz",
	bytes: 282205,
	lastChange: "2022-11-01T18:24:58.107Z"
}, {
	filename: "B_museum_floor_Normal.jpg",
	bytes: 75082,
	lastChange: "2022-11-01T18:24:58.091Z"
}, {
	filename: "B_museum_floor_lightmap/B_museum_floor_lightmap-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.119Z"
}, {
	filename: "B_museum_floor_lightmap/B_museum_floor_lightmap-astc.ktx.gz",
	bytes: 366170,
	lastChange: "2022-11-01T18:24:58.123Z"
}, {
	filename: "B_museum_floor_lightmap/B_museum_floor_lightmap-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.135Z"
}, {
	filename: "B_museum_floor_lightmap/B_museum_floor_lightmap-dxt.ktx.gz",
	bytes: 671806,
	lastChange: "2022-11-01T18:24:58.139Z"
}, {
	filename: "B_museum_floor_lightmap/B_museum_floor_lightmap-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.155Z"
}, {
	filename: "B_museum_floor_lightmap/B_museum_floor_lightmap-pvrtc.ktx.gz",
	bytes: 990601,
	lastChange: "2022-11-01T18:24:58.163Z"
}, {
	filename: "B_museum_floor_lightmap.jpg",
	bytes: 272686,
	lastChange: "2022-11-01T18:24:58.111Z"
}, {
	filename: "COIN_PBR_01/AO.png",
	bytes: 8575,
	lastChange: "2022-11-01T18:24:58.163Z"
}, {
	filename: "COIN_PBR_01/AXIE_COIN_default_BaseColor.png",
	bytes: 62508,
	lastChange: "2022-11-01T18:24:58.163Z"
}, {
	filename: "COIN_PBR_01/AXIE_COIN_default_Metallic-combined.png",
	bytes: 1573929,
	lastChange: "2022-11-01T18:24:58.175Z"
}, {
	filename: "COIN_PBR_01/AXIE_COIN_default_Metallic.png",
	bytes: 8575,
	lastChange: "2022-11-01T18:24:58.175Z"
}, {
	filename: "COIN_PBR_01/AXIE_COIN_default_Normal.png",
	bytes: 2560702,
	lastChange: "2022-11-01T18:24:58.191Z"
}, {
	filename: "COIN_PBR_01/AXIE_COIN_default_Roughness.png",
	bytes: 853097,
	lastChange: "2022-11-01T18:24:58.195Z"
}, {
	filename: "C_octagon/C_octagon-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.211Z"
}, {
	filename: "C_octagon/C_octagon-astc.ktx.gz",
	bytes: 465296,
	lastChange: "2022-11-01T18:24:58.215Z"
}, {
	filename: "C_octagon/C_octagon-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.227Z"
}, {
	filename: "C_octagon/C_octagon-dxt.ktx.gz",
	bytes: 781367,
	lastChange: "2022-11-01T18:24:58.231Z"
}, {
	filename: "C_octagon/C_octagon-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.251Z"
}, {
	filename: "C_octagon/C_octagon-pvrtc.ktx.gz",
	bytes: 1178834,
	lastChange: "2022-11-01T18:24:58.259Z"
}, {
	filename: "C_octagon.jpg",
	bytes: 623250,
	lastChange: "2022-11-01T18:24:58.199Z"
}, {
	filename: "C_octagon_cushions/C_octagon_cushions-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:58.263Z"
}, {
	filename: "C_octagon_cushions/C_octagon_cushions-astc.ktx.gz",
	bytes: 145640,
	lastChange: "2022-11-01T18:24:58.263Z"
}, {
	filename: "C_octagon_cushions/C_octagon_cushions-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:58.267Z"
}, {
	filename: "C_octagon_cushions/C_octagon_cushions-dxt.ktx.gz",
	bytes: 196443,
	lastChange: "2022-11-01T18:24:58.271Z"
}, {
	filename: "C_octagon_cushions/C_octagon_cushions-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:58.275Z"
}, {
	filename: "C_octagon_cushions/C_octagon_cushions-pvrtc.ktx.gz",
	bytes: 291314,
	lastChange: "2022-11-01T18:24:58.275Z"
}, {
	filename: "C_octagon_cushions.jpg",
	bytes: 228632,
	lastChange: "2022-11-01T18:24:58.259Z"
}, {
	filename: "C_octagon_envMap-diffuse-sRGB/C_octagon_envMap-diffuse-sRGB-astc.ktx",
	bytes: 16484,
	lastChange: "2022-11-01T18:24:58.279Z"
}, {
	filename: "C_octagon_envMap-diffuse-sRGB/C_octagon_envMap-diffuse-sRGB-astc.ktx.gz",
	bytes: 12591,
	lastChange: "2022-11-01T18:24:58.279Z"
}, {
	filename: "C_octagon_envMap-diffuse-sRGB/C_octagon_envMap-diffuse-sRGB-dxt.ktx",
	bytes: 16504,
	lastChange: "2022-11-01T18:24:58.279Z"
}, {
	filename: "C_octagon_envMap-diffuse-sRGB/C_octagon_envMap-diffuse-sRGB-dxt.ktx.gz",
	bytes: 4345,
	lastChange: "2022-11-01T18:24:58.279Z"
}, {
	filename: "C_octagon_envMap-diffuse-sRGB/C_octagon_envMap-diffuse-sRGB-pvrtc.ktx",
	bytes: 8292,
	lastChange: "2022-11-01T18:24:58.279Z"
}, {
	filename: "C_octagon_envMap-diffuse-sRGB/C_octagon_envMap-diffuse-sRGB-pvrtc.ktx.gz",
	bytes: 4867,
	lastChange: "2022-11-01T18:24:58.279Z"
}, {
	filename: "C_octagon_envMap-diffuse-sRGB.png",
	bytes: 7469,
	lastChange: "2022-11-01T18:24:58.279Z"
}, {
	filename: "C_octagon_envMap-specular-sRGB/C_octagon_envMap-specular-sRGB-astc.ktx",
	bytes: 262244,
	lastChange: "2022-11-01T18:24:58.283Z"
}, {
	filename: "C_octagon_envMap-specular-sRGB/C_octagon_envMap-specular-sRGB-astc.ktx.gz",
	bytes: 125634,
	lastChange: "2022-11-01T18:24:58.283Z"
}, {
	filename: "C_octagon_envMap-specular-sRGB/C_octagon_envMap-specular-sRGB-dxt.ktx",
	bytes: 262264,
	lastChange: "2022-11-01T18:24:58.283Z"
}, {
	filename: "C_octagon_envMap-specular-sRGB/C_octagon_envMap-specular-sRGB-dxt.ktx.gz",
	bytes: 45063,
	lastChange: "2022-11-01T18:24:58.283Z"
}, {
	filename: "C_octagon_envMap-specular-sRGB/C_octagon_envMap-specular-sRGB-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:58.283Z"
}, {
	filename: "C_octagon_envMap-specular-sRGB/C_octagon_envMap-specular-sRGB-pvrtc.ktx.gz",
	bytes: 66395,
	lastChange: "2022-11-01T18:24:58.287Z"
}, {
	filename: "C_octagon_envMap-specular-sRGB.png",
	bytes: 347872,
	lastChange: "2022-11-01T18:24:58.279Z"
}, {
	filename: "C_octagon_floors/C_octagon_floors-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.307Z"
}, {
	filename: "C_octagon_floors/C_octagon_floors-astc.ktx.gz",
	bytes: 1093954,
	lastChange: "2022-11-01T18:24:58.315Z"
}, {
	filename: "C_octagon_floors/C_octagon_floors-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.331Z"
}, {
	filename: "C_octagon_floors/C_octagon_floors-dxt.ktx.gz",
	bytes: 1229319,
	lastChange: "2022-11-01T18:24:58.335Z"
}, {
	filename: "C_octagon_floors/C_octagon_floors-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.355Z"
}, {
	filename: "C_octagon_floors/C_octagon_floors-pvrtc.ktx.gz",
	bytes: 1370613,
	lastChange: "2022-11-01T18:24:58.359Z"
}, {
	filename: "C_octagon_floors.jpg",
	bytes: 1171727,
	lastChange: "2022-11-01T18:24:58.291Z"
}, {
	filename: "C_octagon_floorsB.jpg",
	bytes: 669045,
	lastChange: "2022-11-01T18:24:58.367Z"
}, {
	filename: "C_octagon_walls/C_octagon_walls-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.379Z"
}, {
	filename: "C_octagon_walls/C_octagon_walls-astc.ktx.gz",
	bytes: 479446,
	lastChange: "2022-11-01T18:24:58.383Z"
}, {
	filename: "C_octagon_walls/C_octagon_walls-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.395Z"
}, {
	filename: "C_octagon_walls/C_octagon_walls-dxt.ktx.gz",
	bytes: 755831,
	lastChange: "2022-11-01T18:24:58.399Z"
}, {
	filename: "C_octagon_walls/C_octagon_walls-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.415Z"
}, {
	filename: "C_octagon_walls/C_octagon_walls-pvrtc.ktx.gz",
	bytes: 1169150,
	lastChange: "2022-11-01T18:24:58.423Z"
}, {
	filename: "C_octagon_walls.jpg",
	bytes: 649182,
	lastChange: "2022-11-01T18:24:58.371Z"
}, {
	filename: "D_transition/D_transition-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.443Z"
}, {
	filename: "D_transition/D_transition-astc.ktx.gz",
	bytes: 635068,
	lastChange: "2022-11-01T18:24:58.447Z"
}, {
	filename: "D_transition/D_transition-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.459Z"
}, {
	filename: "D_transition/D_transition-dxt.ktx.gz",
	bytes: 890575,
	lastChange: "2022-11-01T18:24:58.467Z"
}, {
	filename: "D_transition/D_transition-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.487Z"
}, {
	filename: "D_transition/D_transition-pvrtc.ktx.gz",
	bytes: 1213282,
	lastChange: "2022-11-01T18:24:58.495Z"
}, {
	filename: "D_transition.jpg",
	bytes: 905212,
	lastChange: "2022-11-01T18:24:58.427Z"
}, {
	filename: "E_island/E_island-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.511Z"
}, {
	filename: "E_island/E_island-astc.ktx.gz",
	bytes: 487410,
	lastChange: "2022-11-01T18:24:58.515Z"
}, {
	filename: "E_island/E_island-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.527Z"
}, {
	filename: "E_island/E_island-dxt.ktx.gz",
	bytes: 672418,
	lastChange: "2022-11-01T18:24:58.531Z"
}, {
	filename: "E_island/E_island-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.547Z"
}, {
	filename: "E_island/E_island-pvrtc.ktx.gz",
	bytes: 1089231,
	lastChange: "2022-11-01T18:24:58.555Z"
}, {
	filename: "E_island.jpg",
	bytes: 697093,
	lastChange: "2022-11-01T18:24:58.499Z"
}, {
	filename: "F_end/F_end-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.575Z"
}, {
	filename: "F_end/F_end-astc.ktx.gz",
	bytes: 733352,
	lastChange: "2022-11-01T18:24:58.579Z"
}, {
	filename: "F_end/F_end-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.595Z"
}, {
	filename: "F_end/F_end-dxt.ktx.gz",
	bytes: 1053448,
	lastChange: "2022-11-01T18:24:58.599Z"
}, {
	filename: "F_end/F_end-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.619Z"
}, {
	filename: "F_end/F_end-pvrtc.ktx.gz",
	bytes: 1271325,
	lastChange: "2022-11-01T18:24:58.627Z"
}, {
	filename: "F_end.jpg",
	bytes: 979542,
	lastChange: "2022-11-01T18:24:58.559Z"
}, {
	filename: "G_floating_islands/G_floating_islands-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.651Z"
}, {
	filename: "G_floating_islands/G_floating_islands-astc.ktx.gz",
	bytes: 492232,
	lastChange: "2022-11-01T18:24:58.655Z"
}, {
	filename: "G_floating_islands/G_floating_islands-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.671Z"
}, {
	filename: "G_floating_islands/G_floating_islands-dxt.ktx.gz",
	bytes: 778838,
	lastChange: "2022-11-01T18:24:58.675Z"
}, {
	filename: "G_floating_islands/G_floating_islands-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.691Z"
}, {
	filename: "G_floating_islands/G_floating_islands-pvrtc.ktx.gz",
	bytes: 1160677,
	lastChange: "2022-11-01T18:24:58.699Z"
}, {
	filename: "G_floating_islands.jpg",
	bytes: 670980,
	lastChange: "2022-11-01T18:24:58.631Z"
}, {
	filename: "Group 307.svg",
	bytes: 362933,
	lastChange: "2022-11-01T18:24:58.703Z"
}, {
	filename: "LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor/LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor-astc.ktx",
	bytes: 4194404,
	lastChange: "2022-11-01T18:24:58.723Z"
}, {
	filename: "LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor/LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor-astc.ktx.gz",
	bytes: 823669,
	lastChange: "2022-11-01T18:24:58.727Z"
}, {
	filename: "LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor/LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor-dxt.ktx",
	bytes: 4194424,
	lastChange: "2022-11-01T18:24:58.739Z"
}, {
	filename: "LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor/LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor-dxt.ktx.gz",
	bytes: 495136,
	lastChange: "2022-11-01T18:24:58.743Z"
}, {
	filename: "LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor/LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.751Z"
}, {
	filename: "LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor/LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor-pvrtc.ktx.gz",
	bytes: 415129,
	lastChange: "2022-11-01T18:24:58.751Z"
}, {
	filename: "LAYERED_WAVE_UV_UNWRAPPED_LAYERED_04_DefaultMaterial_BaseColor.png",
	bytes: 1977920,
	lastChange: "2022-11-01T18:24:58.711Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_BaseColor/AXIE_COIN_REMESHED_default_BaseColor-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.755Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_BaseColor/AXIE_COIN_REMESHED_default_BaseColor-astc.ktx.gz",
	bytes: 37698,
	lastChange: "2022-11-01T18:24:58.759Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_BaseColor/AXIE_COIN_REMESHED_default_BaseColor-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.763Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_BaseColor/AXIE_COIN_REMESHED_default_BaseColor-dxt.ktx.gz",
	bytes: 46564,
	lastChange: "2022-11-01T18:24:58.763Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_BaseColor/AXIE_COIN_REMESHED_default_BaseColor-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.767Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_BaseColor/AXIE_COIN_REMESHED_default_BaseColor-pvrtc.ktx.gz",
	bytes: 78059,
	lastChange: "2022-11-01T18:24:58.767Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_BaseColor.jpg",
	bytes: 26099,
	lastChange: "2022-11-01T18:24:58.751Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Metallic-combined.jpg",
	bytes: 60892,
	lastChange: "2022-11-01T18:24:58.771Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Metallic.png",
	bytes: 8575,
	lastChange: "2022-11-01T18:24:58.771Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Normal/AXIE_COIN_REMESHED_default_Normal-astc.ktx",
	bytes: 262244,
	lastChange: "2022-11-01T18:24:58.771Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Normal/AXIE_COIN_REMESHED_default_Normal-astc.ktx.gz",
	bytes: 148579,
	lastChange: "2022-11-01T18:24:58.771Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Normal/AXIE_COIN_REMESHED_default_Normal-dxt.ktx",
	bytes: 262264,
	lastChange: "2022-11-01T18:24:58.775Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Normal/AXIE_COIN_REMESHED_default_Normal-dxt.ktx.gz",
	bytes: 44977,
	lastChange: "2022-11-01T18:24:58.775Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Normal/AXIE_COIN_REMESHED_default_Normal-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:58.775Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Normal/AXIE_COIN_REMESHED_default_Normal-pvrtc.ktx.gz",
	bytes: 73342,
	lastChange: "2022-11-01T18:24:58.775Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Normal.jpg",
	bytes: 69307,
	lastChange: "2022-11-01T18:24:58.771Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Normal.png",
	bytes: 155956,
	lastChange: "2022-11-01T18:24:58.771Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_REMESHED_default_Roughness.png",
	bytes: 1233133,
	lastChange: "2022-11-01T18:24:58.783Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_default_Metallic-combined/AXIE_COIN_default_Metallic-combined-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.791Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_default_Metallic-combined/AXIE_COIN_default_Metallic-combined-astc.ktx.gz",
	bytes: 150508,
	lastChange: "2022-11-01T18:24:58.791Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_default_Metallic-combined/AXIE_COIN_default_Metallic-combined-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.799Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_default_Metallic-combined/AXIE_COIN_default_Metallic-combined-dxt.ktx.gz",
	bytes: 240961,
	lastChange: "2022-11-01T18:24:58.803Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_default_Metallic-combined/AXIE_COIN_default_Metallic-combined-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.815Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_default_Metallic-combined/AXIE_COIN_default_Metallic-combined-pvrtc.ktx.gz",
	bytes: 738740,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "PBR_COIN_REMESH/AXIE_COIN_default_Metallic-combined.jpg",
	bytes: 63666,
	lastChange: "2022-11-01T18:24:58.783Z"
}, {
	filename: "PBR_COIN_REMESH/Grayscale.png",
	bytes: 4166,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/arrow.png",
	bytes: 291,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/arrow_back.png",
	bytes: 400,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/arrow_black.png",
	bytes: 370,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/arrow_black_mobile.png",
	bytes: 208,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/arrow_mobile.png",
	bytes: 221,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/bg.png",
	bytes: 925769,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/chat.png",
	bytes: 1473,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/chat_mobile.png",
	bytes: 441,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/dot.png",
	bytes: 162,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/headphones.png",
	bytes: 459,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/headphones_purple.png",
	bytes: 348,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/headset.png",
	bytes: 749,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/logo.png",
	bytes: 24021,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/mic_settings.png",
	bytes: 300,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/mic_settings_purple.png",
	bytes: 315,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/move.png",
	bytes: 545,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/mute.png",
	bytes: 315,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/mute_black.png",
	bytes: 284,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/mute_hover.png",
	bytes: 315,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/mute_purple.png",
	bytes: 315,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/off_black.png",
	bytes: 281,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/off_purple.png",
	bytes: 290,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/on_black.png",
	bytes: 282,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/on_purple.png",
	bytes: 299,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/prescreen.png",
	bytes: 19744,
	lastChange: "2022-11-01T18:24:58.823Z"
}, {
	filename: "UI/replay.png",
	bytes: 350,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/replay_hover.png",
	bytes: 356,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/rotate.png",
	bytes: 1053,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/rotation.png",
	bytes: 1108,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/sound.png",
	bytes: 2562,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/splash.png",
	bytes: 7148,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/techlive-black.png",
	bytes: 6653,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/techlive-white.png",
	bytes: 4800,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/teleport.png",
	bytes: 1343,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/unmute.png",
	bytes: 348,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/unmute_black.png",
	bytes: 345,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/unmute_hover.png",
	bytes: 356,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/unmute_purple.png",
	bytes: 356,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/volume_off_black.png",
	bytes: 101,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/volume_off_purple.png",
	bytes: 101,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/volume_on_black.png",
	bytes: 131,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/volume_on_purple.png",
	bytes: 131,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "UI/wrist.png",
	bytes: 660,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "WAVE_FIN_default_BaseColor.jpg",
	bytes: 360576,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "_scenelayout/black.jpg",
	bytes: 1129,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "_scenelayout/mask/mask-astc.ktx",
	bytes: 108,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "_scenelayout/mask/mask-astc.ktx.gz",
	bytes: 99,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "_scenelayout/mask/mask-dxt.ktx",
	bytes: 128,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "_scenelayout/mask/mask-dxt.ktx.gz",
	bytes: 114,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "_scenelayout/mask/mask-pvrtc.ktx",
	bytes: 132,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "_scenelayout/mask/mask-pvrtc.ktx.gz",
	bytes: 98,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "_scenelayout/mask.jpg",
	bytes: 1129,
	lastChange: "2022-11-01T18:24:58.827Z"
}, {
	filename: "_scenelayout/uv.jpg",
	bytes: 138695,
	lastChange: "2022-11-01T18:24:58.831Z"
}, {
	filename: "bedrock_mro_low/bedrock_mro_low-astc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:58.831Z"
}, {
	filename: "bedrock_mro_low/bedrock_mro_low-astc.ktx.gz",
	bytes: 113423,
	lastChange: "2022-11-01T18:24:58.831Z"
}, {
	filename: "bedrock_mro_low/bedrock_mro_low-dxt.ktx",
	bytes: 131192,
	lastChange: "2022-11-01T18:24:58.835Z"
}, {
	filename: "bedrock_mro_low/bedrock_mro_low-dxt.ktx.gz",
	bytes: 107111,
	lastChange: "2022-11-01T18:24:58.835Z"
}, {
	filename: "bedrock_mro_low/bedrock_mro_low-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:58.835Z"
}, {
	filename: "bedrock_mro_low/bedrock_mro_low-pvrtc.ktx.gz",
	bytes: 109806,
	lastChange: "2022-11-01T18:24:58.835Z"
}, {
	filename: "bedrock_mro_low.jpg",
	bytes: 161662,
	lastChange: "2022-11-01T18:24:58.831Z"
}, {
	filename: "blossom/bridge.jpg",
	bytes: 455803,
	lastChange: "2022-11-01T18:24:58.839Z"
}, {
	filename: "blossom/flowmap_2.jpg",
	bytes: 16310,
	lastChange: "2022-11-01T18:24:58.839Z"
}, {
	filename: "blossom/grass.png",
	bytes: 279957,
	lastChange: "2022-11-01T18:24:58.839Z"
}, {
	filename: "blossom/grass_wind.jpg",
	bytes: 55762,
	lastChange: "2022-11-01T18:24:58.839Z"
}, {
	filename: "blossom/hdri_gray.jpg",
	bytes: 844258,
	lastChange: "2022-11-01T18:24:58.843Z"
}, {
	filename: "blossom/land.jpg",
	bytes: 636727,
	lastChange: "2022-11-01T18:24:58.847Z"
}, {
	filename: "blossom/leafalpha.jpg",
	bytes: 9168,
	lastChange: "2022-11-01T18:24:58.847Z"
}, {
	filename: "blossom/matcap_sun.jpg",
	bytes: 27940,
	lastChange: "2022-11-01T18:24:58.847Z"
}, {
	filename: "blossom/paintedsky_day.jpg",
	bytes: 881417,
	lastChange: "2022-11-01T18:24:58.855Z"
}, {
	filename: "blossom/rock_low_mro.jpg",
	bytes: 516360,
	lastChange: "2022-11-01T18:24:58.859Z"
}, {
	filename: "blossom/rock_low_normal/rock_low_normal-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.871Z"
}, {
	filename: "blossom/rock_low_normal/rock_low_normal-astc.ktx.gz",
	bytes: 619122,
	lastChange: "2022-11-01T18:24:58.875Z"
}, {
	filename: "blossom/rock_low_normal/rock_low_normal-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:58.891Z"
}, {
	filename: "blossom/rock_low_normal/rock_low_normal-dxt.ktx.gz",
	bytes: 839696,
	lastChange: "2022-11-01T18:24:58.895Z"
}, {
	filename: "blossom/rock_low_normal/rock_low_normal-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:58.915Z"
}, {
	filename: "blossom/rock_low_normal/rock_low_normal-pvrtc.ktx.gz",
	bytes: 1099021,
	lastChange: "2022-11-01T18:24:58.919Z"
}, {
	filename: "blossom/rock_low_normal.jpg",
	bytes: 351507,
	lastChange: "2022-11-01T18:24:58.859Z"
}, {
	filename: "blossom/rock_low_tmap.jpg",
	bytes: 719433,
	lastChange: "2022-11-01T18:24:58.923Z"
}, {
	filename: "blossom/texturesheet.png",
	bytes: 687238,
	lastChange: "2022-11-01T18:24:58.927Z"
}, {
	filename: "blossom/texturesheet2.png",
	bytes: 687287,
	lastChange: "2022-11-01T18:24:58.931Z"
}, {
	filename: "blossom/torri.jpg",
	bytes: 444271,
	lastChange: "2022-11-01T18:24:58.935Z"
}, {
	filename: "blossom/torri_diff.jpg",
	bytes: 284217,
	lastChange: "2022-11-01T18:24:58.935Z"
}, {
	filename: "blossom/tree_mro.jpg",
	bytes: 393887,
	lastChange: "2022-11-01T18:24:58.939Z"
}, {
	filename: "blossom/tree_normal.jpg",
	bytes: 861413,
	lastChange: "2022-11-01T18:24:58.939Z"
}, {
	filename: "blossom/tree_tmap.jpg",
	bytes: 755485,
	lastChange: "2022-11-01T18:24:58.943Z"
}, {
	filename: "blossom/treeleaves-painted3.jpg",
	bytes: 455943,
	lastChange: "2022-11-01T18:24:58.947Z"
}, {
	filename: "blossom/treeleaves-painted4.jpg",
	bytes: 462202,
	lastChange: "2022-11-01T18:24:58.951Z"
}, {
	filename: "blossom/treeleaves-painted5.jpg",
	bytes: 444255,
	lastChange: "2022-11-01T18:24:58.951Z"
}, {
	filename: "blossom/treeleaves.jpg",
	bytes: 644218,
	lastChange: "2022-11-01T18:24:58.955Z"
}, {
	filename: "blossom/water-repeat.jpg",
	bytes: 139120,
	lastChange: "2022-11-01T18:24:58.959Z"
}, {
	filename: "blossom/water_mro.jpg",
	bytes: 159998,
	lastChange: "2022-11-01T18:24:58.959Z"
}, {
	filename: "blossom/water_ripple.jpg",
	bytes: 22227,
	lastChange: "2022-11-01T18:24:58.959Z"
}, {
	filename: "castle.jpg",
	bytes: 717914,
	lastChange: "2022-11-01T18:24:58.963Z"
}, {
	filename: "cloud.jpg",
	bytes: 12437,
	lastChange: "2022-11-01T18:24:58.963Z"
}, {
	filename: "cube/flowmap.jpg",
	bytes: 16310,
	lastChange: "2022-11-01T18:24:58.963Z"
}, {
	filename: "cube/gold_ore_custom.jpg",
	bytes: 3566469,
	lastChange: "2022-11-01T18:24:58.971Z"
}, {
	filename: "cube/gold_ore_normal_1k.jpg",
	bytes: 1266364,
	lastChange: "2022-11-01T18:24:58.975Z"
}, {
	filename: "cube/paintedsky_day.jpg",
	bytes: 881417,
	lastChange: "2022-11-01T18:24:58.983Z"
}, {
	filename: "cube/water_normal/water_normal-astc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:58.983Z"
}, {
	filename: "cube/water_normal/water_normal-astc.ktx.gz",
	bytes: 56434,
	lastChange: "2022-11-01T18:24:58.983Z"
}, {
	filename: "cube/water_normal/water_normal-dxt.ktx",
	bytes: 131192,
	lastChange: "2022-11-01T18:24:58.983Z"
}, {
	filename: "cube/water_normal/water_normal-dxt.ktx.gz",
	bytes: 83349,
	lastChange: "2022-11-01T18:24:58.983Z"
}, {
	filename: "cube/water_normal/water_normal-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:58.987Z"
}, {
	filename: "cube/water_normal/water_normal-pvrtc.ktx.gz",
	bytes: 94746,
	lastChange: "2022-11-01T18:24:58.987Z"
}, {
	filename: "cube/water_normal.jpg",
	bytes: 41752,
	lastChange: "2022-11-01T18:24:58.983Z"
}, {
	filename: "cube/water_ripple.jpg",
	bytes: 17251,
	lastChange: "2022-11-01T18:24:58.987Z"
}, {
	filename: "cyber/black.jpg",
	bytes: 1472,
	lastChange: "2022-11-01T18:24:58.987Z"
}, {
	filename: "cyber/corsica_beach-specular-RGBM/corsica_beach-specular-RGBM-astc.ktx",
	bytes: 1048676,
	lastChange: "2022-11-01T18:24:58.995Z"
}, {
	filename: "cyber/corsica_beach-specular-RGBM/corsica_beach-specular-RGBM-astc.ktx.gz",
	bytes: 403856,
	lastChange: "2022-11-01T18:24:58.999Z"
}, {
	filename: "cyber/corsica_beach-specular-RGBM/corsica_beach-specular-RGBM-dxt.ktx",
	bytes: 1048696,
	lastChange: "2022-11-01T18:24:59.003Z"
}, {
	filename: "cyber/corsica_beach-specular-RGBM/corsica_beach-specular-RGBM-dxt.ktx.gz",
	bytes: 124257,
	lastChange: "2022-11-01T18:24:59.003Z"
}, {
	filename: "cyber/corsica_beach-specular-RGBM/corsica_beach-specular-RGBM-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:59.007Z"
}, {
	filename: "cyber/corsica_beach-specular-RGBM/corsica_beach-specular-RGBM-pvrtc.ktx.gz",
	bytes: 246926,
	lastChange: "2022-11-01T18:24:59.011Z"
}, {
	filename: "cyber/corsica_beach-specular-RGBM.png",
	bytes: 400738,
	lastChange: "2022-11-01T18:24:58.991Z"
}, {
	filename: "cyber/cyber_building_emissive.jpg",
	bytes: 35814,
	lastChange: "2022-11-01T18:24:59.011Z"
}, {
	filename: "cyber/cyber_building_mro.jpg",
	bytes: 503085,
	lastChange: "2022-11-01T18:24:59.011Z"
}, {
	filename: "cyber/cyber_building_mro_2.jpg",
	bytes: 433920,
	lastChange: "2022-11-01T18:24:59.015Z"
}, {
	filename: "cyber/floor-matcap.png",
	bytes: 25685,
	lastChange: "2022-11-01T18:24:59.015Z"
}, {
	filename: "cyber/sci-fi-panel1-normal-dx.png",
	bytes: 630126,
	lastChange: "2022-11-01T18:24:59.019Z"
}, {
	filename: "cyber/spaceship_panels_mro/spaceship_panels_mro-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:59.027Z"
}, {
	filename: "cyber/spaceship_panels_mro/spaceship_panels_mro-astc.ktx.gz",
	bytes: 479849,
	lastChange: "2022-11-01T18:24:59.027Z"
}, {
	filename: "cyber/spaceship_panels_mro/spaceship_panels_mro-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:59.031Z"
}, {
	filename: "cyber/spaceship_panels_mro/spaceship_panels_mro-dxt.ktx.gz",
	bytes: 464267,
	lastChange: "2022-11-01T18:24:59.031Z"
}, {
	filename: "cyber/spaceship_panels_mro/spaceship_panels_mro-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:59.035Z"
}, {
	filename: "cyber/spaceship_panels_mro/spaceship_panels_mro-pvrtc.ktx.gz",
	bytes: 447705,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "cyber/spaceship_panels_mro.jpg",
	bytes: 510123,
	lastChange: "2022-11-01T18:24:59.019Z"
}, {
	filename: "cyber/spaceship_panels_normal.jpg",
	bytes: 436407,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "dots/dotBlurred_01.png",
	bytes: 1199,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "dots/dotBlurred_02.png",
	bytes: 2560,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "dots/dotBlurred_03.png",
	bytes: 1159,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "dots/dotBlurred_04.png",
	bytes: 1879,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "dots/dotBlurred_05.png",
	bytes: 1132,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "dots/dotBlurred_06.png",
	bytes: 1132,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "dots/dotBlurred_07.png",
	bytes: 1346,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "emotes/sprite.png",
	bytes: 50979,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "fantasy/Billboard_256_Albedo.jpg",
	bytes: 36142,
	lastChange: "2022-11-01T18:24:59.039Z"
}, {
	filename: "fantasy/Billboard_512_ATO.jpg",
	bytes: 218468,
	lastChange: "2022-11-01T18:24:59.043Z"
}, {
	filename: "fantasy/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-astc.ktx",
	bytes: 262244,
	lastChange: "2022-11-01T18:24:59.043Z"
}, {
	filename: "fantasy/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-astc.ktx.gz",
	bytes: 176033,
	lastChange: "2022-11-01T18:24:59.043Z"
}, {
	filename: "fantasy/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-dxt.ktx",
	bytes: 262264,
	lastChange: "2022-11-01T18:24:59.047Z"
}, {
	filename: "fantasy/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-dxt.ktx.gz",
	bytes: 59835,
	lastChange: "2022-11-01T18:24:59.047Z"
}, {
	filename: "fantasy/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.047Z"
}, {
	filename: "fantasy/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-pvrtc.ktx.gz",
	bytes: 74259,
	lastChange: "2022-11-01T18:24:59.047Z"
}, {
	filename: "fantasy/corsica_beach-specular-RGBM_single_v2.png",
	bytes: 112971,
	lastChange: "2022-11-01T18:24:59.043Z"
}, {
	filename: "fantasy/flame.jpg",
	bytes: 33493,
	lastChange: "2022-11-01T18:24:59.051Z"
}, {
	filename: "fantasy/floor_lightmap2.jpg",
	bytes: 516991,
	lastChange: "2022-11-01T18:24:59.055Z"
}, {
	filename: "fantasy/ground_lightmap2.jpg",
	bytes: 1665555,
	lastChange: "2022-11-01T18:24:59.067Z"
}, {
	filename: "fantasy/objects_lightmap2.jpg",
	bytes: 1156989,
	lastChange: "2022-11-01T18:24:59.075Z"
}, {
	filename: "field/field-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.099Z"
}, {
	filename: "field/field-astc.ktx.gz",
	bytes: 952251,
	lastChange: "2022-11-01T18:24:59.103Z"
}, {
	filename: "field/field-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:59.127Z"
}, {
	filename: "field/field-dxt.ktx.gz",
	bytes: 1324101,
	lastChange: "2022-11-01T18:24:59.135Z"
}, {
	filename: "field/field-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.159Z"
}, {
	filename: "field/field-pvrtc.ktx.gz",
	bytes: 1371891,
	lastChange: "2022-11-01T18:24:59.167Z"
}, {
	filename: "field.jpg",
	bytes: 234063,
	lastChange: "2022-11-01T18:24:59.079Z"
}, {
	filename: "floor_plans.jpg",
	bytes: 3060536,
	lastChange: "2022-11-01T18:24:59.191Z"
}, {
	filename: "frame.jpg",
	bytes: 65486,
	lastChange: "2022-11-01T18:24:59.191Z"
}, {
	filename: "fun/borders.jpg",
	bytes: 891235,
	lastChange: "2022-11-01T18:24:59.199Z"
}, {
	filename: "fun/borders_mro.jpg",
	bytes: 381592,
	lastChange: "2022-11-01T18:24:59.199Z"
}, {
	filename: "fun/circles.jpg",
	bytes: 450210,
	lastChange: "2022-11-01T18:24:59.203Z"
}, {
	filename: "fun/circles_mro.jpg",
	bytes: 190721,
	lastChange: "2022-11-01T18:24:59.203Z"
}, {
	filename: "fun/cloud1.jpg",
	bytes: 95894,
	lastChange: "2022-11-01T18:24:59.207Z"
}, {
	filename: "fun/cloud2.jpg",
	bytes: 95409,
	lastChange: "2022-11-01T18:24:59.207Z"
}, {
	filename: "fun/cloud_normal.jpg",
	bytes: 139120,
	lastChange: "2022-11-01T18:24:59.207Z"
}, {
	filename: "fun/connector.jpg",
	bytes: 67386,
	lastChange: "2022-11-01T18:24:59.207Z"
}, {
	filename: "fun/connector_mro.jpg",
	bytes: 31927,
	lastChange: "2022-11-01T18:24:59.207Z"
}, {
	filename: "fun/fenceposts.jpg",
	bytes: 548911,
	lastChange: "2022-11-01T18:24:59.211Z"
}, {
	filename: "fun/fenceposts_mro.jpg",
	bytes: 60762,
	lastChange: "2022-11-01T18:24:59.211Z"
}, {
	filename: "fun/finish.jpg",
	bytes: 476993,
	lastChange: "2022-11-01T18:24:59.215Z"
}, {
	filename: "fun/finish_mro.jpg",
	bytes: 203300,
	lastChange: "2022-11-01T18:24:59.215Z"
}, {
	filename: "fun/flowmap.jpg",
	bytes: 16310,
	lastChange: "2022-11-01T18:24:59.215Z"
}, {
	filename: "fun/frame.jpg",
	bytes: 208502,
	lastChange: "2022-11-01T18:24:59.219Z"
}, {
	filename: "fun/frame_mro.jpg",
	bytes: 95190,
	lastChange: "2022-11-01T18:24:59.219Z"
}, {
	filename: "fun/matcap_sun.jpg",
	bytes: 27940,
	lastChange: "2022-11-01T18:24:59.219Z"
}, {
	filename: "fun/maze.jpg",
	bytes: 509015,
	lastChange: "2022-11-01T18:24:59.223Z"
}, {
	filename: "fun/maze_mro.jpg",
	bytes: 176848,
	lastChange: "2022-11-01T18:24:59.223Z"
}, {
	filename: "fun/paintedsky_day.jpg",
	bytes: 881417,
	lastChange: "2022-11-01T18:24:59.231Z"
}, {
	filename: "fun/platforms.jpg",
	bytes: 567094,
	lastChange: "2022-11-01T18:24:59.235Z"
}, {
	filename: "fun/platforms_mro.jpg",
	bytes: 233049,
	lastChange: "2022-11-01T18:24:59.235Z"
}, {
	filename: "fun/spinner1.jpg",
	bytes: 95160,
	lastChange: "2022-11-01T18:24:59.235Z"
}, {
	filename: "fun/spinner1_mro.jpg",
	bytes: 38005,
	lastChange: "2022-11-01T18:24:59.235Z"
}, {
	filename: "fun/spinner2.jpg",
	bytes: 91153,
	lastChange: "2022-11-01T18:24:59.235Z"
}, {
	filename: "fun/spinner2_mro.jpg",
	bytes: 38728,
	lastChange: "2022-11-01T18:24:59.235Z"
}, {
	filename: "fun/spinner3.jpg",
	bytes: 107282,
	lastChange: "2022-11-01T18:24:59.239Z"
}, {
	filename: "fun/spinner3_mro.jpg",
	bytes: 42449,
	lastChange: "2022-11-01T18:24:59.239Z"
}, {
	filename: "galaxy/dwxml.jpg",
	bytes: 220931,
	lastChange: "2022-11-01T18:24:59.239Z"
}, {
	filename: "galaxy/entrance.jpg",
	bytes: 190680,
	lastChange: "2022-11-01T18:24:59.243Z"
}, {
	filename: "galaxy/flowmap.jpg",
	bytes: 16310,
	lastChange: "2022-11-01T18:24:59.243Z"
}, {
	filename: "galaxy/gold_ore_custom.jpg",
	bytes: 3566469,
	lastChange: "2022-11-01T18:24:59.247Z"
}, {
	filename: "galaxy/gold_ore_normal_1k.jpg",
	bytes: 1266364,
	lastChange: "2022-11-01T18:24:59.251Z"
}, {
	filename: "galaxy/info1.png",
	bytes: 102056,
	lastChange: "2022-11-01T18:24:59.255Z"
}, {
	filename: "galaxy/lightmap_crystal.jpg",
	bytes: 213617,
	lastChange: "2022-11-01T18:24:59.255Z"
}, {
	filename: "galaxy/lightmap_objects.jpg",
	bytes: 3035299,
	lastChange: "2022-11-01T18:24:59.275Z"
}, {
	filename: "galaxy/nebula.jpg",
	bytes: 75491,
	lastChange: "2022-11-01T18:24:59.275Z"
}, {
	filename: "galaxy/noise_combined.jpg",
	bytes: 214704,
	lastChange: "2022-11-01T18:24:59.275Z"
}, {
	filename: "galaxy/paintedsky_day.jpg",
	bytes: 144876,
	lastChange: "2022-11-01T18:24:59.275Z"
}, {
	filename: "galaxy/portal_combined.jpg",
	bytes: 115042,
	lastChange: "2022-11-01T18:24:59.275Z"
}, {
	filename: "galaxy/portal_info.png",
	bytes: 7261,
	lastChange: "2022-11-01T18:24:59.275Z"
}, {
	filename: "galaxy/stars/stars-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:59.279Z"
}, {
	filename: "galaxy/stars/stars-astc.ktx.gz",
	bytes: 259078,
	lastChange: "2022-11-01T18:24:59.283Z"
}, {
	filename: "galaxy/stars/stars-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:59.287Z"
}, {
	filename: "galaxy/stars/stars-dxt.ktx.gz",
	bytes: 302643,
	lastChange: "2022-11-01T18:24:59.287Z"
}, {
	filename: "galaxy/stars/stars-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:59.291Z"
}, {
	filename: "galaxy/stars/stars-pvrtc.ktx.gz",
	bytes: 360769,
	lastChange: "2022-11-01T18:24:59.295Z"
}, {
	filename: "galaxy/stars.jpg",
	bytes: 200980,
	lastChange: "2022-11-01T18:24:59.275Z"
}, {
	filename: "galaxy/sun.jpg",
	bytes: 144570,
	lastChange: "2022-11-01T18:24:59.295Z"
}, {
	filename: "galaxy/water_normal.jpg",
	bytes: 41752,
	lastChange: "2022-11-01T18:24:59.295Z"
}, {
	filename: "galaxy/water_ripple.jpg",
	bytes: 17251,
	lastChange: "2022-11-01T18:24:59.295Z"
}, {
	filename: "garden/Billboard_256_Albedo.jpg",
	bytes: 36142,
	lastChange: "2022-11-01T18:24:59.295Z"
}, {
	filename: "garden/Billboard_512_ATO/Billboard_512_ATO-astc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.299Z"
}, {
	filename: "garden/Billboard_512_ATO/Billboard_512_ATO-astc.ktx.gz",
	bytes: 77868,
	lastChange: "2022-11-01T18:24:59.299Z"
}, {
	filename: "garden/Billboard_512_ATO/Billboard_512_ATO-dxt.ktx",
	bytes: 131192,
	lastChange: "2022-11-01T18:24:59.299Z"
}, {
	filename: "garden/Billboard_512_ATO/Billboard_512_ATO-dxt.ktx.gz",
	bytes: 90283,
	lastChange: "2022-11-01T18:24:59.299Z"
}, {
	filename: "garden/Billboard_512_ATO/Billboard_512_ATO-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.299Z"
}, {
	filename: "garden/Billboard_512_ATO/Billboard_512_ATO-pvrtc.ktx.gz",
	bytes: 94084,
	lastChange: "2022-11-01T18:24:59.303Z"
}, {
	filename: "garden/Billboard_512_ATO.jpg",
	bytes: 218468,
	lastChange: "2022-11-01T18:24:59.295Z"
}, {
	filename: "garden/alien_mro.jpg",
	bytes: 1355356,
	lastChange: "2022-11-01T18:24:59.311Z"
}, {
	filename: "garden/alien_normal.jpg",
	bytes: 1673081,
	lastChange: "2022-11-01T18:24:59.323Z"
}, {
	filename: "garden/bedrock_mro.jpg",
	bytes: 1297552,
	lastChange: "2022-11-01T18:24:59.331Z"
}, {
	filename: "garden/bedrock_normal.jpg",
	bytes: 1408176,
	lastChange: "2022-11-01T18:24:59.339Z"
}, {
	filename: "garden/birdanimation.jpg",
	bytes: 13460,
	lastChange: "2022-11-01T18:24:59.339Z"
}, {
	filename: "garden/caustics.jpg",
	bytes: 13734,
	lastChange: "2022-11-01T18:24:59.339Z"
}, {
	filename: "garden/cliffs_mro.jpg",
	bytes: 1878631,
	lastChange: "2022-11-01T18:24:59.343Z"
}, {
	filename: "garden/cliffs_normal.jpg",
	bytes: 1345053,
	lastChange: "2022-11-01T18:24:59.343Z"
}, {
	filename: "garden/clovers_mro.jpg",
	bytes: 1026184,
	lastChange: "2022-11-01T18:24:59.347Z"
}, {
	filename: "garden/clovers_normal.jpg",
	bytes: 1935854,
	lastChange: "2022-11-01T18:24:59.359Z"
}, {
	filename: "garden/clovers_normal_low/clovers_normal_low-astc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.359Z"
}, {
	filename: "garden/clovers_normal_low/clovers_normal_low-astc.ktx.gz",
	bytes: 125830,
	lastChange: "2022-11-01T18:24:59.359Z"
}, {
	filename: "garden/clovers_normal_low/clovers_normal_low-dxt.ktx",
	bytes: 131192,
	lastChange: "2022-11-01T18:24:59.363Z"
}, {
	filename: "garden/clovers_normal_low/clovers_normal_low-dxt.ktx.gz",
	bytes: 121547,
	lastChange: "2022-11-01T18:24:59.363Z"
}, {
	filename: "garden/clovers_normal_low/clovers_normal_low-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.363Z"
}, {
	filename: "garden/clovers_normal_low/clovers_normal_low-pvrtc.ktx.gz",
	bytes: 123455,
	lastChange: "2022-11-01T18:24:59.363Z"
}, {
	filename: "garden/clovers_normal_low.jpg",
	bytes: 322424,
	lastChange: "2022-11-01T18:24:59.359Z"
}, {
	filename: "garden/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-astc.ktx",
	bytes: 262244,
	lastChange: "2022-11-01T18:24:59.367Z"
}, {
	filename: "garden/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-astc.ktx.gz",
	bytes: 176033,
	lastChange: "2022-11-01T18:24:59.367Z"
}, {
	filename: "garden/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-dxt.ktx",
	bytes: 262264,
	lastChange: "2022-11-01T18:24:59.367Z"
}, {
	filename: "garden/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-dxt.ktx.gz",
	bytes: 59835,
	lastChange: "2022-11-01T18:24:59.367Z"
}, {
	filename: "garden/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.371Z"
}, {
	filename: "garden/corsica_beach-specular-RGBM_single_v2/corsica_beach-specular-RGBM_single_v2-pvrtc.ktx.gz",
	bytes: 74259,
	lastChange: "2022-11-01T18:24:59.371Z"
}, {
	filename: "garden/corsica_beach-specular-RGBM_single_v2.png",
	bytes: 112971,
	lastChange: "2022-11-01T18:24:59.363Z"
}, {
	filename: "garden/doorway.jpg",
	bytes: 18230,
	lastChange: "2022-11-01T18:24:59.371Z"
}, {
	filename: "garden/doorway_env.jpg",
	bytes: 40705,
	lastChange: "2022-11-01T18:24:59.371Z"
}, {
	filename: "garden/dune_mro.jpg",
	bytes: 873967,
	lastChange: "2022-11-01T18:24:59.375Z"
}, {
	filename: "garden/dune_normal.jpg",
	bytes: 1288397,
	lastChange: "2022-11-01T18:24:59.383Z"
}, {
	filename: "garden/flowmap/flowmap-astc.ktx",
	bytes: 32868,
	lastChange: "2022-11-01T18:24:59.383Z"
}, {
	filename: "garden/flowmap/flowmap-astc.ktx.gz",
	bytes: 19101,
	lastChange: "2022-11-01T18:24:59.383Z"
}, {
	filename: "garden/flowmap/flowmap-dxt.ktx",
	bytes: 32888,
	lastChange: "2022-11-01T18:24:59.383Z"
}, {
	filename: "garden/flowmap/flowmap-dxt.ktx.gz",
	bytes: 24347,
	lastChange: "2022-11-01T18:24:59.383Z"
}, {
	filename: "garden/flowmap/flowmap-pvrtc.ktx",
	bytes: 32868,
	lastChange: "2022-11-01T18:24:59.383Z"
}, {
	filename: "garden/flowmap/flowmap-pvrtc.ktx.gz",
	bytes: 26351,
	lastChange: "2022-11-01T18:24:59.383Z"
}, {
	filename: "garden/flowmap.jpg",
	bytes: 16310,
	lastChange: "2022-11-01T18:24:59.383Z"
}, {
	filename: "garden/forester_ground_clay.jpg",
	bytes: 2031172,
	lastChange: "2022-11-01T18:24:59.399Z"
}, {
	filename: "garden/forester_water_clay.jpg",
	bytes: 485306,
	lastChange: "2022-11-01T18:24:59.399Z"
}, {
	filename: "garden/frame.jpg",
	bytes: 41974,
	lastChange: "2022-11-01T18:24:59.403Z"
}, {
	filename: "garden/gold_ore_custom.jpg",
	bytes: 3566469,
	lastChange: "2022-11-01T18:24:59.407Z"
}, {
	filename: "garden/gold_ore_normal.jpg",
	bytes: 4653174,
	lastChange: "2022-11-01T18:24:59.423Z"
}, {
	filename: "garden/gold_ore_normal_1k.jpg",
	bytes: 1266364,
	lastChange: "2022-11-01T18:24:59.427Z"
}, {
	filename: "garden/grass_lightmap.jpg",
	bytes: 110969,
	lastChange: "2022-11-01T18:24:59.427Z"
}, {
	filename: "garden/ground_clay.jpg",
	bytes: 1660195,
	lastChange: "2022-11-01T18:24:59.439Z"
}, {
	filename: "garden/jungle_mro.jpg",
	bytes: 872910,
	lastChange: "2022-11-01T18:24:59.443Z"
}, {
	filename: "garden/jungle_normal.jpg",
	bytes: 1329456,
	lastChange: "2022-11-01T18:24:59.447Z"
}, {
	filename: "garden/leaf_ATO/leaf_ATO-astc.ktx",
	bytes: 8292,
	lastChange: "2022-11-01T18:24:59.451Z"
}, {
	filename: "garden/leaf_ATO/leaf_ATO-astc.ktx.gz",
	bytes: 3571,
	lastChange: "2022-11-01T18:24:59.451Z"
}, {
	filename: "garden/leaf_ATO/leaf_ATO-dxt.ktx",
	bytes: 8312,
	lastChange: "2022-11-01T18:24:59.451Z"
}, {
	filename: "garden/leaf_ATO/leaf_ATO-dxt.ktx.gz",
	bytes: 4210,
	lastChange: "2022-11-01T18:24:59.451Z"
}, {
	filename: "garden/leaf_ATO/leaf_ATO-pvrtc.ktx",
	bytes: 8292,
	lastChange: "2022-11-01T18:24:59.451Z"
}, {
	filename: "garden/leaf_ATO/leaf_ATO-pvrtc.ktx.gz",
	bytes: 4788,
	lastChange: "2022-11-01T18:24:59.451Z"
}, {
	filename: "garden/leaf_ATO.jpg",
	bytes: 4054,
	lastChange: "2022-11-01T18:24:59.451Z"
}, {
	filename: "garden/newGround_clay.jpg",
	bytes: 1025521,
	lastChange: "2022-11-01T18:24:59.455Z"
}, {
	filename: "garden/noise.jpg",
	bytes: 20417,
	lastChange: "2022-11-01T18:24:59.455Z"
}, {
	filename: "garden/paintedsky_day/paintedsky_day-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.471Z"
}, {
	filename: "garden/paintedsky_day/paintedsky_day-astc.ktx.gz",
	bytes: 577436,
	lastChange: "2022-11-01T18:24:59.471Z"
}, {
	filename: "garden/paintedsky_day/paintedsky_day-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:59.487Z"
}, {
	filename: "garden/paintedsky_day/paintedsky_day-dxt.ktx.gz",
	bytes: 808655,
	lastChange: "2022-11-01T18:24:59.491Z"
}, {
	filename: "garden/paintedsky_day/paintedsky_day-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.507Z"
}, {
	filename: "garden/paintedsky_day/paintedsky_day-pvrtc.ktx.gz",
	bytes: 1028631,
	lastChange: "2022-11-01T18:24:59.511Z"
}, {
	filename: "garden/paintedsky_day.jpg",
	bytes: 399089,
	lastChange: "2022-11-01T18:24:59.459Z"
}, {
	filename: "garden/paul_ground_lightmap.jpg",
	bytes: 438818,
	lastChange: "2022-11-01T18:24:59.515Z"
}, {
	filename: "garden/rock_mro.jpg",
	bytes: 831728,
	lastChange: "2022-11-01T18:24:59.515Z"
}, {
	filename: "garden/rock_normal.jpg",
	bytes: 1698574,
	lastChange: "2022-11-01T18:24:59.527Z"
}, {
	filename: "garden/tile_mro.jpg",
	bytes: 1152810,
	lastChange: "2022-11-01T18:24:59.531Z"
}, {
	filename: "garden/tile_normal.jpg",
	bytes: 1438609,
	lastChange: "2022-11-01T18:24:59.543Z"
}, {
	filename: "garden/water_normal/water_normal-astc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.543Z"
}, {
	filename: "garden/water_normal/water_normal-astc.ktx.gz",
	bytes: 56434,
	lastChange: "2022-11-01T18:24:59.543Z"
}, {
	filename: "garden/water_normal/water_normal-dxt.ktx",
	bytes: 131192,
	lastChange: "2022-11-01T18:24:59.543Z"
}, {
	filename: "garden/water_normal/water_normal-dxt.ktx.gz",
	bytes: 83349,
	lastChange: "2022-11-01T18:24:59.543Z"
}, {
	filename: "garden/water_normal/water_normal-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.547Z"
}, {
	filename: "garden/water_normal/water_normal-pvrtc.ktx.gz",
	bytes: 94746,
	lastChange: "2022-11-01T18:24:59.547Z"
}, {
	filename: "garden/water_normal.jpg",
	bytes: 41752,
	lastChange: "2022-11-01T18:24:59.543Z"
}, {
	filename: "gold_ore_custom/gold_ore_custom-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.567Z"
}, {
	filename: "gold_ore_custom/gold_ore_custom-astc.ktx.gz",
	bytes: 2070442,
	lastChange: "2022-11-01T18:24:59.571Z"
}, {
	filename: "gold_ore_custom/gold_ore_custom-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:59.583Z"
}, {
	filename: "gold_ore_custom/gold_ore_custom-dxt.ktx.gz",
	bytes: 2035474,
	lastChange: "2022-11-01T18:24:59.587Z"
}, {
	filename: "gold_ore_custom/gold_ore_custom-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.603Z"
}, {
	filename: "gold_ore_custom/gold_ore_custom-pvrtc.ktx.gz",
	bytes: 2019982,
	lastChange: "2022-11-01T18:24:59.607Z"
}, {
	filename: "gold_ore_custom.jpg",
	bytes: 1275510,
	lastChange: "2022-11-01T18:24:59.551Z"
}, {
	filename: "gold_ore_normal_1k/gold_ore_normal_1k-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:59.615Z"
}, {
	filename: "gold_ore_normal_1k/gold_ore_normal_1k-astc.ktx.gz",
	bytes: 493579,
	lastChange: "2022-11-01T18:24:59.615Z"
}, {
	filename: "gold_ore_normal_1k/gold_ore_normal_1k-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:59.619Z"
}, {
	filename: "gold_ore_normal_1k/gold_ore_normal_1k-dxt.ktx.gz",
	bytes: 492347,
	lastChange: "2022-11-01T18:24:59.623Z"
}, {
	filename: "gold_ore_normal_1k/gold_ore_normal_1k-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "gold_ore_normal_1k/gold_ore_normal_1k-pvrtc.ktx.gz",
	bytes: 489683,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "gold_ore_normal_1k.jpg",
	bytes: 1266364,
	lastChange: "2022-11-01T18:24:59.611Z"
}, {
	filename: "hotspot/arrow-ui.png",
	bytes: 1153,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/left-arrow.png",
	bytes: 373,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/mic-purple.png",
	bytes: 585,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/mic-white.png",
	bytes: 406,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/pause.png",
	bytes: 139,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/play.png",
	bytes: 253,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/right-arrow.png",
	bytes: 395,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/speedIcon.png",
	bytes: 353,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/speedIcon_purple.png",
	bytes: 542,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/speedicon2x.png",
	bytes: 675,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/speedicon2x_purple.png",
	bytes: 1049,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/wave/wave-astc.ktx",
	bytes: 356,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/wave/wave-astc.ktx.gz",
	bytes: 309,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/wave/wave-dxt.ktx",
	bytes: 376,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/wave/wave-dxt.ktx.gz",
	bytes: 316,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/wave/wave-pvrtc.ktx",
	bytes: 228,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/wave/wave-pvrtc.ktx.gz",
	bytes: 182,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "hotspot/wave.png",
	bytes: 331,
	lastChange: "2022-11-01T18:24:59.627Z"
}, {
	filename: "inside/axie/video.mp4",
	bytes: 3536415,
	lastChange: "2022-11-01T18:24:59.635Z"
}, {
	filename: "inside/cloud.jpg",
	bytes: 12332,
	lastChange: "2022-11-01T18:24:59.635Z"
}, {
	filename: "inside/decentraland/video.mp4",
	bytes: 1538935,
	lastChange: "2022-11-01T18:24:59.639Z"
}, {
	filename: "inside/default.jpg",
	bytes: 1129,
	lastChange: "2022-11-01T18:24:59.639Z"
}, {
	filename: "inside/default.mp4",
	bytes: 67646,
	lastChange: "2022-11-01T18:24:59.639Z"
}, {
	filename: "inside/dual/pizza.jpg",
	bytes: 824599,
	lastChange: "2022-11-01T18:24:59.643Z"
}, {
	filename: "inside/dual/video.mp4",
	bytes: 1145502,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/gradient/gradient-astc.ktx",
	bytes: 8292,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/gradient/gradient-astc.ktx.gz",
	bytes: 3006,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/gradient/gradient-dxt.ktx",
	bytes: 8312,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/gradient/gradient-dxt.ktx.gz",
	bytes: 2971,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/gradient/gradient-pvrtc.ktx",
	bytes: 8292,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/gradient/gradient-pvrtc.ktx.gz",
	bytes: 5695,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/gradient.jpg",
	bytes: 5007,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/matcap1/matcap1-astc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/matcap1/matcap1-astc.ktx.gz",
	bytes: 51387,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/matcap1/matcap1-dxt.ktx",
	bytes: 131192,
	lastChange: "2022-11-01T18:24:59.655Z"
}, {
	filename: "inside/generative/matcap1/matcap1-dxt.ktx.gz",
	bytes: 79601,
	lastChange: "2022-11-01T18:24:59.655Z"
}, {
	filename: "inside/generative/matcap1/matcap1-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.655Z"
}, {
	filename: "inside/generative/matcap1/matcap1-pvrtc.ktx.gz",
	bytes: 88919,
	lastChange: "2022-11-01T18:24:59.655Z"
}, {
	filename: "inside/generative/matcap1.jpg",
	bytes: 82753,
	lastChange: "2022-11-01T18:24:59.651Z"
}, {
	filename: "inside/generative/matcap2.jpg",
	bytes: 17947,
	lastChange: "2022-11-01T18:24:59.655Z"
}, {
	filename: "inside/hokusai/leafalpha/leafalpha-astc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.675Z"
}, {
	filename: "inside/hokusai/leafalpha/leafalpha-astc.ktx.gz",
	bytes: 9956,
	lastChange: "2022-11-01T18:24:59.675Z"
}, {
	filename: "inside/hokusai/leafalpha/leafalpha-dxt.ktx",
	bytes: 131192,
	lastChange: "2022-11-01T18:24:59.691Z"
}, {
	filename: "inside/hokusai/leafalpha/leafalpha-dxt.ktx.gz",
	bytes: 9493,
	lastChange: "2022-11-01T18:24:59.691Z"
}, {
	filename: "inside/hokusai/leafalpha/leafalpha-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.691Z"
}, {
	filename: "inside/hokusai/leafalpha/leafalpha-pvrtc.ktx.gz",
	bytes: 10829,
	lastChange: "2022-11-01T18:24:59.691Z"
}, {
	filename: "inside/hokusai/leafalpha.jpg",
	bytes: 9168,
	lastChange: "2022-11-01T18:24:59.655Z"
}, {
	filename: "inside/memo/1.jpg",
	bytes: 603969,
	lastChange: "2022-11-01T18:24:59.695Z"
}, {
	filename: "inside/memo/2.jpg",
	bytes: 486341,
	lastChange: "2022-11-01T18:24:59.699Z"
}, {
	filename: "inside/memo/3.jpg",
	bytes: 535529,
	lastChange: "2022-11-01T18:24:59.703Z"
}, {
	filename: "inside/memo/memo/memo-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.711Z"
}, {
	filename: "inside/memo/memo/memo-astc.ktx.gz",
	bytes: 1330446,
	lastChange: "2022-11-01T18:24:59.719Z"
}, {
	filename: "inside/memo/memo/memo-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:59.723Z"
}, {
	filename: "inside/memo/memo/memo-dxt.ktx.gz",
	bytes: 1551732,
	lastChange: "2022-11-01T18:24:59.731Z"
}, {
	filename: "inside/memo/memo/memo-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.751Z"
}, {
	filename: "inside/memo/memo/memo-pvrtc.ktx.gz",
	bytes: 1622863,
	lastChange: "2022-11-01T18:24:59.755Z"
}, {
	filename: "inside/memo/memo.jpg",
	bytes: 718554,
	lastChange: "2022-11-01T18:24:59.707Z"
}, {
	filename: "inside/origin/sprite.jpg",
	bytes: 165343,
	lastChange: "2022-11-01T18:24:59.755Z"
}, {
	filename: "inside/origin/sprite2.jpg",
	bytes: 414856,
	lastChange: "2022-11-01T18:24:59.759Z"
}, {
	filename: "inside/rain/matcap/matcap-astc.ktx",
	bytes: 262244,
	lastChange: "2022-11-01T18:24:59.759Z"
}, {
	filename: "inside/rain/matcap/matcap-astc.ktx.gz",
	bytes: 189378,
	lastChange: "2022-11-01T18:24:59.763Z"
}, {
	filename: "inside/rain/matcap/matcap-dxt.ktx",
	bytes: 262264,
	lastChange: "2022-11-01T18:24:59.763Z"
}, {
	filename: "inside/rain/matcap/matcap-dxt.ktx.gz",
	bytes: 61116,
	lastChange: "2022-11-01T18:24:59.763Z"
}, {
	filename: "inside/rain/matcap/matcap-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.763Z"
}, {
	filename: "inside/rain/matcap/matcap-pvrtc.ktx.gz",
	bytes: 71589,
	lastChange: "2022-11-01T18:24:59.763Z"
}, {
	filename: "inside/rain/matcap.png",
	bytes: 174971,
	lastChange: "2022-11-01T18:24:59.759Z"
}, {
	filename: "inside/rain/normal-ring/normal-ring-astc.ktx",
	bytes: 32868,
	lastChange: "2022-11-01T18:24:59.763Z"
}, {
	filename: "inside/rain/normal-ring/normal-ring-astc.ktx.gz",
	bytes: 12407,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/rain/normal-ring/normal-ring-dxt.ktx",
	bytes: 32888,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/rain/normal-ring/normal-ring-dxt.ktx.gz",
	bytes: 14469,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/rain/normal-ring/normal-ring-pvrtc.ktx",
	bytes: 32868,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/rain/normal-ring/normal-ring-pvrtc.ktx.gz",
	bytes: 21698,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/rain/normal-ring.jpg",
	bytes: 5120,
	lastChange: "2022-11-01T18:24:59.763Z"
}, {
	filename: "inside/spriteparticles.png",
	bytes: 5507,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/spriteparticles2/spriteparticles2-astc.ktx",
	bytes: 16484,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/spriteparticles2/spriteparticles2-astc.ktx.gz",
	bytes: 10148,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/spriteparticles2/spriteparticles2-dxt.ktx",
	bytes: 16504,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/spriteparticles2/spriteparticles2-dxt.ktx.gz",
	bytes: 6270,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/spriteparticles2/spriteparticles2-pvrtc.ktx",
	bytes: 8292,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/spriteparticles2/spriteparticles2-pvrtc.ktx.gz",
	bytes: 1770,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/spriteparticles2.png",
	bytes: 2719,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/taco/bud.jpg",
	bytes: 270599,
	lastChange: "2022-11-01T18:24:59.767Z"
}, {
	filename: "inside/taco/video.mp4",
	bytes: 671603,
	lastChange: "2022-11-01T18:24:59.771Z"
}, {
	filename: "inside/vee/sprite.jpg",
	bytes: 327328,
	lastChange: "2022-11-01T18:24:59.771Z"
}, {
	filename: "inside/vee/video.mp4",
	bytes: 2234055,
	lastChange: "2022-11-01T18:24:59.779Z"
}, {
	filename: "kinetic/E6BF3C_5A4719_977726_FCFC82-256px.png",
	bytes: 81655,
	lastChange: "2022-11-01T18:24:59.779Z"
}, {
	filename: "kinetic/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px-astc.ktx",
	bytes: 262244,
	lastChange: "2022-11-01T18:24:59.779Z"
}, {
	filename: "kinetic/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px-astc.ktx.gz",
	bytes: 71489,
	lastChange: "2022-11-01T18:24:59.779Z"
}, {
	filename: "kinetic/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px-dxt.ktx",
	bytes: 262264,
	lastChange: "2022-11-01T18:24:59.783Z"
}, {
	filename: "kinetic/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px-dxt.ktx.gz",
	bytes: 25427,
	lastChange: "2022-11-01T18:24:59.783Z"
}, {
	filename: "kinetic/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.783Z"
}, {
	filename: "kinetic/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px-pvrtc.ktx.gz",
	bytes: 57607,
	lastChange: "2022-11-01T18:24:59.783Z"
}, {
	filename: "kinetic/E7E2D8_B1AA9D_C9C2B3_BCB4AC-512px.png",
	bytes: 58981,
	lastChange: "2022-11-01T18:24:59.779Z"
}, {
	filename: "leafalpha/leafalpha-astc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.783Z"
}, {
	filename: "leafalpha/leafalpha-astc.ktx.gz",
	bytes: 9956,
	lastChange: "2022-11-01T18:24:59.783Z"
}, {
	filename: "leafalpha/leafalpha-dxt.ktx",
	bytes: 131192,
	lastChange: "2022-11-01T18:24:59.783Z"
}, {
	filename: "leafalpha/leafalpha-dxt.ktx.gz",
	bytes: 9493,
	lastChange: "2022-11-01T18:24:59.783Z"
}, {
	filename: "leafalpha/leafalpha-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.787Z"
}, {
	filename: "leafalpha/leafalpha-pvrtc.ktx.gz",
	bytes: 10829,
	lastChange: "2022-11-01T18:24:59.787Z"
}, {
	filename: "leafalpha.jpg",
	bytes: 9168,
	lastChange: "2022-11-01T18:24:59.783Z"
}, {
	filename: "lidar/particle.png",
	bytes: 894,
	lastChange: "2022-11-01T18:24:59.787Z"
}, {
	filename: "lightmap/lightmap-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.799Z"
}, {
	filename: "lightmap/lightmap-astc.ktx.gz",
	bytes: 367552,
	lastChange: "2022-11-01T18:24:59.799Z"
}, {
	filename: "lightmap/lightmap-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:59.811Z"
}, {
	filename: "lightmap/lightmap-dxt.ktx.gz",
	bytes: 611632,
	lastChange: "2022-11-01T18:24:59.819Z"
}, {
	filename: "lightmap/lightmap-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.835Z"
}, {
	filename: "lightmap/lightmap-pvrtc.ktx.gz",
	bytes: 882528,
	lastChange: "2022-11-01T18:24:59.839Z"
}, {
	filename: "lightmap.jpg",
	bytes: 545578,
	lastChange: "2022-11-01T18:24:59.787Z"
}, {
	filename: "lightshaft/light-mask.jpg",
	bytes: 5236,
	lastChange: "2022-11-01T18:24:59.839Z"
}, {
	filename: "lightshaft/noise_combined.jpg",
	bytes: 214704,
	lastChange: "2022-11-01T18:24:59.839Z"
}, {
	filename: "loader/loader.png",
	bytes: 524851,
	lastChange: "2022-11-01T18:24:59.843Z"
}, {
	filename: "loader/logo.jpg",
	bytes: 26354,
	lastChange: "2022-11-01T18:24:59.843Z"
}, {
	filename: "loader/logo.png",
	bytes: 16757,
	lastChange: "2022-11-01T18:24:59.843Z"
}, {
	filename: "logoFrostedGlass/logoFrostedGlass-astc.ktx",
	bytes: 4194404,
	lastChange: "2022-11-01T18:24:59.859Z"
}, {
	filename: "logoFrostedGlass/logoFrostedGlass-astc.ktx.gz",
	bytes: 41246,
	lastChange: "2022-11-01T18:24:59.859Z"
}, {
	filename: "logoFrostedGlass/logoFrostedGlass-dxt.ktx",
	bytes: 4194424,
	lastChange: "2022-11-01T18:24:59.871Z"
}, {
	filename: "logoFrostedGlass/logoFrostedGlass-dxt.ktx.gz",
	bytes: 29214,
	lastChange: "2022-11-01T18:24:59.871Z"
}, {
	filename: "logoFrostedGlass/logoFrostedGlass-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.875Z"
}, {
	filename: "logoFrostedGlass/logoFrostedGlass-pvrtc.ktx.gz",
	bytes: 3174,
	lastChange: "2022-11-01T18:24:59.875Z"
}, {
	filename: "logoFrostedGlass.png",
	bytes: 31257,
	lastChange: "2022-11-01T18:24:59.843Z"
}, {
	filename: "marble_normal/marble_normal-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:59.879Z"
}, {
	filename: "marble_normal/marble_normal-astc.ktx.gz",
	bytes: 179413,
	lastChange: "2022-11-01T18:24:59.883Z"
}, {
	filename: "marble_normal/marble_normal-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:24:59.887Z"
}, {
	filename: "marble_normal/marble_normal-dxt.ktx.gz",
	bytes: 228834,
	lastChange: "2022-11-01T18:24:59.887Z"
}, {
	filename: "marble_normal/marble_normal-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:24:59.891Z"
}, {
	filename: "marble_normal/marble_normal-pvrtc.ktx.gz",
	bytes: 312355,
	lastChange: "2022-11-01T18:24:59.891Z"
}, {
	filename: "marble_normal.jpg",
	bytes: 159675,
	lastChange: "2022-11-01T18:24:59.879Z"
}, {
	filename: "matcap.png",
	bytes: 50511,
	lastChange: "2022-11-01T18:24:59.891Z"
}, {
	filename: "middle_earth.jpg",
	bytes: 702026,
	lastChange: "2022-11-01T18:24:59.899Z"
}, {
	filename: "path/path-mask/path-mask-astc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.899Z"
}, {
	filename: "path/path-mask/path-mask-astc.ktx.gz",
	bytes: 22662,
	lastChange: "2022-11-01T18:24:59.899Z"
}, {
	filename: "path/path-mask/path-mask-dxt.ktx",
	bytes: 131192,
	lastChange: "2022-11-01T18:24:59.899Z"
}, {
	filename: "path/path-mask/path-mask-dxt.ktx.gz",
	bytes: 21729,
	lastChange: "2022-11-01T18:24:59.899Z"
}, {
	filename: "path/path-mask/path-mask-pvrtc.ktx",
	bytes: 131172,
	lastChange: "2022-11-01T18:24:59.899Z"
}, {
	filename: "path/path-mask/path-mask-pvrtc.ktx.gz",
	bytes: 40380,
	lastChange: "2022-11-01T18:24:59.899Z"
}, {
	filename: "path/path-mask.jpg",
	bytes: 31523,
	lastChange: "2022-11-01T18:24:59.899Z"
}, {
	filename: "pbr/lut.png",
	bytes: 16623,
	lastChange: "2022-11-01T18:24:59.899Z"
}, {
	filename: "platforms.jpg",
	bytes: 966096,
	lastChange: "2022-11-01T18:24:59.907Z"
}, {
	filename: "portal/portal-astc.ktx",
	bytes: 4194404,
	lastChange: "2022-11-01T18:24:59.967Z"
}, {
	filename: "portal/portal-astc.ktx.gz",
	bytes: 824037,
	lastChange: "2022-11-01T18:24:59.971Z"
}, {
	filename: "portal/portal-dxt.ktx",
	bytes: 4194424,
	lastChange: "2022-11-01T18:24:59.987Z"
}, {
	filename: "portal/portal-dxt.ktx.gz",
	bytes: 438308,
	lastChange: "2022-11-01T18:24:59.991Z"
}, {
	filename: "portal/portal-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.999Z"
}, {
	filename: "portal/portal-pvrtc.ktx.gz",
	bytes: 569741,
	lastChange: "2022-11-01T18:25:00.003Z"
}, {
	filename: "portal-mask/portal-mask-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.923Z"
}, {
	filename: "portal-mask/portal-mask-astc.ktx.gz",
	bytes: 82135,
	lastChange: "2022-11-01T18:24:59.923Z"
}, {
	filename: "portal-mask/portal-mask-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:24:59.927Z"
}, {
	filename: "portal-mask/portal-mask-dxt.ktx.gz",
	bytes: 117410,
	lastChange: "2022-11-01T18:24:59.931Z"
}, {
	filename: "portal-mask/portal-mask-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:24:59.939Z"
}, {
	filename: "portal-mask/portal-mask-pvrtc.ktx.gz",
	bytes: 233265,
	lastChange: "2022-11-01T18:24:59.939Z"
}, {
	filename: "portal-mask.jpg",
	bytes: 85366,
	lastChange: "2022-11-01T18:24:59.907Z"
}, {
	filename: "portal.png",
	bytes: 790061,
	lastChange: "2022-11-01T18:24:59.943Z"
}, {
	filename: "portals/cube.jpg",
	bytes: 760844,
	lastChange: "2022-11-01T18:25:00.007Z"
}, {
	filename: "portals/cyber.jpg",
	bytes: 901391,
	lastChange: "2022-11-01T18:25:00.015Z"
}, {
	filename: "portals/fantasy.jpg",
	bytes: 893346,
	lastChange: "2022-11-01T18:25:00.019Z"
}, {
	filename: "portals/field/field-astc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:25:00.043Z"
}, {
	filename: "portals/field/field-astc.ktx.gz",
	bytes: 1173888,
	lastChange: "2022-11-01T18:25:00.051Z"
}, {
	filename: "portals/field/field-dxt.ktx",
	bytes: 2097272,
	lastChange: "2022-11-01T18:25:00.067Z"
}, {
	filename: "portals/field/field-dxt.ktx.gz",
	bytes: 1530998,
	lastChange: "2022-11-01T18:25:00.075Z"
}, {
	filename: "portals/field/field-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:25:00.091Z"
}, {
	filename: "portals/field/field-pvrtc.ktx.gz",
	bytes: 1508312,
	lastChange: "2022-11-01T18:25:00.095Z"
}, {
	filename: "portals/field.jpg",
	bytes: 1179227,
	lastChange: "2022-11-01T18:25:00.027Z"
}, {
	filename: "portals/fun.jpg",
	bytes: 863792,
	lastChange: "2022-11-01T18:25:00.103Z"
}, {
	filename: "portals/garden.jpg",
	bytes: 1269543,
	lastChange: "2022-11-01T18:25:00.111Z"
}, {
	filename: "portals/home.jpg",
	bytes: 260041,
	lastChange: "2022-11-01T18:25:00.111Z"
}, {
	filename: "portals/icon-cube.png",
	bytes: 17250,
	lastChange: "2022-11-01T18:25:00.111Z"
}, {
	filename: "portals/icon-cyber.png",
	bytes: 14151,
	lastChange: "2022-11-01T18:25:00.111Z"
}, {
	filename: "portals/icon-fantasy.png",
	bytes: 11924,
	lastChange: "2022-11-01T18:25:00.111Z"
}, {
	filename: "portals/icon-fun.png",
	bytes: 27130,
	lastChange: "2022-11-01T18:25:00.111Z"
}, {
	filename: "portals/icon-garden.png",
	bytes: 12599,
	lastChange: "2022-11-01T18:25:00.111Z"
}, {
	filename: "portals/icon-home.png",
	bytes: 26866,
	lastChange: "2022-11-01T18:25:00.111Z"
}, {
	filename: "portals/water_normal.jpg",
	bytes: 41752,
	lastChange: "2022-11-01T18:25:00.111Z"
}, {
	filename: "prompts/close.png",
	bytes: 3693,
	lastChange: "2022-11-01T18:25:00.111Z"
}, {
	filename: "roomA_color.jpg",
	bytes: 3817419,
	lastChange: "2022-11-01T18:25:00.139Z"
}, {
	filename: "roomB_color.jpg",
	bytes: 2559631,
	lastChange: "2022-11-01T18:25:00.155Z"
}, {
	filename: "roomC_color.jpg",
	bytes: 1486082,
	lastChange: "2022-11-01T18:25:00.163Z"
}, {
	filename: "screens/background.png",
	bytes: 6549,
	lastChange: "2022-11-01T18:25:00.163Z"
}, {
	filename: "screens/env/env-astc.ktx",
	bytes: 16484,
	lastChange: "2022-11-01T18:25:00.279Z"
}, {
	filename: "screens/env/env-astc.ktx.gz",
	bytes: 11765,
	lastChange: "2022-11-01T18:25:00.279Z"
}, {
	filename: "screens/env/env-dxt.ktx",
	bytes: 16504,
	lastChange: "2022-11-01T18:25:00.279Z"
}, {
	filename: "screens/env/env-dxt.ktx.gz",
	bytes: 4014,
	lastChange: "2022-11-01T18:25:00.279Z"
}, {
	filename: "screens/env/env-pvrtc.ktx",
	bytes: 8292,
	lastChange: "2022-11-01T18:25:00.279Z"
}, {
	filename: "screens/env/env-pvrtc.ktx.gz",
	bytes: 4729,
	lastChange: "2022-11-01T18:25:00.279Z"
}, {
	filename: "screens/env-specular/env-specular-astc.ktx",
	bytes: 4194404,
	lastChange: "2022-11-01T18:25:00.223Z"
}, {
	filename: "screens/env-specular/env-specular-astc.ktx.gz",
	bytes: 1600047,
	lastChange: "2022-11-01T18:25:00.231Z"
}, {
	filename: "screens/env-specular/env-specular-dxt.ktx",
	bytes: 4194424,
	lastChange: "2022-11-01T18:25:00.247Z"
}, {
	filename: "screens/env-specular/env-specular-dxt.ktx.gz",
	bytes: 577357,
	lastChange: "2022-11-01T18:25:00.251Z"
}, {
	filename: "screens/env-specular/env-specular-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:25:00.271Z"
}, {
	filename: "screens/env-specular/env-specular-pvrtc.ktx.gz",
	bytes: 1071540,
	lastChange: "2022-11-01T18:25:00.275Z"
}, {
	filename: "screens/env-specular.png",
	bytes: 4235689,
	lastChange: "2022-11-01T18:25:00.199Z"
}, {
	filename: "screens/env.png",
	bytes: 9400,
	lastChange: "2022-11-01T18:25:00.279Z"
}, {
	filename: "screens/mro/mro-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:25:00.283Z"
}, {
	filename: "screens/mro/mro-astc.ktx.gz",
	bytes: 479849,
	lastChange: "2022-11-01T18:25:00.283Z"
}, {
	filename: "screens/mro/mro-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:25:00.287Z"
}, {
	filename: "screens/mro/mro-dxt.ktx.gz",
	bytes: 464267,
	lastChange: "2022-11-01T18:25:00.287Z"
}, {
	filename: "screens/mro/mro-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:25:00.295Z"
}, {
	filename: "screens/mro/mro-pvrtc.ktx.gz",
	bytes: 447705,
	lastChange: "2022-11-01T18:25:00.295Z"
}, {
	filename: "screens/mro.jpg",
	bytes: 510123,
	lastChange: "2022-11-01T18:25:00.279Z"
}, {
	filename: "screens/normals/normals-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:25:00.303Z"
}, {
	filename: "screens/normals/normals-astc.ktx.gz",
	bytes: 403052,
	lastChange: "2022-11-01T18:25:00.303Z"
}, {
	filename: "screens/normals/normals-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:25:00.307Z"
}, {
	filename: "screens/normals/normals-dxt.ktx.gz",
	bytes: 370431,
	lastChange: "2022-11-01T18:25:00.307Z"
}, {
	filename: "screens/normals/normals-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:25:00.315Z"
}, {
	filename: "screens/normals/normals-pvrtc.ktx.gz",
	bytes: 407026,
	lastChange: "2022-11-01T18:25:00.315Z"
}, {
	filename: "screens/normals.jpg",
	bytes: 436407,
	lastChange: "2022-11-01T18:25:00.295Z"
}, {
	filename: "screens/play/play-astc.ktx",
	bytes: 4194404,
	lastChange: "2022-11-01T18:25:00.319Z"
}, {
	filename: "screens/play/play-astc.ktx.gz",
	bytes: 12729,
	lastChange: "2022-11-01T18:25:00.323Z"
}, {
	filename: "screens/play/play-dxt.ktx",
	bytes: 4194424,
	lastChange: "2022-11-01T18:25:00.327Z"
}, {
	filename: "screens/play/play-dxt.ktx.gz",
	bytes: 11370,
	lastChange: "2022-11-01T18:25:00.327Z"
}, {
	filename: "screens/play/play-pvrtc.ktx",
	bytes: 2097252,
	lastChange: "2022-11-01T18:25:00.331Z"
}, {
	filename: "screens/play/play-pvrtc.ktx.gz",
	bytes: 3174,
	lastChange: "2022-11-01T18:25:00.331Z"
}, {
	filename: "screens/play.png",
	bytes: 15869,
	lastChange: "2022-11-01T18:25:00.315Z"
}, {
	filename: "test/2k_atlas.jpg",
	bytes: 523713,
	lastChange: "2022-11-01T18:25:00.335Z"
}, {
	filename: "test/bluenoise64.png",
	bytes: 7114,
	lastChange: "2022-11-01T18:25:00.335Z"
}, {
	filename: "test/georgetest.jpeg",
	bytes: 500564,
	lastChange: "2022-11-01T18:25:00.339Z"
}, {
	filename: "test/georgetest2.jpeg",
	bytes: 825196,
	lastChange: "2022-11-01T18:25:00.343Z"
}, {
	filename: "test/spritesheet1k.png",
	bytes: 1077941,
	lastChange: "2022-11-01T18:25:00.347Z"
}, {
	filename: "test/spritesheettest.png",
	bytes: 554838,
	lastChange: "2022-11-01T18:25:00.351Z"
}, {
	filename: "test-portal-feed.jpg",
	bytes: 139034,
	lastChange: "2022-11-01T18:25:00.335Z"
}, {
	filename: "tree_foliage_lightmap/tree_foliage_lightmap-astc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:25:00.363Z"
}, {
	filename: "tree_foliage_lightmap/tree_foliage_lightmap-astc.ktx.gz",
	bytes: 95345,
	lastChange: "2022-11-01T18:25:00.367Z"
}, {
	filename: "tree_foliage_lightmap/tree_foliage_lightmap-dxt.ktx",
	bytes: 524408,
	lastChange: "2022-11-01T18:25:00.367Z"
}, {
	filename: "tree_foliage_lightmap/tree_foliage_lightmap-dxt.ktx.gz",
	bytes: 153883,
	lastChange: "2022-11-01T18:25:00.371Z"
}, {
	filename: "tree_foliage_lightmap/tree_foliage_lightmap-pvrtc.ktx",
	bytes: 524388,
	lastChange: "2022-11-01T18:25:00.375Z"
}, {
	filename: "tree_foliage_lightmap/tree_foliage_lightmap-pvrtc.ktx.gz",
	bytes: 258273,
	lastChange: "2022-11-01T18:25:00.375Z"
}, {
	filename: "tree_foliage_lightmap.jpg",
	bytes: 128639,
	lastChange: "2022-11-01T18:25:00.351Z"
}, {
	filename: "vfx/bokeh.jpg",
	bytes: 23593,
	lastChange: "2022-11-01T18:25:00.375Z"
}, {
	filename: "vfx/dirtylens.jpg",
	bytes: 242396,
	lastChange: "2022-11-01T18:25:00.379Z"
}], Namespace("DreamUI"), DreamUI.Class((function AccessibilityService() {
	Inherit(this, Component);
	const _this = this;
	_this.isKeyboardNav = !1, async function() {
		_this.events.sub(Keyboard.DOWN, (e => {
			9 === e.keyCode && (_this.isKeyboardNav = !0)
		})), _this.events.sub(Mouse.input, Interaction.CLICK, (() => {
			_this.isKeyboardNav && (_this.isKeyboardNav = !1)
		})), await DreamStyleguide.instance().ready(), HydraCSS.style(".use-keyboard", {
			...DreamStyleguide.instance().withAccessibility
		}), _this.flag("isReady", !0)
	}(), _this.enableKeyboardFocus = function(el, hoverFunction) {
		el.div.onfocus = () => {
			_this.isKeyboardNav && (el.div.classList.contains("use-keyboard") || el.div.classList.add("use-keyboard")), hoverFunction && "function" == typeof hoverFunction && hoverFunction({
				action: "over"
			})
		}, el.div.onblur = () => {
			el.div.classList.contains("use-keyboard") && el.div.classList.remove("use-keyboard"), hoverFunction && "function" == typeof hoverFunction && hoverFunction({
				action: "out"
			})
		}
	}, _this.enableTabNavigation = function(el, clickFunction, hoverFunction, ariaLabel, num = 0) {
		if (el.attr("tabindex", `${num}`), ariaLabel && el.attr("aria-label", ariaLabel), clickFunction) {
			let keys = {};
			el.keydown((e => {
				keys[e.keyCode] = !0, keys[17] && keys[18] && keys[13] && clickFunction(e), keys[17] && keys[18] && keys[32] && clickFunction(e), keys[13] && clickFunction(e), keys[32] && clickFunction(e)
			})), el.keyup((e => {
				keys[e.key] = !1, keys = {}
			}))
		}
		_this.enableKeyboardFocus(el, hoverFunction)
	}, this.ready = function() {
		return _this.wait("isReady")
	}
}), "singleton"), Namespace("DreamUI"), DreamUI.Class((function SkipLinkButton({
	hiddenStyles: hiddenStyles,
	visibleStyles: visibleStyles,
	target: target,
	...rest
}) {
	const _this = this;

	function onFocus() {
		_this.setStyles(function getVisibleStyles() {
			return visibleStyles || {
				element: {
					position: "absolute !important",
					top: 0,
					left: 0,
					right: 0,
					margin: "auto",
					width: "auto",
					height: "auto",
					zIndex: 1,
					background: DreamColors.instance().white
				}
			}
		}())
	}

	function onBlur() {
		_this.setStyles(getHiddenStyles())
	}

	function onClick() {
		_this.target && _this.target.focus?.()
	}

	function getHiddenStyles() {
		return hiddenStyles || {
			element: {
				position: "absolute !important",
				left: "-999px",
				width: "1px",
				height: "1px",
				overflow: "hidden",
				zIndex: "-999"
			}
		}
	}
	Inherit(this, DreamUI.Button, {
		styles: hiddenStyles || getHiddenStyles(),
		...rest
	}), _this.target = target, _this.element?.bind?.("focus", onFocus), _this.element?.bind?.("blur", onBlur), _this.events.sub(_this, DreamUI.Button.CLICK, onClick), _this.setTarget = _target => _this.target = _target, _this.hide = _ => _this.element?.hide?.(), _this.show = _ => _this.element?.show?.(), _this.onDestroy = _ => {
		_this.element?.unbind?.("focus", onFocus), _this.element?.unbind?.("blur", onBlur), _this.events.unsub(_this, DreamUI.Button.CLICK, onClick)
	}
})), Namespace("DreamUI"), DreamUI.Class((function Badge({
	parent: parent,
	styles: styles = {},
	count: count = "",
	size: size = "medium",
	viewComponent: viewComponent
}) {
	Inherit(this, DreamUI.ElementController);
	const _this = this;
	_this.size = size, _this.count = count, async function() {
		await _this.initView({
			component: viewComponent || DreamUI.BadgeView,
			config: {
				parent: parent,
				styles: styles,
				count: count,
				size: size
			}
		})
	}(), _this.updateCount = count => {
		_this.view.text.text(count)
	}, _this.clearBadge = _ => {
		_this.view?.destroy(), _this.destroy()
	}
})), Namespace("DreamUI"), DreamUI.Class((function BadgeStylesheet() {
	Inherit(this, Component);
	const _this = this,
		BASE_ELEMENT = {
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			height: "24px",
			width: "24px",
			borderRadius: "50%",
			textAlign: "center",
			position: "absolute !important",
			top: 0,
			right: 0,
			transform: "translate(50%, -50%)"
		},
		BASE_TEXT = {
			fontSize: "14px",
			color: DreamColors.instance().white
		};
	!async function() {
		await DreamColors.instance().ready(), _this.medium = {
			element: {
				...BASE_ELEMENT,
				background: DreamColors.instance().red500
			},
			text: {
				...BASE_TEXT
			}
		}, _this.large = {
			element: {
				...BASE_ELEMENT,
				height: "32px",
				width: "32px",
				background: DreamColors.instance().red500
			},
			text: {
				...BASE_TEXT,
				fontSize: "18px"
			}
		}, _this.small = {
			element: {
				...BASE_ELEMENT,
				height: "16px",
				width: "16px",
				background: DreamColors.instance().red500
			},
			text: {
				...BASE_TEXT,
				fontSize: "11px"
			}
		}, _this.flag("isReady", !0)
	}(), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function BadgeView({
	parent: parent,
	styles: styles,
	count: count,
	size: size
}) {
	Inherit(this, DreamUI.DreamElement, "span");
	const _this = this,
		$this = _this.element;
	!async function() {
		await DreamUI.BadgeStylesheet.ready(),
			function initElement() {
				parent?.element ? parent.element.div.insertAdjacentElement("beforeend", $this.div) : parent && parent.div.insertAdjacentElement("beforeend", $this.div);
				$this.goob(_this.combineStyles([DreamUI.BadgeStylesheet[size].element, styles.element]))
			}(),
			function initText() {
				_this.text = $this.create(`${_this.constructorName}__text`), _this.text.goob(_this.combineStyles([DreamUI.BadgeStylesheet[size].text, styles.text])), _this.text.text(count)
			}()
	}()
})), Namespace("DreamUI"), DreamUI.Class((function Button({
	animations: animations = DreamUI.ButtonAnimations,
	disabled: disabled,
	viewComponent: viewComponent = DreamUI.ButtonView,
	icon: icon,
	styles: styles = {},
	text: text,
	preset: preset = "none",
	type: type,
	useIconViewBox: useIconViewBox = !1
}) {
	Inherit(this, DreamUI.ElementController);
	const _this = this;
	!async function() {
		_this.disabled = disabled, await _this.initView({
			component: viewComponent,
			config: {
				icon: icon,
				styles: styles,
				text: text,
				preset: preset,
				type: type,
				useIconViewBox: useIconViewBox
			}
		}).ready(), _this.disabled && _this.disable(), _this.flag("isReady", !0)
	}(), _this.handleHover = function(event) {
		animations.onHover(event, _this.view)
	}, _this.handleClick = function() {
		_this.events.fire(DreamUI.Button.CLICK)
	}, _this.handleKeyboardFocus = function(event) {
		_this.events.fire(DreamUI.Button.KEYBOARD_FOCUS, event)
	}, _this.setText = async value => {
		await _this.wait("text"), _this.view.text.text(value)
	}, _this.enable = async _ => {
		await _this.wait("isReady"), _this.view.element && (_this.disabled = !1, _this.view.element.enableInteract(), animations.onEnabled(_this.view), _this.view.element.attr("disabled", null))
	}, _this.disable = async _ => {
		await _this.wait("isReady"), _this.disabled = !0, _this.view.element.disableInteract(), animations.onDisabled(_this.view), _this.view.element.attr("disabled", "disabled")
	}, _this.focus = _ => {
		_this.view.element.div.focus()
	}, _this.setIcon = (_icon, _styles = {}, _useIconViewBox = !1) => {
		_this.view?.icon?.destroy?.(), _this.view.initIcon(_icon, _styles, _useIconViewBox)
	}, _this.get("element", (_ => _this.view?.element)), _this.get("text", (_ => _this.view?.text)), _this.get("icon", (_ => _this.view?.icon))
}), (_ => {
	DreamUI.Button.CLICK = "DreamUI.Button.CLICK", DreamUI.Button.KEYBOARD_FOCUS = "DreamUI.Button.KEYBOARD_FOCUS"
})), Namespace("DreamUI"), DreamUI.Class((function ButtonAnimations() {
	Inherit(this, Component), this.onHover = function({
		action: action
	}, button) {
		switch (action) {
			case "over":
				button.element.tween({
					opacity: .75
				}, 400, "easeOutCubic");
				break;
			case "out":
				button.element.tween({
					opacity: 1
				}, 400, "easeOutCubic")
		}
	}, this.onClick = function(button) {
		button.element.tween({
			opacity: 1
		}, 400, "easeOutCubic")
	}, this.onEnabled = function(button) {
		button.element.css({
			opacity: 1
		}), button.element.hit.css({
			cursor: "pointer"
		})
	}, this.onDisabled = function(button) {
		button.element.css({
			opacity: .5,
			cursor: "not-allowed"
		}), button.element.hit && button.element.hit.css({
			cursor: "not-allowed"
		})
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function ButtonStyles() {
	Inherit(this, Component);
	const _this = this,
		BASE_ELEMENT = {
			"align-items": "center",
			appearance: "none",
			display: "flex",
			"-webkit-appearance": "none",
			background: "none",
			border: "none",
			borderRadius: "0.4rem",
			outline: "none",
			position: "relative",
			textAlign: "center",
			whiteSpace: "nowrap"
		};
	let BASE_TEXT = {};
	const BASE_ICON = {
		height: "2.4rem",
		width: "2.4rem"
	};
	!async function() {
		await DreamColors.instance().ready(), await DreamStyleguide.instance().ready(), BASE_TEXT = {
			...DreamStyleguide.instance().buttonMedium,
			position: "relative",
			fontWeight: "bold"
		}, _this.none = {}, _this.basic = {
			element: {
				...BASE_ELEMENT,
				background: "transparent",
				color: DreamColors.instance().black,
				padding: "1.25rem 3.5rem"
			},
			text: {
				...BASE_TEXT
			},
			icon: {
				...BASE_ICON
			}
		}, _this.fab = {
			element: {
				...BASE_ELEMENT,
				background: DreamColors.instance().primary,
				color: DreamColors.instance().white,
				display: "flex",
				alignItems: "center",
				justifyContent: "center",
				boxShadow: `0 2px 4px ${DreamColors.instance().black}`,
				height: "6rem",
				width: "6rem",
				borderRadius: "100%"
			},
			text: {
				...DreamStyleguide.instance().visuallyHidden
			},
			icon: {
				...BASE_ICON
			}
		}, _this.flat = {
			element: {
				...BASE_ELEMENT,
				background: DreamColors.instance().primary,
				color: DreamColors.instance().white,
				padding: "1.25rem 3.5rem"
			},
			text: {
				...BASE_TEXT
			},
			icon: {
				...BASE_ICON
			}
		}, _this.icon = {
			element: {
				...BASE_ELEMENT,
				background: "transparent",
				color: DreamColors.instance().white,
				display: "flex",
				alignItems: "center",
				justifyContent: "center",
				height: "4rem",
				width: "4rem",
				borderRadius: "100%"
			},
			text: {
				...DreamStyleguide.instance().visuallyHidden
			},
			icon: {
				...BASE_ICON
			}
		}, _this.miniFab = {
			element: {
				...BASE_ELEMENT,
				background: DreamColors.instance().primary,
				color: DreamColors.instance().white,
				display: "flex",
				alignItems: "center",
				justifyContent: "center",
				boxShadow: `0 2px 4px ${DreamColors.instance().black}`,
				height: "4rem",
				width: "4rem",
				borderRadius: "100%"
			},
			text: {
				...DreamStyleguide.instance().visuallyHidden
			},
			icon: {
				...BASE_ICON
			}
		}, _this.pill = {
			element: {
				...BASE_ELEMENT,
				background: DreamColors.instance().primary,
				color: DreamColors.instance().white,
				display: "flex",
				alignItems: "center",
				justifyContent: "center",
				borderRadius: "3rem",
				padding: "0.7rem 2.2rem"
			},
			text: {
				...BASE_TEXT,
				fontSize: "1.7rem"
			},
			icon: {
				...BASE_ICON
			}
		}, _this.raised = {
			element: {
				...BASE_ELEMENT,
				background: DreamColors.instance().primary,
				color: DreamColors.instance().white,
				padding: "1.25rem 3.5rem",
				boxShadow: "0 2px 4px"
			},
			text: {
				...BASE_TEXT
			},
			icon: {
				...BASE_ICON,
				position: "absolute",
				right: "1rem",
				top: "50%",
				transform: "translateY(-50%)"
			}
		}, _this.roundedStroked = {
			element: {
				...BASE_ELEMENT,
				background: DreamColors.instance().blue500,
				border: `2px solid ${DreamColors.instance().blue500}`,
				borderRadius: "5rem",
				color: DreamColors.instance().white,
				justifyContent: "center",
				padding: "1rem 2rem"
			},
			text: {
				...BASE_TEXT
			},
			icon: {
				...BASE_ICON
			}
		}, _this.stroked = {
			element: {
				...BASE_ELEMENT,
				background: DreamColors.instance().white,
				border: `1px solid ${DreamColors.instance().gray300}`,
				color: DreamColors.instance().blue600,
				justifyContent: "center",
				padding: "1.2rem 1.8rem"
			},
			text: {
				...BASE_TEXT
			},
			icon: {
				...BASE_ICON
			}
		}, _this.flag("isReady", !0)
	}(), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function ButtonView({
	icon: icon,
	styles: styles,
	text: text,
	preset: preset,
	type: type,
	useIconViewBox: useIconViewBox
}) {
	Inherit(this, DreamUI.DreamElement, "button");
	const _this = this,
		$this = _this.element;

	function initIcon(_icon, _styles, _useIconViewBox) {
		const iconStyles = _styles.icon || _styles;
		_this.icon = _this.initClass(Sprite, _icon, iconStyles, _icon, !0, _useIconViewBox), _this.icon.element.goob(_this.combineStyles([DreamUI.ButtonStyles[preset].icon, _styles.icon]))
	}!async function() {
		await DreamUI.ButtonStyles.ready(), $this.attr && (! function initElement() {
			$this.attr("aria-label", text), $this.goob(_this.combineStyles([DreamUI.ButtonStyles[preset].element, styles.element])), type && $this.attr("type", type);
			_this.parent.disabled && $this.attr("disabled", "disabled")
		}(), text && function initText() {
			_this.text = $this.create(`${_this.constructorName}__text`), _this.text.goob(_this.combineStyles([DreamUI.ButtonStyles[preset].text, styles.text])), _this.text.text(text)
		}(), icon && initIcon(icon, styles, useIconViewBox), function addA11y() {
			DreamUI.AccessibilityService.instance().enableTabNavigation($this, _this.parent.handleClick, _this.parent.handleKeyboardFocus)
		}(), function addHandlers() {
			$this.interact(_this.parent.handleHover, _this.parent.handleClick), _this.parent.disabled && $this.disableInteract()
		}(), _this.flag("isReady", !0))
	}(), _this.setStyles = async replacedStyles => {
		await _this.wait("isReady"), replacedStyles && (_this.element && replacedStyles.element && _this.element.css(replacedStyles.element), _this.text && replacedStyles.text && _this.text.css(replacedStyles.text), _this.icon && replacedStyles.icon && _this.icon.element.css(replacedStyles.icon))
	}, _this.initIcon = initIcon, _this.ready = _ => _this.wait("isReady")
})), Namespace("DreamUI"), DreamUI.Class((function CSSStylesLoader() {
	Inherit(this, Component);
	const _this = this;
	_this.load = function load(hydraObject) {
		hydraObject.goob(_this.styles)
	}
})), Namespace("DreamUI"), Namespace("DreamUI"), DreamUI.Class((function DreamElement(type) {
	Inherit(this, Element, type);
	const _this = this;
	_this.element;

	function _isArrayLike(possibleArray) {
		return !! function _isArray(val) {
			return null != val && val.length >= 0 && "[object Array]" === Object.prototype.toString.call(val)
		}(possibleArray) || !!possibleArray && ("object" == typeof possibleArray && (0 === possibleArray.length || possibleArray.length > 0 && (possibleArray.hasOwnProperty(0) && x.hasOwnProperty(possibleArray.length - 1))))
	}!async function() {
		_this.constructorName = Utils.getConstructorName(_this), _this.styleguide = DreamStyleguide.instance(), _this.colors = DreamColors.instance(), _this.binds = []
	}(), this.combineStyles = function(objArray) {
		let list;
		return list = function flatten(list) {
				var value, jlen, j, result = [],
					idx = 0,
					ilen = list.length;
				const flatt = list => {
					for (; idx < ilen;) {
						if (_isArrayLike(list[idx]))
							for (value = flatt(list[idx]), j = 0, jlen = value.length; j < jlen;) result[result.length] = value[j], j += 1;
						else result[result.length] = list[idx];
						idx += 1
					}
					return result
				};
				return flatt(list)
			}(objArray),
			function _mergeAll(target) {
				if (null == target) throw new TypeError("Cannot convert undefined or null to object");
				for (var output = Object(), idx = 0, length = target.length; idx < length;) {
					var source = target[idx];
					if (null != source)
						for (var nextKey in source) output[nextKey] = source[nextKey];
					idx += 1
				}
				return output
			}(list)
	}, this.parseConfig = function(config) {
		for (let key in config) _this[key] = config[key]
	}, this.getPrefix = function(className) {
		return `${Utils.getConstructorName(this)}__${className}`
	}, this.hideLoader = () => {
		DreamUI.Modal.instance().close()
	}, this.showLoader = (view, config) => {
		DreamUI.Modal.instance().open(view, {
			closeOnClickOutside: !1,
			options: config
		})
	}, this.setStyles = async (styleOverwrite, pairLookupArr = []) => {
		if (await _this.wait("isReady"), !styleOverwrite) return;
		_this.styles = styleOverwrite;
		[...Object.keys(styleOverwrite).map((v => ({
			domKey: v,
			styleKey: v
		}))), ...pairLookupArr].forEach((k => {
			let domObj = k.domKey.split(".").reduce(((a, c) => a?.[c]), _this),
				newStyle = k.styleKey.split(".").reduce(((a, c) => a?.[c]), styleOverwrite);
			domObj?.css && newStyle && domObj.css(newStyle)
		}))
	}, _this.ready = _ => _this.wait("isReady"), _this.setReady = (val = !0) => _this.flag("isReady", val), this.onDestroy = () => {
		_this.binds.forEach((bind => {
			bind.destroy()
		}))
	}
})), Namespace("DreamUI"), DreamUI.Class((function ElementController({
	withState: withState = !1,
	controllerStyles: controllerStyles
} = {}) {
	Inherit(this, Element);
	const _this = this;
	_this.state = null, withState && (_this.state = AppState.createLocal()), controllerStyles && _this.element.goob({
		...controllerStyles
	}), _this.initView = function({
		component: component,
		config: config
	}) {
		return _this.view = _this.initClass(component, config), _this.view
	}, _this.ready = _ => _this.wait("isReady"), _this.setReady = (val = !0) => _this.flag("isReady", val), _this.setStyles = async (...args) => (await _this.wait("view"), await (_this.view?.ready?.()), _this.view?.setStyles?.(...args)), _this.get("isFormControl", (_ => _this.view.isFormControl))
})), Namespace("DreamUI"), DreamUI.Class((function Form({
	viewComponent: viewComponent = {},
	viewOptions: viewOptions
}) {
	Inherit(this, DreamUI.ElementController);
	const _this = this;
	_this.fields = [], async function() {
		_this.delayedCall((_ => {
				_this.flag("viewLoaded") || console.error("DreamUI.Form: the viewComponent needs to set the isReady flag for the form fields to be registered!")
			}), 1e3), await _this.initView({
				component: viewComponent,
				config: {
					formContext: _this,
					...viewOptions
				}
			}).ready(), _this.flag("viewLoaded", !0),
			function __initFields() {
				if (!_this.view) return;
				for (item in _this.view) _this.view[item]?.isFormControl && _this.add(_this.view[item])
			}(), _this.flag("isReady", !0)
	}(), _this.add = field => {
		_this.fields.push(field)
	}, _this.remove = field => {
		_this.fields.remove(field)
	}, _this.validate = async _ => -1 === (await Promise.all(_this.fields.filter((field => field.validate)).map((field => field.validate())))).indexOf(!1), _this.submit = async _ => {
		let values = {};
		return await _this.validate() ? (_this.fields.filter((field => field.id && field.value)).forEach((field => {
			values[field.id] = field.value
		})), _this.events.fire(DreamUI.Form.VALID, {
			values: values
		}), _this.events.fire(DreamUI.Form.SUBMIT, {
			values: values
		})) : _this.events.fire(DreamUI.Form.INVALID, {
			values: values
		}), values
	}
}), (_ => {
	DreamUI.Form.SUBMIT = "DreamUI.Form.SUBMIT", DreamUI.Form.INVALID = "DreamUI.Form.INVALID", DreamUI.Form.VALID = "DreamUI.Form.VALID"
})), Namespace("DreamUI"), DreamUI.Class((function FormControl() {
	Inherit(this, DreamUI.DreamElement);
	const _this = this;
	_this.element;
	_this.isFormControl = !0, DreamUI.AccessibilityService.instance(), _this.handleFocus = async function() {
		await _this.wait(1), DreamUI.AccessibilityService.instance().isKeyboardNav ? _this.keyboardFocusStyles() : _this.mouseFocusStyles()
	}, _this.keyboardFocusStyles = function() {}, _this.mouseFocusStyles = function() {}, _this.setReady = _ => _this.flag("isReady", !0), _this.ready = _ => _this.flag("isReady")
})), Namespace("DreamUI"), DreamUI.Class((function Select({
	viewComponent: viewComponent = DreamUI.SelectView,
	styles: styles = {},
	id: id,
	label: label = "",
	options: options = [],
	required: required = !1,
	icon: icon = "core-chevron-bottom",
	value: value = null,
	errorMessage: errorMessage = "This field is required",
	placeholder: placeholder = "Select",
	preset: preset = "default",
	emitsEventWhenValuePopulatedOnInit: emitsEventWhenValuePopulatedOnInit = !1,
	enableHover: enableHover = !1
}) {
	Inherit(this, DreamUI.ElementController);
	const _this = this;
	!async function() {
		if (!id) return console.error(`${_this.constructorName} requires an ID.`);
		_this.id = id, _this.value = value, _this.preset = preset, await _this.initView({
				component: viewComponent,
				config: {
					styles: styles,
					id: id,
					label: label,
					options: options,
					required: required,
					icon: icon,
					preset: preset,
					enableHover: enableHover
				}
			}).ready(),
			function handlePresetSpecific() {
				switch (preset) {
					case "labelAsPlaceholder":
						_this.view.prependLabelToInputWrapper?.(), _this.view.setBlankOptionText?.("");
						break;
					case "default":
					case "rounded":
						_this.view.setBlankOptionText?.(placeholder), _this.view.input.div.classList.remove("is-selected"), _this.view.input.div.classList.add("is-unselected");
						break;
					default:
						_this.view.setBlankOptionText?.(placeholder)
				}
			}(), null !== value && function handlePopulatedValueOnInit() {
				_this.view.input.div.value = value, _this.handleValueChange({
					val: _this.value,
					emitEvent: emitsEventWhenValuePopulatedOnInit
				})
			}(), _this.setReady()
	}(), _this.handleFocus = function() {
		_this.view.handleFocus()
	}, _this.handleBlur = function() {
		_this.value && 0 !== _this.value.length ? (_this.view.label.div.classList.remove("no-value"), _this.view.label.div.classList.add("has-value")) : (_this.view.label.div.classList.add("no-value"), _this.view.label.div.classList.remove("has-value")), _this.view.input.div.classList.remove("is-focused")
	}, _this.handleValueChange = function({
		val: val,
		emitEvent: emitEvent = !0
	}) {
		_this.value = val, "default" !== preset && "rounded" !== preset || (_this.view.input.div.classList.remove("is-unselected"), _this.view.input.div.classList.add("is-selected")), null !== _this.value && _this.handleLabelWhenValuePopulated(), emitEvent && _this.events.fire(DreamUI.Select.CHANGE, {
			value: _this.value
		})
	}, _this.handleLabelWhenValuePopulated = function() {
		_this.view.label.div.classList.remove("no-value"), _this.view.label.div.classList.add("has-value")
	}, _this.validate = () => {
		let valid;
		return valid = !!(required && _this.value && _this.value.length > 0) || !(required && (!_this.value || _this.value && _this.value.length > 0)), valid ? _this.view.error && _this.view.error.text("") : (_this.view.element.classList.add("has-error"), _this.view.error && _this.view.error.text(errorMessage)), valid
	}, _this.updateOptions = opts => {
		_this.view.updateOptions(opts)
	}, _this.ready = () => _this.wait("isReady")
}), (() => {
	DreamUI.Select.CHANGE = "DreamUI.Select.CHANGE", DreamUI.Select.VALUE_POPULATED_ON_INIT = "DreamUI.Select.VALUE_POPULATED_ON_INIT"
})), Namespace("DreamUI"), DreamUI.Class((function SelectStyles({
	config: config = {}
}) {
	Inherit(this, DreamUI.CSSStylesLoader);
	this.styles = {
		position: "relative",
		display: "flex",
		alignItems: "center",
		...config.styles.element,
		".label": {
			position: "relative",
			color: DreamColors.instance().black,
			font: `1.4rem ${DreamStyleguide.instance().fonts.primary}`,
			".required": {
				color: DreamColors.instance().red
			},
			"&.has-value": {
				top: "5%",
				opacity: 1
			},
			"&.no-value": {
				top: "50%",
				background: "transparent"
			},
			...config.styles[".label"]
		},
		svg: {
			height: "2rem",
			width: "2rem",
			position: "absolute !important",
			right: ".5rem",
			pointerEvents: "none",
			...config.styles.svg
		},
		".inputWrapper": {
			display: "flex",
			alignItems: "center",
			position: "relative",
			background: "white",
			marginLeft: "15px",
			"&:hover": {
				".inputHover": {
					opacity: 1
				}
			},
			...config.styles[".inputWrapper"]
		},
		".inputHover": {
			position: "absolute !important",
			top: "0",
			left: "0",
			right: "0",
			height: "100%",
			background: "transparent",
			padding: 0,
			boxShadow: "rgba(99, 99, 99, 0.2) 0px 2px 8px 0px;",
			opacity: 0,
			...config.styles[".inputHover"]
		},
		".input": {
			padding: "1rem 3rem 1rem 1rem",
			"-webkit-appearance": "none",
			"-moz-appearance": "none",
			appearance: "none",
			position: "relative",
			width: "100%",
			border: "none",
			outline: "none",
			font: `1.4rem ${DreamStyleguide.instance().fonts.primary}`,
			color: DreamColors.instance().hexToRgba(DreamColors.instance().black, .5),
			"&.is-selected": {
				color: config.selectedColor || DreamColors.instance().black
			},
			"&.is-unselected": {
				color: config.unselectedColor || DreamColors.instance().hexToRgba(DreamColors.instance().black, .5)
			},
			"&.is-focused": {
				...DreamStyleguide.instance().withAccessibility
			},
			"&.is-unfocused": {
				...DreamStyleguide.instance().withoutAccessibility
			},
			".option": {
				position: "relative",
				padding: "1.5rem",
				font: `1.4rem ${DreamStyleguide.instance().fonts.primary}`
			},
			...config.styles[".input"]
		},
		".error": {
			color: DreamColors.instance().red,
			font: `1rem/2rem ${DreamStyleguide.instance().fonts.primary}`,
			height: "2rem",
			padding: "0.5rem 0",
			opacity: 0,
			...config.styles[".error"]
		},
		"&.has-error": {
			".error": {
				opacity: 1
			}
		},
		"&.labelAsPlaceholder": {
			".label": {
				left: "0rem",
				color: DreamColors.instance().primary,
				position: "absolute !important",
				top: "50%",
				transform: "translateY(-50%)",
				transition: "0.2s ease all",
				padding: ".25rem",
				paddingLeft: "0rem",
				pointerEvents: "none",
				font: `1.4rem ${DreamStyleguide.instance().fonts.primary}`,
				zIndex: 1,
				"&.has-value": {
					display: "none"
				}
			}
		},
		"&.rounded": {
			".inputWrapper": {
				borderRadius: "6.4rem",
				overflow: "hidden",
				border: "1px solid black"
			},
			".input": {
				"&.is-selected": {
					color: config.selectedColor || DreamColors.instance().black
				},
				"&.is-unselected": {
					color: config.unselectedColor || DreamColors.instance().hexToRgba(DreamColors.instance().black, .5)
				}
			}
		}
	}
})), Namespace("DreamUI"), DreamUI.Class((function SelectView({
	styles: styles = {},
	id: id,
	label: label = "",
	options: options = [],
	required: required = !1,
	icon: icon,
	preset: preset = "default",
	enableHover: enableHover = !1
}) {
	Inherit(this, DreamUI.FormControl);
	const _this = this,
		$this = _this.element;

	function createOptions() {
		_this.blankOption || (_this.blankOption = _this.input.create("option", "option"), _this.blankOption.attr("disabled", ""), _this.blankOption.attr("value", !1), _this.blankOption.attr("hidden", ""), _this.blankOption.attr("selected", !0)), _this.options = options.map(createOption), _this.options && 0 !== _this.options.length || (_this.disabled = !0, _this.label.attr("disabled", "true"), _this.label.text("No options are available."))
	}

	function createOption(option) {
		let $option = _this.input.create("option", "option");
		return $option.attr("value", option.value), $option.text(option.text), option.selected && $option.attr("selected", !0), $option
	}! function() {
		if (!id) return console.error(`${_this.constructorName} requires an ID.`);
		_this.preset = preset,
			function initElement() {
				$this.div.classList.add(preset)
			}(),
			function initLabel() {
				let stripped = label.replace(" ", "");
				_this.label = $this.create("label", "label"), _this.label.text(label), _this.label.attr("for", stripped), _this.label.attr("id", `${stripped}_label`), required && label && (_this.label.inner = _this.label.create("required", "span"), _this.label.inner.text(" *"))
			}(),
			function initInput() {
				_this.inputWrapper = $this.create("inputWrapper").goob({
					position: "relative"
				});
				let stripped = label.replace(" ", "");
				_this.inputHover = _this.inputWrapper.create("inputHover"), _this.input = _this.inputWrapper.create("input", "select"), _this.input.attr("name", stripped), _this.input.attr("aria-labeledby", `${stripped}_label`), _this.input.attr("role", "button"), _this.input.attr("tabindex", "0")
			}(),
			function initStyles() {
				_this.initClass(DreamUI.SelectStyles, {
					config: {
						styles: styles
					}
				}).load($this)
			}(), icon && function setIcon() {
				_this.icon = _this.initClass(Sprite, icon, null, null, [_this.inputWrapper])
			}(), createOptions(), required && function initError() {
				_this.error = $this.create("error")
			}(),
			function addHandlers() {
				_this.input.bind("focus", (_ => _this.parent.handleFocus())), _this.input.bind("blur", (_ => _this.parent.handleBlur())), _this.input.bind("change", (_ => _this.parent.handleValueChange({
					val: _this.input.div.value
				}))), enableHover && (_this.input.bind("mouseenter", (e => _this.parent.handleHover(e))), _this.input.bind("mouseleave", (e => _this.parent.handleHover(e))))
			}(), _this.setReady()
	}(), _this.prependLabelToInputWrapper = function() {
		_this.inputWrapper.div.prepend(_this.label.div)
	}, _this.appendFocusBarToInputWrapper = function() {
		_this.focusBar = _this.inputWrapper.create("focus", "span")
	}, _this.setBlankOptionText = function(_text) {
		_this.blankOption.text(_text)
	}, _this.keyboardFocusStyles = () => {
		_this.input.div.classList.remove("is-unfocused"), _this.input.div.classList.add("is-focused")
	}, _this.mouseFocusStyles = () => {
		_this.input.div.classList.remove("is-focused"), _this.input.div.classList.add("is-unfocused")
	}, _this.updateOptions = newOptions => {
		options = newOptions, _this.options.forEach((option => {
			option.destroy()
		})), createOptions()
	}, _this.ready = () => _this.wait("isReady")
})), Namespace("DreamUI"), DreamUI.Class((function Tab({
	persist: persist = "some",
	tabs: tabs = [],
	styles: styles = {},
	animation: animation = DreamUI.TabAnimations,
	preset: preset = "material"
}) {
	Inherit(this, DreamUI.DreamElement, "div");
	const _this = this,
		$this = _this.element;

	function initTabView(index, tab = _this.contentTabs[index]) {
		let data = _this.tabs[index],
			view = _this.initClass(data.get("view"), {
				...data.get("viewOptions"),
				tab: _this
			}, [tab]);
		return view.tabIndex = index, view
	}

	function shouldTabPersist(index) {
		return "some" === persist ? !1 !== _this.tabs[index].persist : persist
	}
	async function switchTab(selectedIndex, userInitiated) {
		if (selectedIndex === _this.activeIndex) return;
		_this.notifier.manageNotifications(selectedIndex, _this.activeIndex), _this.tab = _this.tabs[selectedIndex], _this.headerTab = _this.headerTabs[selectedIndex], _this.contentTab = _this.contentTabs[selectedIndex], _this.headerTab.attr("aria-selected", !0), _this.headerTab.css(_this.combineStyles([DreamUI.TabStyles[preset].headerTabActive, styles.headerTabActive])), _this.headerTabs[_this.activeIndex].attr("aria-selected", !1), _this.headerTabs[_this.activeIndex].css(_this.combineStyles([DreamUI.TabStyles[preset].headerTabInactive, styles.headerTabInactive])), _this.clearBadge(selectedIndex);
		let prevTabClass = _this.contentTabClass,
			prevIndex = _this.activeIndex;
		_this.activeIndex = selectedIndex, _this.events.fire(DreamUI.Tab.CHANGE, {
			prevIndex: prevIndex,
			activeIndex: selectedIndex,
			userInitiated: userInitiated
		});
		let promise = animation.animateChange(_this, selectedIndex);
		if (shouldTabPersist(selectedIndex)) _this.contentTabClass = _this.contentTab.view;
		else {
			let contentTabClass = initTabView(selectedIndex);
			_this.contentTabClass = contentTabClass
		}
		prevTabClass && !shouldTabPersist(prevIndex) && (await promise, prevTabClass.destroy()),
			function addPanelAccessibility(element, label) {
				element.attr("id", `${label}`), element.attr("role", "tabpanel"), element.attr("aria-labeledby", `tab-${label}`)
			}(_this.contentTabClass.element, _this.tab.get("label")), animateBar(), Track.event(Router.getState()[0], "tab", _this.tab.get("label"))
	}

	function animateBar() {
		$this && $this.div && animation.animateBar(_this)
	}

	function handleTabClick(event) {
		event instanceof HydraObject ? switchTab(event.index, !0) : switchTab(event.object.index, !0)
	}

	function handleTabHover(event) {
		animation.onHover(event)
	}
	_this.tabs = new StateArray(tabs), _this.activeIndex = 0, _this.headerTabs = [], _this.contentTabs = [], _this.bar = null, _this.headerTabsBadges = [], _this.notifer = null, _this.handleNotification = function handleNotification(index) {
		_this.addBadge(index)
	}, async function() {
		await DreamUI.TabStyles.ready(), _this.notifier = _this.initClass(DreamUI.TabNotifier),
			function initElement() {
				$this.goob(_this.combineStyles([DreamUI.TabStyles[preset].element, styles.element])), _this.header = $this.create(`${_this.constructorName}__header`, "ul"), _this.header.goob(_this.combineStyles([DreamUI.TabStyles[preset].header, styles.header])), _this.headerWrapper = _this.header.create(`${_this.constructorName}__header__wrapper`), _this.headerWrapper.goob(_this.combineStyles([DreamUI.TabStyles[preset].headerWrapper, styles.headerWrapper])), _this.content = $this.create(`${_this.constructorName}__content`), _this.content.goob(_this.combineStyles([DreamUI.TabStyles[preset].content, styles.content]))
			}(),
			function initBar() {
				_this.bar = _this.header.create(`${_this.constructorName}__bar`), _this.bar.goob(_this.combineStyles([DreamUI.TabStyles[preset].bar, styles.bar]))
			}(),
			function initTabs() {
				_this.headerTabs = _this.tabs.map(((data, index) => {
					let label = data.get("label"),
						isActiveTab = index === _this.activeIndex,
						tabElement = _this.headerWrapper.create(`${_this.constructorName}__tab`);
					return tabElement.data = data, tabElement.index = index, tabElement.attr("aria-controls", label), tabElement.attr("aria-selected", isActiveTab), tabElement.attr("id", `tab-${label}`), tabElement.attr("role", "tab"), tabElement.attr("data-index", index), tabElement.text(label), tabElement.index = index, isActiveTab ? tabElement.goob(_this.combineStyles([DreamUI.TabStyles[preset].headerTabActive, styles.headerTabActive])) : tabElement.goob(_this.combineStyles([DreamUI.TabStyles[preset].headerTabInactive, styles.headerTabInactive])), index !== _this.tabs.length - 1 && tabElement.goob(_this.combineStyles([DreamUI.TabStyles[preset].headerTabSpacing, styles.headerTabSpacing])), tabElement.interact(handleTabHover, handleTabClick), DreamUI.AccessibilityService.instance().enableTabNavigation(tabElement, (_ => handleTabClick(tabElement)), handleTabHover), tabElement.data.notifierSettings && _this.notifier.bindToNotification(tabElement), tabElement
				})), _this.content.css({
					width: 100 * _this.tabs.length + "%"
				}), _this.contentTabs = _this.tabs.map(((data, index) => {
					let tab = _this.content.create(`${_this.constructorName}__tab`);
					return tab.goob(_this.combineStyles([DreamUI.TabStyles[preset].contentTab, styles.contentTab])), tab.data = data, shouldTabPersist(index) ? tab.view = initTabView(index, tab) : _this.activeIndex === index && (_this.contentTabClass = initTabView(index, tab)), _this.activeIndex !== index && tab.invisible(), tab
				}))
			}(), animateBar(), _this.flag("isReady", !0)
	}(), _this.addBadge = (index, count = "", badgeStyles = {}) => {
		_this.clearBadge(index), _this.headerTabsBadges[index] = _this.initClass(DreamUI.Badge, {
			count: count,
			size: "small",
			styles: _this.combineStyles([DreamUI.TabStyles[preset].badge, styles.badge]),
			parent: _this.headerTabs[index]
		})
	}, _this.clearBadge = tabIndex => {
		_this.headerTabsBadges[tabIndex] && (_this.headerTabsBadges[tabIndex].clearBadge(), _this.headerTabsBadges[tabIndex] = null)
	}, _this.change = index => switchTab(index), _this.ready = _ => _this.wait("isReady")
}), (() => {
	DreamUI.Tab.CHANGE = "DreamUI.Tab.CHANGE"
})), Namespace("DreamUI"), DreamUI.Class((function TabAnimations() {
	Inherit(this, Component);
	const _this = this,
		EASE = "easeInOutCubic";
	this.onHover = function({
		action: action,
		object: object
	}, tab) {
		switch (action) {
			case "over":
				object?.tween({
					opacity: .5
				}, 600, EASE);
				break;
			case "out":
				object?.tween({
					opacity: 1
				}, 600, EASE)
		}
	}, this.onClick = function() {}, this.animateIn = function(view, transitionDirection) {
		return "ltr" === transitionDirection ? (view.css({
			opacity: 0
		}).transform({
			x: "-100%"
		}), view.tween({
			opacity: 1,
			x: 0
		}, 600, EASE).promise()) : (view.css({
			opacity: 0
		}).transform({
			x: "100%"
		}), view.tween({
			opacity: 1,
			x: 0
		}, 600, EASE).promise())
	}, this.animateOut = function(view, transitionDirection) {
		return "ltr" === transitionDirection ? view.tween({
			opacity: 0,
			x: "100%"
		}, 600, EASE).promise() : view.tween({
			opacity: 1,
			x: "-100%"
		}, 600, EASE).promise()
	}, this.animateBar = async function(tab) {
		await this.wait(200);
		let scroll = tab.header.div.scrollLeft || 0,
			padding = parseInt(getComputedStyle(tab.header.div).paddingLeft),
			{
				left: left,
				width: width
			} = tab.headerTabs[tab.activeIndex].div.getBoundingClientRect();
		const fullWidth = tab.element.div.getBoundingClientRect().left;
		left += scroll, tab.bar.tween({
			width: width,
			x: left - fullWidth - padding,
			y: "0"
		}, 600, EASE)
	}, this.animateChange = function({
		content: content,
		contentTabs: contentTabs,
		header: header,
		headerWrapper: headerWrapper,
		headerTabs: headerTabs,
		headerTab: headerTab
	}, index) {
		let headerStyles = getComputedStyle(header.div),
			headerPadding = parseInt(headerStyles.paddingLeft),
			xLimit = headerWrapper.div.clientWidth - header.div.clientWidth + 2 * headerPadding,
			x = Math.clamp(headerTab.div.offsetLeft, xLimit, 0);
		return headerWrapper.tween({
			x: -x
		}, 600, EASE), content.tween({
			x: `-${index/headerTabs.length*100}%`
		}, 600, EASE), contentTabs.forEach(((tab, tabIndex) => {
			index === tabIndex ? (tab.css({
				height: "100%"
			}), tab.visible(), tab.tween({
				opacity: 1
			}, 300, EASE)) : tab.tween({
				opacity: 0
			}, 300, EASE, (_ => {
				tab.invisible(), tab.css({
					height: 0
				})
			}))
		})), _this.wait(600)
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function TabNotifier() {
	Inherit(this, Component);
	let _notificationCache = {};
	const _this = this;
	async function createNotificationBinding(tabObj) {
		tabObj.notificationBinding?.destroy(), tabObj.notificationBinding = null;
		const binding = (await tabObj.notifierInstance.notifierState()).bind("all", AppStateOperators.skip(1), AppStateOperators.filter((data => null !== data)), (() => {
			_this.parent.handleNotification(tabObj.index), tabObj.notifierInstance.deactivate()
		}));
		return _notificationCache[tabObj.label] = binding, binding
	}
	_this.bindToNotification = async function(tabObj) {
		const {
			NotifierClass: NotifierClass,
			roomId: roomId
		} = tabObj.data.notifierSettings();
		if (void 0 === NotifierClass) throw new Error("DreamUITab: You are trying to add a notifier class that doesn't exist, make sure you import model-session-notifier");
		tabObj.notifierInstance || (tabObj.notifierInstance = _this.initClass(NotifierClass, roomId)), await tabObj.notifierInstance.ready(), tabObj.index !== _this.parent.activeIndex && (await tabObj.notifierInstance.activate(), tabObj.notificationBinding = await createNotificationBinding(tabObj))
	}, _this.manageNotifications = async function(selectedIndex, activeIndex) {
		const tabEntering = _this.parent.headerTabs[selectedIndex],
			tabExiting = _this.parent.headerTabs[activeIndex];
		tabExiting.notifierInstance && (tabExiting.notifierInstance?.activate(), tabExiting.notificationBinding = await createNotificationBinding(tabExiting)), tabEntering.notifierInstance && tabEntering.notifierInstance?.deactivate()
	}, _this.onDestroy = function() {
		Object.values(_notificationCache).forEach((val => {
			val.destroy?.(), val = null
		}))
	}
})), Namespace("DreamUI"), DreamUI.Class((function TabStyles() {
	Inherit(this, Component);
	const _this = this;
	!async function() {
		await DreamColors.instance().ready(), await DreamStyleguide.instance().ready();
		const BASE_ELEMENT = {
				display: "flex",
				flexDirection: "column",
				height: "100%",
				width: "100%",
				overflow: "hidden"
			},
			BASE_HEADER = {
				alignItems: "center",
				display: "flex",
				padding: "0 3rem",
				whiteSpace: "nowrap",
				width: "100%"
			},
			BASE_HEADER_CONTENT = {
				alignItems: "center",
				display: "flex",
				paddingTop: "ios" === Device.system.os ? "0.3rem" : "0"
			},
			BASE_HEADER_TAB = {
				...DreamStyleguide.instance().label3,
				alignItems: "center",
				cursor: "pointer",
				display: "flex",
				fontWeight: "bold",
				justifyContent: "center",
				outline: "none",
				padding: "0 0 2rem",
				position: "relative"
			},
			BASE_BORDERED_TAB = {
				...DreamStyleguide.instance().buttonMedium,
				alignItems: "center",
				border: `0.2rem solid ${DreamColors.instance().blue500}`,
				borderRadius: "5rem",
				cursor: "pointer",
				display: "flex",
				fontWeight: "bold",
				justifyContent: "center",
				outline: "none",
				padding: "1.1rem 2rem",
				position: "relative"
			},
			BASE_CONTENT = {
				display: "flex",
				height: "100%",
				overflow: "hidden",
				width: "100%"
			},
			BASE_CONTENT_TAB = {
				height: "100%",
				overflow: "hidden",
				position: "relative",
				width: "100%"
			},
			BASE_BADGE = {
				height: "0.7rem",
				right: "1.3rem",
				top: "1.3rem",
				width: "0.7rem"
			};
		_this.none = {}, _this.material = {
			element: {
				...BASE_ELEMENT
			},
			header: {
				...BASE_HEADER,
				borderBottom: `1px solid ${DreamColors.instance().gray300}`
			},
			headerWrapper: {
				...BASE_HEADER_CONTENT
			},
			headerTabActive: {
				...BASE_HEADER_TAB,
				color: DreamColors.instance().black
			},
			headerTabInactive: {
				...BASE_HEADER_TAB,
				color: DreamColors.instance().gray500
			},
			headerTabSpacing: {
				marginRight: "2.5rem"
			},
			content: {
				...BASE_CONTENT
			},
			contentTab: {
				...BASE_CONTENT_TAB
			},
			bar: {
				background: DreamColors.instance().blue500,
				border: "none",
				bottom: 0,
				height: "2px",
				position: "absolute !important",
				width: "auto",
				zIndex: 1
			},
			badge: {
				element: {
					...BASE_BADGE
				}
			}
		}, _this.rounded = {
			element: {
				...BASE_ELEMENT
			},
			header: {
				...BASE_HEADER,
				paddingBottom: "2rem"
			},
			headerWrapper: {
				...BASE_HEADER_CONTENT,
				paddingTop: "safari" === Device.system.browser && "2px"
			},
			headerTabActive: {
				...BASE_BORDERED_TAB,
				background: DreamColors.instance().blue500,
				color: `${DreamColors.instance().white}`
			},
			headerTabInactive: {
				...BASE_BORDERED_TAB,
				background: "transparent",
				color: DreamColors.instance().blue500
			},
			headerTabSpacing: {
				marginRight: "1.2rem"
			},
			content: {
				...BASE_CONTENT
			},
			contentTab: {
				...BASE_CONTENT_TAB
			},
			bar: {
				display: "none"
			},
			badge: {
				element: {
					...BASE_BADGE
				}
			}
		}, _this.flag("isReady", !0)
	}(), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function AVSettingsPanel({
	audioOnly: audioOnly = !1,
	headerComponent: headerComponent = DreamUI.AVSettingsHeader,
	footerComponent: footerComponent = DreamUI.AVSettingsFooter,
	audioTabComponent: audioTabComponent = DreamUI.AVSettingsAudio,
	videoTabComponent: videoTabComponent = DreamUI.AVSettingsVideo
}) {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		$this = _this.element;
	!async function() {
		await DreamUI.AVSettingsPanelStyles.ready(),
			function initHTML() {
				$this.goob(_this.combineStyles([DreamUI.AVSettingsPanelStyles.container]))
			}(),
			function initHeader() {
				_this.header = _this.initClass(headerComponent)
			}(), async function initTabs() {
					const tabs = [{
						view: audioTabComponent,
						label: "Audio"
					}];
					audioOnly || tabs.push({
						view: videoTabComponent,
						label: "Video"
					});
					_this.tabs = await _this.initClass(DreamUI.Tab, {
						preset: DreamUI.AVSettingsPanelStyles.tabPreset,
						styles: _this.combineStyles([DreamUI.AVSettingsPanelStyles.tabStyles]),
						tabs: tabs
					})
				}(),
				function initFooter() {
					_this.footer = _this.initClass(footerComponent)
				}()
	}()
})), Namespace("DreamUI"), DreamUI.Class((function AVSettingsPanelStyles() {
	Inherit(this, Component);
	const _this = this;
	_this.container = {
		width: "440px",
		background: DreamColors.instance().white,
		borderRadius: "8px",
		position: "relative",
		padding: "3rem",
		boxShadow: "0 2px 12px rgba(0,0,0,0.3)"
	}, _this.tabPreset = "rounded", _this.tabStyles = {
		element: {},
		header: {
			padding: "2.8rem 0 4rem"
		}
	}, _this.flag("isReady", !0), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function AVSettingsTabBase() {
	Inherit(this, DreamUI.DreamElement);
	const _this = this;
	_this.element.goob({
		width: "100%"
	}), _this.getOptionId = opt => opt._id ? opt._id : opt.deviceId, _this.formatOptionsForDreamUISelect = options => options.map((option => ({
		text: option._name || option.label,
		value: _this.getOptionId(option)
	}))), _this.getMatchingOptionOnSelectChange = (options, value) => options.find((option => _this.getOptionId(option) === value)), _this.createDropdown = async (id, streamOptions, gameCenterCb) => {
		const options = _this.formatOptionsForDreamUISelect(streamOptions),
			selectedOption = streamOptions.find((o => o.selected)),
			select = _this.initClass(DreamUI.Select, {
				id: id,
				options: options,
				styles: DreamUI.AVSettingsTabBaseStyles.selectStyles,
				icon: DreamUI.AVSettingsTabBaseStyles.selectIcon,
				value: selectedOption && _this.getOptionId(selectedOption)
			});
		return _this.events.sub(select, DreamUI.Select.CHANGE, (({
			value: value
		}) => {
			const match = _this.getMatchingOptionOnSelectChange(streamOptions, value);
			match && gameCenterCb(match)
		})), select
	}
})), Namespace("DreamUI"), DreamUI.Class((function AVSettingsTabBaseStyles() {
	Inherit(this, Component);
	const _this = this;
	!async function() {
		await DreamStyleguide.instance().ready(), _this.section = {
			marginBottom: "40px"
		}, _this.enableVideoMessage = {
			...DreamStyleguide.instance().p1
		}, _this.selectStyles = {
			".input": {
				height: "4.6rem",
				border: `solid 1px ${DreamColors.instance().gray300}`,
				paddingLeft: "20px",
				borderRadius: "40px",
				background: DreamColors.instance().white,
				"&.is-selected, &.is-unselected": {
					color: DreamColors.instance().gray800
				}
			},
			svg: {
				width: "2rem",
				height: "2rem",
				right: "1.5rem",
				color: DreamColors.instance().blue
			}
		}, _this.selectIcon = "chevron-bottom", _this.flag("isReady", !0)
	}(), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function AVSettingsAudio({
	styles: styles = {}
}) {
	Inherit(this, DreamUI.AVSettingsTabBase);
	const _this = this,
		$this = _this.element,
		_iconPrefix = Config.ICON_PREFIX ? Config.ICON_PREFIX : "core";
	!async function() {
		await DreamUI.AVSettingsTabBaseStyles.ready(), async function createMicSection() {
			_this.micSection = $this.create(_this.getPrefix("mic-section")).goob(_this.combineStyles([DreamUI.AVSettingsTabBaseStyles.section, styles.section])), _this.micSectionHeader = _this.initClass(DreamUI.AVSettingsSectionHeader, {
				label: "Microphone",
				icon: `${_iconPrefix}-av-microphone`,
				actionView: DreamUI.AVAudioBars
			}, [_this.micSection]);
			const streamOptions = await GameCenterMedia.userStream.getAudioInputs();
			_this.micSectionSelect = await _this.createDropdown("mic-select", streamOptions, GameCenterMedia.userStream.setAudioSource), _this.micSection.add(_this.micSectionSelect)
		}()
	}()
})), Namespace("DreamUI"), DreamUI.Class((function AVAudioBars({
	styles: styles = {}
}) {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		$this = _this.element;
	var _audioContext, _analyser, _dataArray, $bars = [];
	async function initAnalyser() {
		const AudioContext = window.AudioContext || window.webkitAudioContext;
		if (AudioContext) {
			_audioContext = new AudioContext, (_analyser = _audioContext.createAnalyser()).minDecibels = -70, _analyser.maxDecibels = -10, _analyser.smoothingTimeConstant = .85, _analyser.fftSize = 256;
			const audio = await GameCenterMedia.userStream.getAudioStream();
			if (audio) {
				_audioContext.createMediaStreamSource(audio).connect(_analyser);
				const bufferLength = _analyser.frequencyBinCount;
				_dataArray = new Float32Array(bufferLength)
			}
		}
	}

	function loop() {
		if (_dataArray && _analyser) {
			_analyser.getFloatFrequencyData(_dataArray);
			let value = Math.range(_dataArray[0], -100, -30, .1, 1, !0);
			for (let bar of $bars) bar.css({
				height: 2 * value + "rem"
			})
		}
	}
	async function replaceStream() {
		initAnalyser()
	}!async function() {
		await DreamUI.AVAudioBarsStyles.ready(),
			function initHTML() {
				$this.goob(_this.combineStyles([DreamUI.AVAudioBarsStyles.element, styles.element]));
				let numBars = 3;
				for (let i = 0; i < numBars; i++) {
					let bar = $this.create("DreamUI.AVAudioBars__audio-bar");
					bar.goob(_this.combineStyles([DreamUI.AVAudioBarsStyles.bar, styles.bar])), $bars.push(bar)
				}
			}(), initAnalyser(),
			function addListeners() {
				_this.events.sub(GameCenterMediaUserStream.UPDATE, replaceStream)
			}(), _this.startRender(loop)
	}()
})), Namespace("DreamUI"), DreamUI.Class((function AVAudioBarsStyles() {
	Inherit(this, Component);
	const _this = this;
	!async function() {
		await DreamColors.instance().ready(), _this.element = {
			display: "grid",
			position: "relative",
			gridAutoFlow: "column",
			gridAutoColumns: "min-content",
			gridGap: "3px"
		}, _this.bar = {
			position: "relative",
			borderRadius: "3px",
			height: "2rem",
			width: "2px",
			willChange: "height",
			background: DreamColors.instance().gray800
		}, _this.flag("isReady", !0)
	}(), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function AVSettingsAudioTest() {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		AudioContext = (_this.element, window.AudioContext || window.webkitAudioContext);
	_this.audioContext = new AudioContext, async function initButton() {
		await DreamColors.instance().ready(), await DreamStyleguide.instance().ready(), _this.button = _this.initClass(DreamUI.Button, {
			text: "Test",
			styles: {
				element: {
					padding: 0
				},
				text: {
					...DreamStyleguide.instance().label1,
					color: DreamColors.instance().gray800
				}
			}
		})
	}(), async function audioTestSubscriber() {
		const audioReq = new Request(Assets.getPath("~assets/audio/test.mp3"));
		try {
			const response = await fetch(audioReq),
				buffer = await response.arrayBuffer(),
				decodedData = await _this.audioContext.decodeAudioData(buffer);
			_this.events.sub(_this.button, DreamUI.Button.CLICK, (_ => function handleAudioTest(decodedData) {
				const source = _this.audioContext.createBufferSource();
				source.buffer = decodedData, source.connect(_this.audioContext.destination), source.start()
			}(decodedData)))
		} catch (e) {
			console.error(e)
		}
	}()
})), Namespace("DreamUI"), DreamUI.Class((function AVSettingsSectionHeader({
	styles: styles = {},
	label: label = "Hello",
	icon: icon,
	preset: preset = "rowLayout",
	actionView: actionView
}) {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		$this = _this.element;
	!async function() {
		await DreamUI.AVSettingsSectionHeaderStyles.ready(),
			function initHTML() {
				_this.label = $this.create(_this.getPrefix("label")), _this.label.text(label), _this.actions = $this.create(_this.getPrefix("actions")), icon && (_this.icon = _this.initClass(Sprite, icon, _this.combineStyles([DreamUI.AVSettingsSectionHeaderStyles[preset].icon, styles.icon]), [_this.actions]));
				actionView && _this.initClass(actionView, [_this.actions])
			}(),
			function initStyles() {
				$this.goob(_this.combineStyles([DreamUI.AVSettingsSectionHeaderStyles[preset].element, styles.element])), _this.label.goob(_this.combineStyles([DreamUI.AVSettingsSectionHeaderStyles[preset].label, styles.label])), _this.actions.goob(_this.combineStyles([DreamUI.AVSettingsSectionHeaderStyles[preset].actions, styles.actions]))
			}()
	}()
})), Namespace("DreamUI"), DreamUI.Class((function AVSettingsSectionHeaderStyles() {
	Inherit(this, Component);
	const _this = this;
	!async function() {
		await DreamColors.instance().ready(), _this.rowLayout = {
			element: {
				display: "flex",
				justifyContent: "space-between",
				alignItems: "center",
				marginBottom: "16px"
			},
			label: {
				...DreamStyleguide.instance().label4,
				color: DreamColors.instance().gray800
			},
			actions: {
				display: "flex",
				width: "65px",
				justifyContent: "space-between",
				alignItems: "center"
			},
			icon: {
				width: "24px",
				height: "24px",
				color: DreamColors.instance().blue,
				marginRight: "16px"
			}
		}, _this.columnLayout = {
			..._this.rowLayout,
			element: {
				..._this.rowLayout.element,
				flexDirection: "column",
				marginBottom: "20px"
			},
			actions: {
				width: "auto",
				justifyContent: "center",
				video: {
					transform: "scaleX(-1)"
				}
			},
			label: {
				..._this.rowLayout.label,
				alignSelf: "flex-start"
			}
		}, _this.flag("isReady", !0)
	}(), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function AVSettingsVideo({
	styles: styles = {},
	message: message = "Please enable video to change camera options"
}) {
	Inherit(this, DreamUI.AVSettingsTabBase);
	const _this = this,
		$this = _this.element;
	!async function() {
		if (await DreamUI.AVSettingsTabBaseStyles.ready(), PlayerModel.get("gcmedia_mute_video")) return function showEnableMessage() {
			const msg = $this.create(_this.getPrefix("message"));
			msg.text(message), msg.goob(_this.combineStyles([DreamUI.AVSettingsTabBaseStyles.enableVideoMessage, styles.enableVideoMessage]))
		}();
		!async function createVideoSection() {
			_this.videoSection = $this.create(_this.getPrefix("video-section")), _this.videoSectionHeader = _this.initClass(DreamUI.AVSettingsSectionHeader, {
				label: "Cameras",
				actionView: DreamUI.AVSettingsVideoTest,
				preset: "columnLayout"
			}, [_this.videoSection]);
			const streamOptions = await GameCenterMedia.userStream.getVideoInputs();
			_this.videoSectionSelect = _this.createDropdown("video-select", streamOptions, GameCenterMedia.userStream.setVideoSource), _this.videoSection.add(_this.videoSectionSelect)
		}()
	}()
})), Namespace("DreamUI"), DreamUI.Class((function AVSettingsVideoTest({
	styles: styles = {}
}) {
	Inherit(this, DreamUI.DreamElement, "video");
	const _this = this,
		$this = _this.element;
	!async function() {
		await DreamUI.AVSettingsVideoTestStyles.ready(), async function initVideo() {
			$this.goob(_this.combineStyles([DreamUI.AVSettingsVideoTestStyles.element, styles.element])), $this.attr("autoplay", "true");
			let stream = await GameCenterMedia.userStream.getStream();
			stream && ($this.div.srcObject = stream.srcObject, $this.div.play(), $this.div.volume = .001)
		}()
	}()
})), Namespace("DreamUI"), DreamUI.Class((function AVSettingsVideoTestStyles() {
	Inherit(this, Component);
	const _this = this;
	_this.element = {
		background: "black",
		height: "120px",
		width: "120px",
		objectFit: "cover",
		position: "relative"
	}, _this.flag("isReady", !0), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function AVSettingsFooter({
	styles: styles = {},
	buttonConfig: buttonConfig = {}
} = {}) {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		$this = _this.element;
	!async function() {
		await DreamUI.AVSettingsFooterStyles.ready(), $this.goob(_this.combineStyles([DreamUI.AVSettingsFooterStyles.element, styles.element])),
			function initButton() {
				_this.saveButton = _this.initClass(DreamUI.Button, function getButtonConfig() {
					return {
						preset: "flat",
						text: "Save",
						...buttonConfig,
						styles: _this.combineStyles([DreamUI.AVSettingsFooterStyles.buttonStyles, buttonConfig.styles])
					}
				}()), _this.events.sub(_this.saveButton, DreamUI.Button.CLICK, (_ => DreamUI.Modal.instance().close()))
			}()
	}()
})), Namespace("DreamUI"), DreamUI.Class((function AVSettingsFooterStyles() {
	Inherit(this, Component);
	const _this = this;
	!async function() {
		await DreamColors.instance().ready(), _this.element = {
			paddingTop: "2rem"
		}, _this.buttonStyles = {
			element: {
				width: "100%",
				justifyContent: "center",
				height: "48px",
				borderRadius: "50px",
				background: DreamColors.instance().blue
			}
		}, _this.flag("isReady", !0)
	}(), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function AVSettingsHeader({
	styles: styles = {},
	buttonConfig: buttonConfig = {}
} = {}) {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		$this = _this.element;
	!async function() {
		await DreamUI.AVSettingsHeaderStyles.ready(),
			function initHeading() {
				_this.heading = $this.create(_this.getPrefix("heading")).text("Settings")
			}(),
			function initButton() {
				_this.closeButton = _this.initClass(DreamUI.Button, function getButtonConfig() {
					return {
						preset: "icon",
						text: "close",
						icon: Config.ICON_PREFIX ? `${Config.ICON_PREFIX}-close` : "core-close",
						...buttonConfig,
						styles: _this.combineStyles([DreamUI.AVSettingsHeaderStyles.buttonStyles, buttonConfig.styles])
					}
				}()), _this.events.sub(_this.closeButton, DreamUI.Button.CLICK, (_ => DreamUI.Modal.instance().close()))
			}(),
			function initStyles() {
				$this.goob(_this.combineStyles([DreamUI.AVSettingsHeaderStyles.element, styles.element])), _this.heading.goob(_this.combineStyles([DreamUI.AVSettingsHeaderStyles.heading, styles.heading]))
			}()
	}()
})), Namespace("DreamUI"), DreamUI.Class((function AVSettingsHeaderStyles() {
	Inherit(this, Component);
	const _this = this;
	!async function() {
		await DreamColors.instance().ready(), await DreamStyleguide.instance().ready(), _this.element = {
			display: "flex",
			justifyContent: "space-between",
			alignItems: "center"
		}, _this.heading = {
			...DreamStyleguide.instance().h3,
			fontWeight: "bold",
			color: DreamColors.instance().gray800
		}, _this.buttonStyles = {
			element: {
				border: `2px solid ${DreamColors.instance().gray500}`,
				color: DreamColors.instance().gray500
			}
		}, _this.flag("isReady", !0)
	}(), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function Modal({
	animations: animations = DreamUI.ModalAnimations,
	styles: styles = {}
} = {}) {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		$this = _this.element;
	let _isFocused;

	function keyDown(e) {
		let isTabPressed = "Tab" === e.key || 9 === e.keyCode;
		_this.flag("isOpen") && isTabPressed && (_isFocused ? (_this.currentlyFocused = e.srcElement, _this.currentlyFocused === _this.lastFocusableElement && focusFirstElement(e)) : !_isFocused && _this.firstFocusableElement && (_isFocused = !0, focusFirstElement(e)))
	}

	function focusFirstElement(e) {
		_this.firstFocusableElement.focus(), e.preventDefault(), _this.currentlyFocused = _this.firstFocusableElement
	}!async function() {
		await DreamUI.ModalStyles.ready(),
			function initGlobalStyles() {
				goober.glob`
            .Modal * { position: relative }
        `
			}(),
			function initElement() {
				$this.goob(_this.combineStyles([DreamUI.ModalStyles.element, styles.element]))
			}(),
			function initClose() {
				_this.closeBackground = $this.create(_this.getPrefix("close")), _this.closeBackground.goob(_this.combineStyles([DreamUI.ModalStyles.closeBackground, styles.closeBackground])), _this.closeBackground.interact(null, _this.close)
			}(),
			function initWrapper() {
				_this.wrapper = $this.create(_this.getPrefix("wrapper")), _this.wrapper.goob(_this.combineStyles([DreamUI.ModalStyles.wrapper, styles.wrapper]))
			}(), Stage.add($this), _this.flag("isReady", !0)
	}(), _this.open = async function(Class, {
		closeOnClickOutside: closeOnClickOutside = !0,
		options: options = {}
	} = {}) {
		let wasOpen;
		return await _this.wait("isReady"),
			function addListeners() {
				_this.events.sub(Keyboard.DOWN, keyDown)
			}(), _this.events.fire(DreamUI.Modal.OPENING), _this.flag("isOpen") && (wasOpen = !0, await _this.closeContent()), _this.flag("isOpen", !0), $this.div.classList.add("prevent_interaction3d"), $this.div.classList.add("prevent_interactionScroll"), closeOnClickOutside ? _this.closeBackground.visible() : _this.closeBackground.invisible(), _this.modal = _this.initClass(Class, options, [_this.wrapper]),
			function getFocusable() {
				_this.delayedCall((() => {
					_this.focusableContent = _this.modal?.element?.div.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'), _this.firstFocusableElement = _this.focusableContent?.[0], _this.lastFocusableElement = _this.focusableContent?.[_this.focusableContent?.length - 1]
				}), 200)
			}(), wasOpen || animations.animateIn(_this), animations.animateIn(_this.modal), _this.modal
	}, _this.close = async function() {
		await _this.wait("isReady"), _this.modal && (! function removeListeners() {
			_this.events.unsub(Keyboard.DOWN, keyDown)
		}(), _this.flag("isOpen", !1), _isFocused = !1, $this.div.classList.remove("prevent_interaction3d"), $this.div.classList.remove("prevent_interactionScroll"), await animations.animateOut(_this), _this.closeBackground.invisible(), _this.events.fire(DreamUI.Modal.CLOSED, {
			modal: _this.modal
		}), _this.modal.destroy(), _this.modal = null)
	}, _this.closeContent = async function() {
		await _this.wait("isReady"), await animations.animateOut(_this.modal), _this.modal.destroy(), _this.modal = null
	}
}), "singleton", (_ => {
	DreamUI.Modal.CLOSED = "DreamUI_Modal_Closed", DreamUI.Modal.OPENING = "DreamUI_Modal_Opening"
})), Namespace("DreamUI"), DreamUI.Class((function ModalAnimations() {
	Inherit(this, Component), this.onCloseHover = function({
		action: action
	}, close) {
		switch (action) {
			case "over":
				close.element.tween({
					opacity: .5
				}, 400, "easeOutCubic");
				break;
			case "out":
				close.element.tween({
					opacity: 1
				}, 400, "easeOutCubic")
		}
	}, this.onCloseClick = function(event, close) {
		close.element.tween({
			opacity: 1
		}, 400, "easeOutCubic")
	}, this.animateIn = function(modal) {
		return modal.element.visible().css({
			opacity: 0
		}).tween({
			opacity: 1
		}, 400, "easeOutCubic").promise()
	}, this.animateOut = function(modal) {
		return modal.element.tween({
			opacity: 0
		}, 400, "easeOutCubic", (_ => {
			modal.element.invisible()
		})).promise()
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function ModalStyles() {
	Inherit(this, Component);
	const _this = this;
	!async function() {
		await DreamColors.instance().ready(), _this.element = {
			background: "rgba(0, 0, 0, 0.8)",
			height: "100%",
			opacity: 0,
			overflow: "auto",
			position: "absolute  !important",
			top: 0,
			visibility: "hidden",
			width: "100%",
			zIndex: 1e4
		}, _this.closeBackground = {
			height: "100%",
			left: 0,
			position: "absolute !important",
			top: 0,
			visibility: "hidden",
			width: "100%"
		}, _this.wrapper = {
			left: "50%",
			position: "absolute !important",
			top: "50%",
			transform: "translate(-50%, -50%)",
			zIndex: 1e5
		}, _this.flag("isReady", !0)
	}(), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function VideoChatZones({
	animations: animations = DreamUI.VideoChatZoneAnimations,
	audioOnly: audioOnly = !1,
	styles: styles = DreamUI.VideoChatZoneStyles
} = {}) {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		$this = _this.element;
	var _video, _startTime;

	function resize() {
		$this.css({
			height: Stage.height,
			width: Stage.width
		})
	}!async function() {
		await styles.ready(),
			function initElement() {
				$this.goob(styles.element), _this.wrapper = $this.create(_this.getPrefix("wrapper")), _this.wrapper.goob(styles.wrapper)
			}(),
			function initPreview() {
				audioOnly || (_this.video = _this.initClass(DreamUI.VideoChatZoneVideo, {
					animations: animations,
					styles: styles
				}, [_this.wrapper]))
			}(),
			function initSettings() {
				_this.settings = _this.initClass(DreamUI.VideoChatZoneSettings, {
					audioOnly: audioOnly,
					animations: animations,
					styles: styles
				}, [_this.wrapper])
			}(),
			function addListeners() {
				_this.onResize(resize)
			}()
	}(), this.connect = async function() {
		Track.event("chatzone", "start"), _startTime = Date.now(), _video = await GameCenterMedia.getUserVideo(!0), _this.video?.updateVideo(_video), $this && $this.css && $this.css({
			opacity: 1,
			display: "block"
		})
	}, this.disconnect = function() {
		let timeElapsed = function determineTimeElapsed(startTime) {
			let timeDiff = Date.now() - startTime;
			timeDiff /= 1e3;
			const seconds = Math.round(timeDiff);
			return parseFloat(seconds / 60).toFixed(2)
		}(_startTime);
		Track.event("chatzone", "end", null, timeElapsed), $this && $this.css && $this.css({
			opacity: 0,
			display: "none"
		})
	}
})), Namespace("DreamUI"), DreamUI.Class((function VideoChatZoneAnimations() {
	Inherit(this, Component), this.onButtonHover = function({
		action: action
	}, button) {
		switch (action) {
			case "over":
				button.element.tween({
					opacity: .5
				}, 400, "easeOutCubic");
				break;
			case "out":
				button.element.tween({
					opacity: 1
				}, 400, "easeOutCubic")
		}
	}, this.onButtonClick = function(event, button) {
		button.element.tween({
			opacity: 1
		}, 400, "easeOutCubic")
	}, this.onButtonDeactive = function(event, button) {
		button.element.tween({
			color: DreamColors.instance().red
		}, 400, "easeOutCubic")
	}, this.onButtonActive = function(event, button) {
		button.element.tween({
			color: DreamColors.instance().white
		}, 400, "easeOutCubic")
	}, this.animateVideoIn = function(video) {
		video.tween({
			opacity: 1,
			scaleX: -1,
			x: "-50%",
			y: "-50%"
		}, 10, "easeInOut")
	}, this.animateVideoOut = function(video) {
		video.tween({
			opacity: 0,
			scaleX: -1,
			x: "-50%",
			y: "-50%"
		}, 10, "easeInOut")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function VideoChatZoneButton({
	animations: animations,
	icon: icon,
	onClick: onClick = (_ => {}),
	styles: styles,
	label: label
} = {}) {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		$this = _this.element;

	function handleHover(event) {
		animations.onButtonHover(event, _this)
	}

	function handleClick(event) {
		animations.onButtonClick(event, _this), onClick()
	}
	_this.label = label,
		function initElement() {
			$this.goob(styles.element), $this.interact(handleHover, handleClick), $this.attr("role", "button"), $this.attr("aria-label", _this.label), DreamUI.AccessibilityService.instance().enableTabNavigation($this, (event => handleClick(event)))
		}(),
		function initIcon() {
			_this.icon = _this.initClass(Sprite, icon), _this.icon.element.goob(styles.icon)
		}(), _this.setLabel = _label => {
			_this.label = _label, $this.attr("aria-label", _this.label)
		}
})), Namespace("DreamUI"), DreamUI.Class((function VideoChatZoneSettings({
	audioOnly: audioOnly = !1,
	animations: animations,
	styles: styles
} = {}) {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		$this = _this.element,
		_iconPrefix = Config.ICON_PREFIX ? Config.ICON_PREFIX : "core";

	function getAudioLabel() {
		return _this.audioEnabled ? "turn audio off" : "turn audio on"
	}

	function getVideoLabel() {
		return _this.videoEnabled ? "turn video off" : "turn video on"
	}
	async function handleAudioToggle() {
		_this.audioEnabled ? (animations.onButtonDeactive(null, _this.audio), Track.event("settings", "disable_av_audio"), await GameCenterMedia.userStream.disableAudio()) : (animations.onButtonActive(null, _this.audio), Track.event("settings", "enable_av_audio"), await GameCenterMedia.userStream.enableAudio()), _this.audioEnabled = !_this.audioEnabled, AVSettingsController.instance().audioEnabled = _this.audioEnabled, _this.audio?.setLabel(getAudioLabel())
	}
	async function handleVideoToggle() {
		_this.videoEnabled ? (animations.onButtonDeactive(null, _this.video), Track.event("settings", "disable_av_video"), await GameCenterMedia.userStream.disableVideo()) : (animations.onButtonActive(null, _this.video), Track.event("settings", "enable_av_video"), await GameCenterMedia.userStream.enableVideo()), _this.videoEnabled = !_this.videoEnabled, AVSettingsController.instance().videoEnabled = _this.videoEnabled, _this.video?.setLabel(getVideoLabel())
	}

	function handleSettings() {
		DreamUI.Modal.instance().open(DreamUI.AVSettingsPanel, {
			options: {
				audioOnly: audioOnly
			}
		})
	}!async function() {
		await styles.ready(),
			function initElement() {
				$this.goob(styles.settings)
			}(), async function initAudioVideo() {
				_this.controls = $this.create(`${_this.constructorName}__av-wrapper`), _this.controls.goob(styles.settingsControls), _this.audioEnabled = AVSettingsController.instance().audioEnabled, _this.audio = _this.initClass(DreamUI.VideoChatZoneButton, {
					animations: animations,
					icon: `${_iconPrefix}chat-zones-microphone`,
					onClick: handleAudioToggle,
					styles: styles.settingsButton,
					label: getAudioLabel()
				}, [_this.controls]), _this.audioEnabled || animations.onButtonDeactive(null, _this.audio);
				audioOnly || (_this.videoEnabled = AVSettingsController.instance().videoEnabled, _this.video = _this.initClass(DreamUI.VideoChatZoneButton, {
					animations: animations,
					icon: `${_iconPrefix}chat-zones-camera`,
					onClick: handleVideoToggle,
					styles: styles.settingsButton,
					label: getVideoLabel()
				}, [_this.controls]), _this.videoEnabled || animations.onButtonDeactive(null, _this.video));
				_this.settings = _this.initClass(DreamUI.VideoChatZoneButton, {
					animations: animations,
					icon: `${_iconPrefix}chat-zones-settings`,
					onClick: handleSettings,
					styles: styles.settingsButtonCog,
					label: "open settings"
				})
			}()
	}()
})), Namespace("DreamUI"), DreamUI.Class((function VideoChatZoneStyles() {
	Inherit(this, Component);
	const _this = this;
	!async function() {
		await DreamColors.instance().ready(), _this.element = {
			opacity: 0,
			display: "none",
			width: "100%",
			height: "100%"
		}, _this.wrapper = {
			alignItems: "center",
			bottom: "4rem",
			display: "flex",
			flexDirection: "column",
			justifyContent: "center",
			pointerEvents: "auto",
			width: "100%"
		}, _this.video = {
			background: "#000",
			border: "2px solid white",
			borderRadius: "50%",
			height: "10rem",
			marginBottom: "2rem",
			overflow: "hidden",
			position: "relative !important",
			width: "10rem",
			transform: "translateZ(0) scaleX(-1)"
		}, _this.videoAvatar = {
			height: "100%",
			left: "50%",
			objectFit: "cover",
			top: "50%",
			transform: "translate(-50%, -50%)",
			width: "100%"
		}, _this.videoMedia = {
			borderRadius: "50%",
			left: "50%",
			top: "50%",
			height: "10rem",
			transform: "translate(-50%, -50%) scaleX(-1)",
			width: "15rem"
		}, _this.settings = {
			alignItems: "center",
			display: "flex",
			background: "rgba(0, 0, 0, 0.8)",
			borderRadius: "11.5rem",
			padding: "0.8rem",
			position: "relative !important"
		}, _this.settingsControls = {
			alignItems: "center",
			display: "flex",
			gap: "1rem",
			marginRight: "3rem",
			position: "relative !important"
		}, _this.settingsButton = {
			element: {
				alignItems: "center",
				background: "#333",
				borderRadius: "50%",
				color: "#fff",
				display: "flex",
				height: "5rem",
				justifyContent: "center",
				position: "relative !important",
				width: "5rem"
			},
			icon: {
				height: "2.4rem",
				width: "2.4rem"
			}
		}, _this.settingsButtonCog = {
			element: {
				alignItems: "center",
				background: DreamColors.instance().black,
				borderRadius: "0rem",
				color: DreamColors.instance().white,
				display: "flex",
				height: "7rem",
				justifyContent: "center",
				position: "relative !important",
				width: "7rem"
			},
			icon: {
				height: "4rem",
				width: "4rem"
			}
		}, _this.flag("isReady", !0)
	}(), _this.ready = function() {
		return _this.wait("isReady")
	}
}), "static"), Namespace("DreamUI"), DreamUI.Class((function VideoChatZoneVideo({
	animations: animations,
	styles: styles
} = {}) {
	Inherit(this, DreamUI.DreamElement);
	const _this = this,
		$this = _this.element;
	async function handleStateChange({
		isEnabled: isEnabled
	}) {
		await _this.wait(_this, "video"), isEnabled ? animations.animateVideoIn(_this.video) : animations.animateVideoOut(_this.video)
	}!async function() {
		await styles.ready(),
			function initElement() {
				const path = PlayerModel.get("profileImage") || Assets.getPath("assets/images/avatar/placeholder.png");
				$this.goob(styles.video), _this.avatar = $this.create(_this.getPrefix("avatar"), "img"), _this.avatar.goob(styles.videoAvatar), _this.avatar.attr("src", Assets.getPath(path))
			}(),
			function addHandlers() {
				_this.events.sub(AVSettingsController.VIDEO_STATE_CHANGE, handleStateChange), _this.events.sub(VideoChatZones.DISCONNECTED, (() => {
					_this.video?.destroy?.(), _this.video = null
				}))
			}()
	}(), _this.updateVideo = function(video) {
		video && (_this.video = $(video), _this.video.attr("width", "100%").attr("height", "100%").goob(styles.videoMedia), $this.add(_this.video))
	}
})), Class((function AudioController() {
	Inherit(this, Component), Inherit(this, StateComponent);
	const _this = this,
		SFX = SFXController.instance();
	_this.ready = Promise.create();
	let _canUseFilter = !0,
		_currentHotspotTrack = null,
		_currentHotspotPlaybackSpeed = 1,
		_canRemute = !0;
	!async function() {
		await async function initialize() {
				GlobalAudio3D.setup(), await GlobalAudio3D.ready, await SpaceAudioManager.instance().ready
			}(),
			function addListeners() {
				if (!_canRemute) return;
				_this.events.sub(AudioController.TOGGLE_MUTE, _this.handleToggleMute), _this.bindState(PlayerSettings.instance().state, "audio", (value => {
					_this.events.fire(AudioController.TOGGLE_MUTE, {
						value: !value
					})
				})), _this.events.sub(XRDeviceManager.SESSION_START, (_ => {
					_this.getAllCurrentlyPlayingAudio().forEach((sound => {
						sound.pause(), sound.play()
					}))
				}))
			}(), _this.flag("initialized", !0), _this.ready.resolve(), PortalUtil.isPortal && (_this.events.fire(AudioController.TOGGLE_MUTE, {
				value: !0
			}), _canRemute = !1)
	}(), this.handleToggleMute = async function({
		value: value
	}) {
		GlobalAudio3D.muted = value
	}, this.getAllCurrentlyPlayingAudio = function() {
		let active = [];
		return Object.values(SFX.activeSounds).forEach((activeSounds => {
			activeSounds.length && activeSounds.forEach((s => active.push(s)))
		})), active
	}, this.isAudioLoaded = this.getAudio = function(_name) {
		return SFX.preloaded[_name]
	}, this.getAudioPlaying = function(_name, loop = !1) {
		return SFX.activeSounds[_name]?.[0]
	}, this.registerAudio = async function(_name, _file) {
		await SFX.registerSound(_name, _file), await SFX.preload(_name)
	}, this.play = async function({
		name: name,
		loop: loop = !1,
		timeStamp: timeStamp = 0,
		playbackRate: playbackRate = 1
	}) {
		SFX.play(name, {
			onBeforePlay: sound => {
				sound.loop = loop, sound.seek(timeStamp), sound.autoplay = !0, name.includes("hotspot") && (_currentHotspotTrack = name, sound.playbackRate = _currentHotspotPlaybackSpeed), SpaceAudioManager.SOUNDS.includes(name) && (sound.filter ? (sound.filter.type = "lowpass", sound.filter.frequency.value = 24e3, sound.filter.Q.value = 10) : _canUseFilter = !1)
			}
		})
	}, this.stop = function(name) {
		const sound = _this.getAudio(name);
		sound && (sound.stop(), SFX.activeSounds[name].remove(sound))
	}, this.setPlaybackSpeed = function(speed) {
		if (_currentHotspotPlaybackSpeed = speed, !_currentHotspotTrack) return;
		_this.getAudioPlaying(_currentHotspotTrack).playbackRate = _currentHotspotPlaybackSpeed
	}, this.fadeIn = async function(name, duration = 700, ease = "linear", loop = !1, volume = 1) {
		let sound = _this.getAudioPlaying(name);
		if (sound || (await _this.play({
				name: name,
				loop: loop
			}), sound = _this.getAudioPlaying(name)), sound) return sound.volume = 0, sound.tween({
			volume: volume
		}, duration, ease).promise()
	}, this.fadeOut = async function(name, duration = 700, ease = "linear") {
		let sound = _this.getAudioPlaying(name);
		if (sound) return _this.delayedCall((() => {
			_this.stop(name)
		}), duration), sound.tween({
			volume: 0
		}, duration, ease).promise()
	}, this.fadeFilter = async function(name, value, duration = 1200, ease = "linear") {
		let sound = _this.getAudioPlaying(name);
		if (sound) return _this.delayedCall((() => {
			sound.filter.frequency = value
		}), duration), tween(sound.filter.frequency, {
			value: value
		}, duration, ease)
	}, this.fadeToVolume = async function(name, volume, duration = 700, ease = "linear") {
		let sound = _this.getAudioPlaying(name);
		if (sound) return sound.tween({
			volume: volume
		}, duration, ease).promise()
	}, this.get("canUseFilter", (_ => _canUseFilter)), this.get("hotspotPlaybackSpeed", (_ => _currentHotspotPlaybackSpeed))
}), "singleton", (_ => {
	AudioController.TOGGLE_MUTE = "AudioController.TOGGLE_MUTE"
})), Class((function RandAttributes(_mesh, _shader, _group, _input) {
	const seedRandom = require("SeedRandom");
	!async function() {
		let geom, seeded = !1;
		if (_shader instanceof Shader) {
			let config = InputUIL.create(`${_input.prefix}ra`, _group);
			config.setLabel("Random Value"), config.addToggle("seeded"), seeded = config.get("seeded"), await _mesh.instanceMeshReady, geom = _mesh.instanceMesh.geometry
		} else seeded = _shader, geom = _mesh.geometry || _mesh.geom;
		let random = seeded ? seedRandom : Math.random,
			count = geom.attributes.offset.count,
			buffer = new Float32Array(1 * count);
		for (let i = 0; i < count; i++) buffer[4 * i + 0] = random(0, 1, 4);
		geom.addAttribute("rand", new GeometryAttribute(buffer, 1, 1))
	}()
})), Class((function RoomCulling() {
	Inherit(this, Component), Inherit(this, StateComponent);
	const _this = this;
	let _env;
	_this.list = [];
	let _enabled = Tests.roomCulling();

	function renderIf(obj, array) {
		if (!obj.visible) return;
		let item = {
			obj: obj,
			array: array
		};
		_this.list.push(item), checkItem(item)
	}

	function checkItem(item) {
		const room = RoomsStore.get("currentRoom");
		if (item?.obj) {
			if (item.obj.disableCulling) return;
			item.obj.visible = item.array.includes(room)
		} else console.log("cannot find item", item)
	}

	function onRoomChange() {
		_this.list.forEach((item => checkItem(item)))
	}
	this.start = function start(env) {
		_env = env, async function testVisibility() {
			const layers = await _env.layout.getAllLayers();
			Tests.renderGardenLeaves() || (layers.leaves.mesh.visible = !1, layers.leaves.visible = !1, layers.leaves.antimatter.stopRender());
			Tests.grassDensity() <= 0 && (layers.grass.instanceMesh.visible = !1, layers.grass.instanceMesh.disableCulling = !0)
		}(), Global.PLAYGROUND || _enabled && (!async function trackMesh() {
			const layers = await _env.layout.getAllLayers();
			layers.sun.visible = Tests.avatarShadow();
			const FROM_ROTUNDA = [RoomsStore.ROTUNDA, RoomsStore.OUTSIDE, RoomsStore.BRIDGE, RoomsStore.GALAXY],
				FROM_OUTSIDE = [RoomsStore.OUTSIDE, RoomsStore.BRIDGE, RoomsStore.GALAXY];
			renderIf(layers.A_lobby, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA]), renderIf(layers.A_lobby_floor, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA]), renderIf(layers.A_lobby_curtains, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA]), renderIf(layers.B_museum, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA, RoomsStore.OUTSIDE]), renderIf(layers.B_museum_floor, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA, RoomsStore.OUTSIDE]), renderIf(layers.C_octagon_walls, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA, RoomsStore.OUTSIDE, RoomsStore.BRIDGE]), renderIf(layers.C_octagon_floors, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA, RoomsStore.OUTSIDE]), renderIf(layers.C_octagon_cushions, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA]), renderIf(layers.E_island, FROM_ROTUNDA), renderIf(layers.F_end, FROM_ROTUNDA), renderIf(layers.tree_foliage, FROM_ROTUNDA), renderIf(layers.tree_leaves.instanceMesh, FROM_ROTUNDA), renderIf(layers.grass.instanceMesh, FROM_ROTUNDA), renderIf(layers.water, FROM_OUTSIDE), renderIf(layers.birds, FROM_ROTUNDA), renderIf(layers.birds2, FROM_ROTUNDA), renderIf(layers.light_shafts, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA, RoomsStore.OUTSIDE]), renderIf(layers.kinetic, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA, RoomsStore.OUTSIDE]), renderIf(layers.space_dome, FROM_ROTUNDA), renderIf(layers.portal_field, FROM_ROTUNDA), renderIf(layers.leaves, FROM_ROTUNDA), renderIf(layers.frostedGlass, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA]), renderIf(layers.DREAM_PORTAL, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA]), renderIf(layers.waterfall_inside, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA, RoomsStore.OUTSIDE])
		}(), _this.bindState(RoomsStore, "currentRoom", onRoomChange))
	}, this.renderIf = renderIf, this.forceUpdate = _ => {
		_this.list.forEach((item => checkItem(item)))
	}, this.trackHotspots = async function(manager) {
		if (!_enabled) return;
		const hotspots = manager.hotspots,
			waits = [];
		hotspots.forEach((h => waits.push(h.ready()))), await Promise.all(waits);
		const getSpot = id => hotspots.filter((h => h.id === id))[0];
		["hotspot1", "hotspot2", "hotspot3", "hotspot4", "hotspot5", "hotspot6", "hotspot7", "hotspot8"].forEach((h => {
			renderIf(getSpot(h).artwork, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA, RoomsStore.OUTSIDE]), renderIf(getSpot(h).layers.artwork, [RoomsStore.FIRST_ROOM, RoomsStore.SECOND_ROOM, RoomsStore.ROTUNDA, RoomsStore.OUTSIDE])
		})), ["hotspot9", "hotspot10", "hotspot11", "hotspot12", "hotspot13", "hotspot14", "hotspot15", "hotspot16"].forEach((h => {
			renderIf(getSpot(h).artwork, [RoomsStore.ROTUNDA, RoomsStore.OUTSIDE, RoomsStore.BRIDGE, RoomsStore.GALAXY]), renderIf(getSpot(h).layers.artwork, [RoomsStore.ROTUNDA, RoomsStore.OUTSIDE, RoomsStore.BRIDGE, RoomsStore.GALAXY])
		}))
	}
}), "static"), Class((function SpaceAudioManager() {
	Inherit(this, Component);
	const _this = this,
		PATH = "assets/audio/audio_",
		AC = AudioController.instance();
	let _currentAudio;
	_this.ready = Promise.create();
	const _audio = {
		intro: null,
		gallery: null,
		outdoor: null,
		galaxy: null
	};
	let _isTeleporting = !1,
		_isIntroPlaying = !1,
		_initialized = !1;

	function handleIntro() {
		_isIntroPlaying && _audio.intro && _audio.intro.duration - _audio.intro.currentTime <= 0 && function handleIntroComplete() {
			AC.fadeOut("intro", 1e3, "easeOutQuad"), AC.fadeToVolume(_currentAudio, SpaceAudioManager.BACKGROUND_VOLUME, 1e3, "easeInCubic", 1e3), _isIntroPlaying = !1, _this.stopRender(handleIntro)
		}()
	}

	function onChatZoneConnect() {
		_isIntroPlaying && _this.stopIntro(), AC.fadeOut(_currentAudio, 400, "easeOutQuad")
	}

	function onChatZoneDisconnect() {
		AC.fadeIn(_currentAudio, 1e3, "easeInCubic", !0, SpaceAudioManager.BACKGROUND_VOLUME)
	}
	async function handleTeleport(_id) {
		if (!_id) return;
		_isTeleporting = !0;
		const numeric = parseInt(_id.match(/\d+/)[0]);
		"gallery" === _currentAudio && numeric >= 9 && await manualTransitionInHotSpot("gallery", "outdoor"), "outdoor" === _currentAudio && numeric <= 8 && await manualTransitionInHotSpot("outdoor", "gallery"), _isTeleporting = !1
	}
	async function onHotSpotActive(isActive) {
		(Utils.query("spawnDebug") || isActive || _this.flag("initial")) && (_isTeleporting || (! function fadeHotSpot(bool) {
			bool ? (AC.canUseFilter && AC.fadeFilter(_currentAudio, SpaceAudioManager.FREQUENCY_SWEEPED, 600, "linear"), AC.fadeToVolume(_currentAudio, SpaceAudioManager.HOTSPOT_VOLUME, 1e3, "easeInCubic", 1e3)) : (AC.fadeToVolume(_currentAudio, SpaceAudioManager.BACKGROUND_VOLUME, 1e3, "easeInCubic"), AC.canUseFilter && AC.fadeFilter(_currentAudio, SpaceAudioManager.FREQUENCY_FULL, 1700, "linear", 500))
		}(isActive), _this.flag("initial", !0)))
	}
	async function manualTransitionInHotSpot(curr, next) {
		await AC.fadeOut(curr, 300, "easeOutCubic"), _this.setCurrentAudio(next), await AC.fadeIn(next, 300, "easeOutCubic", !0, SpaceAudioManager.HOTSPOT_VOLUME)
	}!async function() {
		await async function init() {
				if (PortalUtil.isPortal) return void _this.ready.resolve();
				await async function preLoadAudio() {
					await AppCMSConfig.ready(), await GlobalAudio3D.ready;
					const promises = [AC.registerAudio("intro", LandingText?.data?.voiceover?.audio?.asset?.url), ...SpaceAudioManager.SOUNDS.map((sound => AC.registerAudio(sound, Assets.getPath(`${PATH}${sound}.mp3`))))];
					return Promise.all(promises)
				}(), _audio.intro = AC.getAudio("intro"), _audio.gallery = AC.getAudio("gallery"), _audio.outdoor = AC.getAudio("outdoor"), _audio.galaxy = AC.getAudio("galaxy"), _audio.outdoor.volume = 0, _audio.galaxy.volume = 0, _currentAudio = "gallery", (Utils.query("spawnDebug") || Utils.query("skip")) && await AC.fadeIn(_currentAudio, 1e3, "easeOutQuad", !0, SpaceAudioManager.BACKGROUND_VOLUME);
				Utils.query("spawnDebug") && await handleTeleport(Utils.query("spawnDebug"));
				_this.flag("initialized", !0), _this.startRender(handleIntro)
			}(),
			function addHandlers() {
				if (PortalUtil.isPortal) return;
				_this.bindState(HotSpotStore, "active", onHotSpotActive), _this.events.sub(HotSpotManager.TELEPORT, handleTeleport), _this.events.sub(LoaderView.ANIMATING_OUT, _this.initializeAudio), _this.events.sub(LandingUIEnter.CLICK, _this.initializeAudio), _this.events.sub(VideoChatZones.CONNECTED, onChatZoneConnect), _this.events.sub(VideoChatZones.DISCONNECTED, onChatZoneDisconnect)
			}(), _this.ready.resolve(), _this.flag("initial", !1)
	}(), this.initializeAudio = async function() {
		await _this.wait("initialized"), _initialized || (_initialized = !0, _isIntroPlaying = !0, await AC.fadeIn("intro", 1e3, "easeOutQuad", !1, 1), await AC.fadeIn(_currentAudio, 1e3, "easeOutQuad", !0, SpaceAudioManager.HOTSPOT_VOLUME))
	}, this.updateTransition = function(dist, from, to) {
		if (PortalUtil.isPortal || !_this.flag("initialized") || _isTeleporting || !_audio[from] || !_audio[to]) return;
		if (dist >= 1) return _this.setCurrentAudio(to);
		if (dist <= 0) return _this.setCurrentAudio(from);
		_isIntroPlaying && _this.stopIntro();
		AC.getAudioPlaying(to) || AC.play({
			name: to,
			loop: !0
		}), _audio[from].volume = SpaceAudioManager.BACKGROUND_VOLUME - dist, _audio[to].volume = Math.min(dist, SpaceAudioManager.BACKGROUND_VOLUME)
	}, this.setCurrentAudio = function(audio) {
		audio !== _currentAudio && (_currentAudio = audio)
	}, this.stopIntro = function() {
		AC.fadeOut("intro", 400, "easeOutQuad"), AC.stop("intro"), SFXController.instance().preloaded.intro = null, _isIntroPlaying = !1, _this.stopRender(handleIntro)
	}, this.get("currentAudio", (_ => _currentAudio)), this.get("isIntroPlaying", (_ => _isIntroPlaying))
}), "singleton", (_ => {
	SpaceAudioManager.BACKGROUND_VOLUME = .6, SpaceAudioManager.HOTSPOT_VOLUME = .1, SpaceAudioManager.SOUNDS = ["gallery", "outdoor", "galaxy"], SpaceAudioManager.FREQUENCY_FULL = 24e3, SpaceAudioManager.FREQUENCY_SWEEPED = 200
})), Class((function TrackAnalytics() {
	Inherit(this, Component);
	const _this = this;

	function onChatZoneConnect() {
		window.gtag && gtag("event", "join_group", {
			group_id: "1on1Chat"
		})
	}! function addListeners() {
		_this.events.sub(VideoChatZones.CONNECTED, onChatZoneConnect)
	}(), this.track = function track(event, data) {
		if (Hydra.LOCAL && console.log("Track analytics", event, data), window.gtag) switch (event) {
			case "HotspotEnter":
				gtag("event", "level_start", {
					level_name: data
				});
				break;
			case "HotspotLeave":
				gtag("event", "level_end", {
					level_name: data
				});
				break;
			case "LandingClicked":
				gtag("event", "login", {
					method: "LandingClicked"
				});
				break;
			case "tutorialStart":
				gtag("event", "tutorial_begin");
				break;
			case "tutorialEnd":
				gtag("event", "tutorial_complete");
				break;
			default:
				gtag("event", "select_content", {
					content_type: event,
					item_id: data
				})
		}
	}
}), "static"), Class((function VoiceChatController() {
	Inherit(this, Component);
	const _this = this;
	AudioController.instance();
	let _connecting = !1,
		_connected = !1,
		_disconnecting = !1,
		_muted = !0,
		_id = null;
	async function muteSelf(bool) {
		GameCenterMedia.userStream && (bool ? GameCenterMedia.userStream.disableAudio() : GameCenterMedia.userStream.enableAudio())
	}

	function handleVoiceChatMute({
		value: value
	}) {
		_this.events.fire(AudioController.TOGGLE_MUTE, {
			value: !value
		}), PlayerModel.set("gcmedia_mute_audio", value), muteSelf(value), _muted = value
	}
	async function onHotSpotActive(isActive) {
		const hotspot = HotSpotStore.get("hotspot");
		hotspot && (isActive ? _id = hotspot.id : (_muted = !0, _this.disconnect(), _connected && (UIStore.get("shouldMuteFromUserSettings") || _this.events.fire(AudioController.TOGGLE_MUTE, {
			value: !1
		}))))
	}

	function handleError(e) {
		_connected = !1, _this.events.fire(VoiceChatController.ERROR, {
			message: e
		})
	}
	Dev.expose("stressTest", (async () => {
			await _this.disconnect(), await _this.connect()
		})),
		function addListeners() {
			_this.bindState(HotSpotStore, "active", onHotSpotActive), _this.events.sub(VoiceChatController.TOGGLE_MUTE, handleVoiceChatMute)
		}(), Utils.query("portalMute"), this.connect = async function() {
			if (_id || handleError("No hotspot ID available"), window.AgoraRTC && AgoraRTC?.__CLIENT_LIST__?.length && (await _this.disconnect(), await _this.wait(100)), !_connecting) {
				_this.events.fire(VoiceChatController.CONNECTING), _disconnecting && await undefined, _connecting = !0, await Multiplayer.wait("room");
				try {
					Multiplayer.room.mediaId = Multiplayer.room.id + _id, await GameCenterMedia.useRoom(Multiplayer.room), _connected = !0, _this.events.fire(VoiceChatController.CONNECTED, {
						value: !0
					}), Tests.autoJoinChatOnEnterHotspot() ? muteSelf(!0) : muteSelf(!1)
				} catch (e) {
					handleError(e)
				}
				_connecting = !1
			}
		}, this.disconnect = async function() {
			await _this.wait((() => !_connecting)), _connected && (_disconnecting = !0, await GameCenterMedia.useRoom(!1), _connected = !1, _disconnecting = !1, _this.events.fire(VoiceChatController.CONNECTED, {
				value: !1
			}), UIMuteButton.instance().muted || (GlobalAudio3D.muted = !1))
		}, this.get("connected", (_ => _connected)), this.get("muted", (_ => _muted))
}), "singleton", (_ => {
	VoiceChatController.NON_AUTO_JOIN_ENTER = "VoiceChatController.NON_AUTO_JOIN_ENTER", VoiceChatController.CONNECTED = "VoiceChatController.CONNECTED", VoiceChatController.CONNECTING = "VoiceChatController.CONNECTING", VoiceChatController.TOGGLE_MUTE = "VoiceChatController.TOGGLE_MUTE", VoiceChatController.ERROR = "VoiceChatController.ERROR"
})), Class((function HotSpot({
	mesh: mesh,
	data: data,
	prev: prev = 0,
	next: next = 0
} = {}) {
	Inherit(this, Object3D), Inherit(this, StateComponent);
	const _this = this;
	let _inside, _artwork, _environment;
	_this.mesh = mesh, _this.data = data, _this.position = new Vector3, _this.id = data?.hotspot?.slug?.current || mesh?.uilName || "", _this.hero = data?.artPiece?.hero, _this.prev = prev, _this.next = next;
	let _visible = !1,
		_hasSecond = !1,
		_secondTrigger = !1;

	function checkSecondTimer() {
		if (_secondTrigger || !_visible) return;
		const switchAt = _this?.data?.artPiece?.hotspotDetail?.secondVisualSwitchTime,
			currentTime = HotSpotStore.get("audio")?.currentTime;
		currentTime && currentTime >= switchAt && transitionToSecond()
	}

	function onHotSpotActive(isActive) {
		const hotspot = HotSpotStore.get("hotspot");
		hotspot && hotspot.id === _this.id ? isActive ? function onEnter() {
			if (!_inside) return;
			_artwork.enter(), _this.layers?.ui_gl?.onEnter?.(), _this.del && clearTimeout(_this.del);
			_this.layers.artwork.shader.set("uPersist", 1), Global.VFX_SHADER && Global.VFX_SHADER.tween("uBlendAtmosMix", 0, 1e3, "easeOutCubic");
			_inside.group.position.copy(_this.position), _inside.show(data), _visible = !0
		}() : async function onLeave() {
			if (!_inside) return;
			_artwork.leave(), _this.layers?.ui_gl?.onLeave?.(), await _inside.animateOut(), Global.VFX_SHADER && Global.VFX_SHADER.tween("uBlendAtmosMix", 1, 2e3, "easeInOutCubic");
			_this.del = _this.delayedCall((() => {
				onExitCompleted()
			}), HotSpot.LEAVE_TIMEOUT), _visible = !1, _secondTrigger = !1
		}(): _this.del && onExitCompleted()
	}

	function onExitCompleted() {
		_this.layers.artwork.shader.set("uPersist", 0), _inside.hide(), _this.del = !1
	}

	function transitionToSecond() {
		const secondVisual = data?.artPiece?.hotspotDetail?.secondVisual;
		secondVisual && (_secondTrigger = !0, _inside?.transitionToSecond?.(), _artwork.transition())
	}
	_this.uiColor = {
		normal: new Color("#000000"),
		inside: new Color("#000000"),
		second: new Color("#000000")
	}, data?.artPiece?.hotspotColor?.uiColor?.hex && (_this.uiColor.normal = new Color(data?.artPiece?.hotspotColor?.uiColor?.hex || "#000000")), data?.artPiece?.hotspotColor?.uiColorInside?.hex && (_this.uiColor.inside = new Color(data?.artPiece?.hotspotColor?.uiColorInside?.hex || "#000000")), data?.artPiece?.hotspotColor?.uiColorSecondArtwork?.hex && (_this.uiColor.second = new Color(data?.artPiece?.hotspotColor?.uiColorSecondArtwork?.hex || "#000000")), _this.distance = 10, async function() {
		_this.layout = _this.initClass(SceneLayout, "hotspot"), _this.layers = await _this.layout.getAllLayers(), _this.isPlayground() && (_this.layers.debug_only_playground.visible = !0), mesh && (_this.group.position.copy(mesh.position), _this.group.rotation.y = mesh.rotation.z, _environment = _this.parent.parent, _artwork = _this.initClass(HotSpotArtwork, _this.layers, data), _this.layers.glow.visible = !1, function pickInside() {
			const insideType = data?.artPiece?.hotspotDetail?.environmentTemplate?._type;
			if (!insideType) return void console.error("A hotspot is missing an environment template type");
			if (_this.parent.insides[insideType]) {
				if (_inside = _this.parent.insides[insideType], Array.isArray(_inside)) {
					let internalId = data?.artPiece?.internalId;
					_inside = _inside.find((i => i.internalId === internalId)), _inside || console.warn("Can't find inside, when multiple insides share the same environment type, make sure to specify the internalId on the inside class.")
				}
				_inside.setData(data)
			} else console.error(`Could not find the type setup in HotspotManager.  The type was ${insideType}`)
		}(), function addListener() {
			_this.bindState(HotSpotStore, "active", onHotSpotActive)
		}(), _hasSecond = data?.artPiece?.hotspotDetail?.secondVisual, _hasSecond && !Utils.query("disableSecond") && (Utils.query("fastSecond") ? _this.delayedCall(transitionToSecond, 300) : _this.startRender(checkSecondTimer, 10)), _this.flag("isReady", !0))
	}(), this.get("position", (_ => _this.group.position)), this.get("environment", (_ => _environment)), this.get("artwork", (_ => _artwork)), this.get("secondTrigger", (_ => _secondTrigger)), this.ready = () => _this.wait("isReady")
}), (_ => {
	HotSpot.LEAVE_TIMEOUT = 2e3
})), Class((function HotSpotArtwork(layers, data) {
	Inherit(this, Component);
	const _this = this;
	let _wrapper, _v3 = new Vector3,
		_quaternion = new Quaternion,
		_up = new Vector3(0, 1, 0),
		_lookAtMatrix = new Matrix4,
		_lookAtVector = new Vector3,
		_static = !1,
		_obj = {
			enter: 0
		},
		_wrapperPosition = new Vector3,
		_videoTextures = [];
	const artwork = layers.artwork;
	let artwork_texture, second_texture, videoAlwaysPlaying = Tests.videoAlwaysPlaying();

	function createTexture(visual) {
		if (!visual) return;
		let texture = !1;
		if (visual.image) {
			const url = SanityImageUrlBuilder.build(visual.image).width(parseInt(600 * Tests.artworkQuality())).quality(90).dpr(World.DPR).url();
			if (!url) return void console.warn("[Hotspot] missing artwork", data);
			texture = Utils3D.getTexture(url), _this.wait(texture, "loaded").then((() => {
				texture.upload()
			}))
		}
		if (visual.video) {
			const posterURL = SanityImageUrlBuilder.build(visual.poster).width(parseInt(512 * Tests.artworkQuality())).quality(90).dpr(World.DPR).url();
			if (Tests.useVideoArtwork()) {
				const videoUrl = visual.video.asset.url;
				if (!videoUrl) return void console.warn("[Hotspot] missing artwork video", data);
				const videotex = _this.initClass(VideoTexture, videoUrl, {
					firstFrame: !videoAlwaysPlaying && posterURL,
					autoplay: videoAlwaysPlaying,
					preload: videoAlwaysPlaying
				});
				_videoTextures.push(videotex), videoAlwaysPlaying && videotex.start(), texture = videotex.texture
			} else texture = Utils3D.getTexture(SanityImageUrlBuilder.build(visual.poster).width(512).quality(90).url())
		}
		return texture
	}

	function loop(_time) {
		if (videoAlwaysPlaying && _videoTextures.length > 0 && function checkVideoTexture() {
				_videoTextures.forEach((videotex => {
					videotex && (videotex.canUpdate = artwork._drawing, videotex.visible = artwork._drawing)
				}))
			}(), _obj.enter > .01 && (_videoTextures[0] && artwork.shader.set("tMap", _videoTextures[0].texture), _videoTextures[1] && artwork.shader.set("tMap2", _videoTextures[1].texture)), artwork.shader.set("uEnter", _obj.enter), artwork.position.y = .5 * -_obj.enter, artwork.position.z = 3.5 * _obj.enter, _static) return;
		const env = _this.parent.environment,
			player = env?.player;
		if (!env || !player || !player.group) return;
		const playerPosition = _v3.copy(player.group.position);
		playerPosition.y = _wrapper.position.y, _lookAtVector.lerp(playerPosition, .05), _lookAtMatrix.lookAt(_wrapper.position, _lookAtVector, _up), _quaternion.setFromRotationMatrix(_lookAtMatrix), _wrapper.quaternion.slerp(_quaternion, .4)
	}! function() {
		_wrapper = artwork._parent, _wrapperPosition.copy(_wrapper.position);
		const name = data.hotspot.slug.current;
		["hotspot1", "hotspot2", "hotspot3", "hotspot4", "hotspot5", "hotspot6", "hotspot7", "hotspot8"].includes(name) && (artwork.shader.set("uStatic", 1), _static = !0), _this.parent.hero && artwork.shader.set("uHero", 1), _this.parent.environment.group.attach(_wrapper), _quaternion.copy(_wrapper.quaternion), artwork_texture = createTexture(data.artPiece.galleryVisual),
			function applyArtwork(mesh, texture) {
				if (!mesh || !texture) return;
				_this.wait(texture, "loaded").then((async () => {
					await defer();
					let {
						width: width,
						height: height
					} = texture.dimensions;
					width >= height ? mesh.scale.x = mesh.scale.y * width / height : mesh.scale.y = mesh.scale.x * height / width, (width === height || width < height) && mesh.scale.multiplyScalar(1.2), _this.events.fire(HotSpotArtwork.RESIZE, !0)
				})), mesh.shader.set("tMap", texture)
			}(artwork, artwork_texture), data?.artPiece?.hotspotDetail?.secondVisual && (_videoTextures.push(null), second_texture = createTexture(data.artPiece.hotspotDetail.secondVisual), artwork.shader.set("tMap2", second_texture)), _this.startRender(loop)
	}(), this.enter = function() {
		videoAlwaysPlaying || _videoTextures.forEach((videotex => {
			videotex && videotex.start()
		})), tween(_obj, {
			enter: 1
		}, 1500, "easeInOutQuad")
	}, this.leave = function() {
		videoAlwaysPlaying || _videoTextures.forEach((videotex => {
			videotex && videotex.stop()
		})), tween(_obj, {
			enter: 0
		}, 1500, "easeInOutQuad"), artwork.shader.set("uTransition", 0)
	}, this.transition = function() {
		_videoTextures[1] && _videoTextures[1]?.video?.video && (_videoTextures[1].video.video.currentTime = 0), artwork.shader.tween("uTransition", 1, 800, "easeOutCubic")
	}, this.get("artwork", (_ => artwork)), this.get("wrapper", (_ => _wrapper)), this.get("quaternion", (_ => _quaternion))
}), (_ => {
	HotSpotArtwork.RESIZE = "HotSpotArtwork.RESIZE"
})), Class((function HotSpotAudioManager() {
	Inherit(this, Component), Inherit(this, StateComponent);
	const _this = this,
		AC = AudioController.instance(),
		UI = (SFXController.instance(), GLUIWrapper.instance());
	let _audio = null,
		_startPlaying = !1,
		_id = null,
		_complete = !1;
	_this.ready = Promise.create();
	let _useFallback = "ios" === Device.system.os || "safari" === Device.system.browser;

	function handleToggleComplete({
		value: value
	}) {
		_complete = value
	}

	function handleVoiceChatMute({
		value: value
	}) {
		value ? _audio.play() : pause()
	}
	async function onHotSpotActive(isActive) {
		const hotspot = HotSpotStore.get("hotspot");
		if (hotspot) return isActive ? void play() : (_this.events.fire(HotSpotAudioManager.TOGGLE_COMPLETE, {
			value: !1
		}), stop(hotspot))
	}
	async function play(hotspot = HotSpotStore.get("hotspot")) {
		let audio;
		if (await GlobalAudio3D.interacted, await _this.wait(500), SpaceAudioManager.instance().isIntroPlaying && SpaceAudioManager.instance().stopIntro(), _useFallback) {
			const audioFile = hotspot?.data?.artPiece?.hotspotDetail?.voiceover?.audio?.asset?.url;
			audio = _this.initClass(Audio3DWASimpleBuffer), audio.playbackRate = AC.hotspotPlaybackSpeed, audio.src = audioFile, audio.context.webkitPreservesPitch = !0, await audio.play()
		} else {
			if (AC.isAudioLoaded(hotspot.id) || await
				function registerHotspotAudio(hotspot) {
					const audioFile = hotspot?.data?.artPiece?.hotspotDetail?.voiceover?.audio?.asset?.url;
					if (audioFile) return AC.registerAudio(hotspot.id, audioFile)
				}(hotspot), !HotSpotStore.get("active")) return;
			_startPlaying = !0, audio = AC.getAudio(hotspot.id), Utils.query("startAudioAt") && !_this.flag("skipOnce") ? (AC.play({
				name: hotspot.id,
				timeStamp: Utils.query("startAudioAt")
			}), _this.flag("skipOnce", !0)) : await AC.fadeIn(hotspot.id, 700, "cubicOut")
		}
		_this.commit(HotSpotStore, "setAudio", audio), _audio = audio, _id = hotspot.id, _this.events.fire(HotSpotAudioManager.PLAY_HOTSPOT_AUDIO, {
			value: hotspot.id
		}), _startPlaying = !1
	}
	async function stop(hotspot) {
		_useFallback && _audio?.unload(), _this.events.fire(HotSpotAudioManager.PLAY_HOTSPOT_AUDIO, {
			value: null
		}), _this.commit(HotSpotStore, "setAudio", null), _audio = null, _id = null, AC.fadeOut(hotspot.id, 600, "cubicOut")
	}

	function pause(audio = HotSpotStore.get("audio")) {
		audio && audio.pause()
	}

	function loop() {
		_audio && (_audio && _audio.progress && UI.audioButton.setProgress(_audio.progress), _audio.duration - _audio.currentTime <= 0 && function handleAudioComplete() {
			_this.events.fire(HotSpotAudioManager.TOGGLE_COMPLETE, {
				value: !0
			}), stop(!1)
		}())
	}! function addHandlers() {
		_this.bindState(HotSpotStore, "active", onHotSpotActive), _this.events.sub(VoiceChatController.TOGGLE_MUTE, handleVoiceChatMute), _this.events.sub(HotSpotAudioManager.TOGGLE_COMPLETE, handleToggleComplete), _this.startRender(loop)
	}(), _this.ready.resolve(), Dev.expose("playHotSpotAudio", (() => {
		play()
	})), Dev.expose("stopHotSpotAudio", (() => {
		stop(HotSpotStore.get("hotspot"))
	})), Dev.expose("seekHotSpotAudio", (t => {
		const hotspot = HotSpotStore.get("hotspot");
		AC.getAudio(hotspot.id).seek(t)
	})), this.play = play, this.stop = stop, this.pause = pause, this.get("complete", (_ => _complete)), this.get("currentTrack", (_ => _audio))
}), "singleton", (_ => {
	HotSpotAudioManager.PLAY_HOTSPOT_AUDIO = "HotSpotAudioManager.PLAY_HOTSPOT_AUDIO", HotSpotAudioManager.TOGGLE_COMPLETE = "HotSpotAudioManager.TOGGLE_COMPLETE"
})), Class((function HotSpotCloseDOM(onClick = (() => {})) {
	Inherit(this, Element), Inherit(this, StateComponent);
	const _this = this,
		$this = _this.element;
	let _wrapper, _circle, _left, _right;

	function onHover(e) {
		const isEnter = "over" === e.action;
		_wrapper.tween({
			scale: isEnter ? 1.1 : 1
		}, 300, "easeOutQuad")
	}!async function() {
		! function initHTML() {
			if (PortalUtil.isPortal || Utils.query("no-UI")) return;
			_wrapper = $this.create("wrapper"), _circle = _wrapper.create("circle"), _left = _wrapper.create("left"), _right = _wrapper.create("right"), $this.interact(onHover, onClick)
		}(),
		function initStyles() {
			$this.goob(`\n          & {\n            width: 52px;\n            height: 52px;\n            z-index: 9999;\n            left: 50%;\n            transform: translateX(-50%);\n            ${StyleGuide.fluid("top",StyleGuide.lateralPadding)}\n\n            ${StyleGuide.smaller("tablet",`\n                    ${StyleGuide.fluid("left",StyleGuide.lateralPadding)}\n                    transform: none;\n            `)}\n          }\n\n          .wrapper {\n            width: 100%;\n            height: 100%;\n          }\n\n          .circle {\n            width: 100%;\n            height: 100%;\n            background: #ffffff;\n            border-radius: 50%;\n            will-change: transform;\n          }\n\n          .left, .right {\n            width: 15px;\n            height: 1px;\n            background: #5757D8;\n            top: 50%;\n            left: 50%;\n            will-change: width;\n          }\n\n          .left {\n            transform: translate(-50%, -50%) rotate(45deg);\n          }\n\n          .right {\n            transform: translate(-50%, -50%) rotate(-45deg);\n          }\n        `)
		}(), await _this.wait(100), _this.bindState(UIStore, "modal", (modal => {
			HotSpotStore.get("active") && (modal ? _this.animateOut() : _this.animateIn())
		}))
	}(), this.animateIn = async function() {
		PortalUtil.isPortal || Utils.query("no-UI") || (_this.clearTimers(), await _this.wait(1e3), _this.events.fire(StarsUI.ENTER_HOTSPOT), await _this.wait(800), _circle.transform({
			scale: 0
		}), _left.css({
			width: 0
		}), _right.css({
			width: 0
		}), $this.show(), _circle.tween({
			scale: 1
		}, 1e3, "easeOutCubic"), _left.tween({
			width: 15
		}, 1e3, "easeOutCubic", 400), _right.tween({
			width: 15
		}, 1e3, "easeOutCubic", 420))
	}, this.animateOut = async function() {
		PortalUtil.isPortal || Utils.query("no-UI") || (_this.clearTimers(), _left.tween({
			width: 0
		}, 800, "easeOutCubic"), _right.tween({
			width: 0
		}, 800, "easeOutCubic"), _circle.tween({
			scale: 0
		}, 800, "easeOutCubic", 80), _this.events.fire(StarsUI.LEAVE_HOTSPOT), await _this.wait(1200), $this.hide())
	}
})), Class((function HotSpotCompass() {
	Inherit(this, Object3D), Inherit(this, StateComponent);
	const _this = this;
	let _compass, _env, _target, _wrapper = new Group,
		_quat = new Quaternion,
		_eul = new Euler,
		_isVR = Tests.isVR();

	function loop() {
		const player = _env?.player,
			target = _this.parent.hotspots[_target];
		if (!target) return void(_compass.visible = !1);
		if (!_env || !player || !player.group) return;
		let RADIUS = .8;
		"1st" === PlayerSettings.instance().state.camera && (RADIUS = 1.3);
		let radius = RADIUS + .06 * Math.sin(.005 * Render.TIME);
		_this.group.position.copy(player.group.position), _this.group.position.y += _isVR ? .85 : 1.45, _compass.position.x = Math.lerp(radius, _compass.position.x, .2);
		const a = _this.group.position,
			b = target.mesh.position;
		let angle = Math.atan2(a.x - b.x, a.z - b.z);
		angle += Math.PI / 2, _this.angle = angle, _eul.y = angle, _quat.setFromEuler(_eul), _wrapper.quaternion.slerp(_quat, .05), _compass.visible = !0
	}
	async function onHotSpotChange(hotspot) {
		if (!hotspot) return;
		await _this.wait(1e3), _this.parent.hotspots.indexOf(hotspot) === _target && setTarget(_target + 1)
	}

	function setTarget(index) {
		_target = index;
		const hotspot = _this.parent.hotspots[_target];
		hotspot?.layers && (_this.parent.hotspots.forEach((h => {
			h.layers.glow.visible = !1
		})), hotspot.layers.glow.visible = !0)
	}

	function onHotSpotActive(active) {
		UIStore.get("landing") || _compass.shader.tween("uHide", active ? 1 : 0, 600, "easeOutCubic")
	}

	function onLandingChange(isLanding) {
		_compass.shader.tween("uHide", isLanding ? 1 : 0, 600, "easeOutCubic")
	}!async function() {
		await _this.parent.ready(), await _this.parent.hotspotsready(), _env = _this.parent.environment, _compass = _env.layout.layers.compass, Tests.showCompass() ? (_env.layout.group.add(_this.group), setTarget(0), _wrapper.add(_compass), _this.add(_wrapper), _this.startRender(loop), function addListeners() {
			_this.bindState(HotSpotStore, "hotspot", onHotSpotChange), _this.bindState(HotSpotStore, "active", onHotSpotActive), _this.bindState(UIStore, "landing", onLandingChange)
		}()) : _compass.visible = !1
	}()
})), Class((function HotSpotManager(environment) {
	Inherit(this, Component), Inherit(this, StateComponent);
	const _this = this;
	let _compass, _quad, _shared, _fallback, _all, _hotspots = [],
		_layers = [],
		_v3 = new Vector3;
	_this.environment = environment, _this.insides = {}, _this.checkEnabled = !0;
	let tweenParam = {
		value: 0
	};
	let _captions, _closeDOM, _useFallback = !Tests.useVFX(),
		_forceClose = !1;

	function closeHotspot() {
		_forceClose = !0, updateOrientationOnAudio({
			value: !0
		})
	}

	function getNumeric(str) {
		return parseInt(str.match(/(\d+)/)[0])
	}

	function check() {
		if (!_this.checkEnabled) return;
		if (!environment.player) return;
		const playerPosition = environment.player.group.position;
		let hotspot = !1;
		_hotspots.forEach((single => {
			_v3.copy(single.position), single.distance = _v3.sub(playerPosition).length(), single.distance < HotSpotManager.RADIUS && (hotspot = single.mesh)
		})), _forceClose && !hotspot && (_forceClose = !1), _forceClose && (hotspot = !1), hotspot && !HotSpotStore.get("active") && _this.commit(HotSpotStore, "setHotSpot", hotspot.hotspot), _this.commit(HotSpotStore, "setActive", !!hotspot)
	}

	function addListeners() {
		_this.bindState(HotSpotStore, "active", onHotSpotActive), _this.events.sub(HotSpotManager.TELEPORT, onTeleport), _this.events.sub(HotSpotManager.TELEPORT_POSITION, onTeleportPosition), _this.events.sub(HotSpotAudioManager.TOGGLE_COMPLETE, updateOrientationOnAudio), _this.events.sub(HotSpotAudioManager.TOGGLE_COMPLETE, (({
			value: value
		}) => {
			if (!value) return;
			const hotspot = HotSpotStore.get("hotspot");
			TrackAnalytics.track("HotspotAudioCompleted", hotspot?.id)
		}))
	}

	function updateOrientationOnAudio({
		value: value
	}) {
		if (!value) return;
		_forceClose = !0;
		HotSpotStore.state.visited.length < _hotspots.length && orientate(_compass.angle + Math.PI, _this.environment.player)
	}

	function onTeleportPosition(position) {
		teleport({
			position: position
		}), orientate(Math.PI, _this.environment.player)
	}

	function onTeleport(index) {
		if (!index) return;
		const hotspot = _hotspots.find((obj => obj.id === index));
		hotspot && teleport(hotspot)
	}
	async function teleport(hotspot) {
		_this.events.fire(HotSpotManager.TELEPORTING), await _quad.animateIn(), _this.environment.player.view.setUniform("uIsTeleporting", 1), _this.checkEnabled = !1, _this.commit(HotSpotStore, "setActive", !1), await _this.wait(200), Tests.isVR() ? (_this.environment.player.controls.setPosition(hotspot.position), lookAtArtwork(hotspot)) : _this.environment.player.controls.teleport(hotspot.position), await _this.wait(300), _forceClose = !1, _this.checkEnabled = !0, await _this.wait(700), _this.environment.player.view.setUniform("uIsTeleporting", 0), await _quad.animateOut()
	}
	async function onHotSpotActive(isActive) {
		if (_this.lookTween && _this.lookTween.stop(), isActive) {
			_closeDOM.animateIn();
			const hotspot = HotSpotStore.get("hotspot");
			TrackAnalytics.track("HotspotEnter", hotspot?.id), HotSpotManager.uHotspotPosition.value.copy(hotspot.position), HotSpotManager.uHotspotEnter.value = 1, HotSpotManager.t && HotSpotManager.t.stop(), HotSpotManager.uHotspotTransition.value = 0, HotSpotManager.uHotspotDirection.value = 1, HotSpotManager.uHotspotRadius.value = 2.5, HotSpotManager.t = tween(HotSpotManager.uHotspotTransition, {
				value: 1
			}, 1200, "easeOutQuart"), Platform.usingVR() || lookAtArtwork(hotspot), _shared && _shared.group.position.copy(hotspot.position), Device.mobile && await _this.wait(1e3), Tests.autoJoinChatOnEnterHotspot() ? VoiceChatController.instance().connect() : VoiceChatController.instance().events.fire(VoiceChatController.NON_AUTO_JOIN_ENTER, {
				value: !0
			})
		} else {
			_closeDOM.animateOut();
			const hotspot = HotSpotStore.get("hotspot");
			hotspot?.id && TrackAnalytics.track("HotspotLeave", hotspot?.id), HotSpotManager.uHotspotEnter.value = 0, HotSpotManager.t && HotSpotManager.t.stop(), HotSpotManager.uHotspotTransition.value = 1, HotSpotManager.uHotspotDirection.value = 0, HotSpotManager.uHotspotRadius.value = 1, HotSpotManager.t = tween(HotSpotManager.uHotspotTransition, {
				value: 0
			}, 1200, "easeInSine"), VoiceChatController.instance().disconnect()
		}
		if (_useFallback) {
			for (el in _all) "captions" != el && "spawn" != el && -1 == el.indexOf("hotspot") && ("grass" == el || "tree_leaves" == el ? _all[el].instanceMesh.visible = !isActive && _all[el].instanceMesh.prevVisible : _all[el].visible = !isActive && _all[el].prevVisible);
			isActive || RoomCulling.forceUpdate(), _fallback.visible = isActive
		}
	}

	function lookAtArtwork(hotspot) {
		let player = _this.environment.player;
		return orientate(hotspot.group.rotation.y, player)
	}

	function orientate(angle, player) {
		if (Platform.usingVR() || player.controls.orbit) {
			let turns, cam = Platform.usingVR() ? RenderManager.camera.wrapper : player.controls.orbit;
			turns = Platform.usingVR() ? Math.floor(cam.rotation.y / (2 * Math.PI)) : Math.floor(cam.rotationY / (2 * Math.PI));
			let endAngle = angle + 2 * turns * Math.PI + .5 * Math.PI,
				initAngle = Platform.usingVR() ? cam.rotation.y : cam.rotationY;
			if (Math.abs(endAngle - initAngle) > Math.PI) {
				endAngle -= 2 * (endAngle > initAngle ? 1 : -1) * Math.PI
			}
			return tweenParam.value = 0, tween(tweenParam, {
				value: 1
			}, 1500, "easeInOutCubic").onUpdate((() => {
				Platform.usingVR() ? cam.rotation.y = endAngle * tweenParam.value + initAngle * (1 - tweenParam.value) : PlayerControlsOrbit.DRAGGING ? clearTween(tweenParam) : cam.rotationY = endAngle * tweenParam.value + initAngle * (1 - tweenParam.value)
			})).promise()
		}
	}!async function() {
		if (Global.LOADER.add(1), _closeDOM = _this.initClass(HotSpotCloseDOM, closeHotspot), Stage.add(_closeDOM.element), _this.events.sub(Keyboard.DOWN, (e => {
				27 === e.keyCode && HotSpotStore.get("active") && closeHotspot()
			})), _all = await environment.layout.getAllLayers(), _useFallback)
			for (el in _all) "grass" == el || "tree_leaves" == el ? _all[el].instanceMesh.prevVisible = _all[el].instanceMesh.visible : _all[el].prevVisible = _all[el].visible;
		_layers = await environment.layout.getAllMatching("hotspot"), _captions = await environment.layout.getLayer("captions"), _compass = _this.initClass(HotSpotCompass), _quad = _this.initClass(TeleportQuad), Tests.isVR() && (_quad.animateIn(), Global.VR_READY.then((() => {
				_this.delayedCall((() => {
					_quad.animateOut()
				}), 1e3)
			}))), _this.environment.group.add(_quad.group), Tests.hotSpotShared() && (_shared = _this.initClass(HotSpotShared)), _useFallback ? (_fallback = new Group, _this.environment.group.add(_fallback), _shared && _fallback.add(_shared.group), Tests.isVR() ? Global.VR_READY.then((() => {
				_fallback.visible = !1
			})) : _fallback.visible = !1) : _shared && InsideScene.instance().scene.add(_shared.group),
			function initHotspots() {
				_layers.forEach((layer => {
					Global.PLAYGROUND || (layer.visible = !1)
				}));
				const cmsHotspots = Gallery.activeHotspots;
				Hydra.LOCAL && console.log(`[HotSpotManager] ${cmsHotspots.length} hotspots found in the CMS.`);
				cmsHotspots.sort(((a, b) => getNumeric(a.hotspot.slug.current) > getNumeric(b.hotspot.slug.current))), cmsHotspots.forEach(((item, index) => {
					const id = item.hotspot.slug.current,
						layer = function getLayerById(id) {
							return environment.layout.layers[id]
						}(id);
					if (!layer) return console.error("[HotSpotManager]: Could not find layer for hotspot", id);
					const prev = cmsHotspots[index - 1]?.hotspot.slug.current,
						next = cmsHotspots[index + 1]?.hotspot.slug.current,
						instance = _this.initClass(HotSpot, {
							mesh: layer,
							data: item,
							prev: prev,
							next: next
						});
					environment.group.add(instance.group), layer.hotspot = instance, _hotspots.push(instance)
				})), _this.areas = _hotspots
			}(),
			function initInsides() {
				let insideParent;
				insideParent = _useFallback ? _fallback : InsideScene.instance().scene;
				const insides = {
						hotspotInsidePhotos: InsideOrigin,
						hotspotInsideGoldSwirls: InsideGenerative,
						hotspotInsideRain: InsideScam,
						hotspotInsideHokusai: InsideHokusai,
						hotspotInsideKolidescope: InsideMemo,
						hotspotInsideLidarVideo: InsideDecentraland,
						hotspotInsideVideoAndImage: InsideDual,
						hotspotInsideVideoAndImageSpritesheet: [InsideVee, InsideTaco],
						hotspotInsideStudioLidar: InsideGucci,
						hotspotInsideSwirls: InsideWsj,
						hotspotInsideAxie: InsideAxie,
						hotspotInsideSushi: InsideSushi,
						hotspotInsideDNA: InsideDna,
						hotspotInsideGoldBlueSwirls: InsideDao,
						hotspotInsideFlowerPedals: InsideEvolute
					},
					initInside = name => {
						const instance = _this.initClass(name);
						return instance.visible = !1, insideParent.add(instance.group), instance
					};
				for (const key in insides) Array.isArray(insides[key]) ? _this.insides[key] = insides[key].map((k => initInside(k))) : _this.insides[key] = initInside(insides[key]);
				Global.VFX_SHADER && HotSpotManager.applyToShader(Global.VFX_SHADER)
			}(), Global.LOADER.add(2);
		const allHotspots = [];
		_hotspots.forEach((h => {
			allHotspots.push(h.ready())
		})), await Promise.all(allHotspots), Global.LOADER.trigger(2), async function batchFloor() {
			const batch = new MeshBatch({
				worldCoords: !0
			});
			environment.group.add(batch.group), _hotspots.forEach((async hotspot => {
				await hotspot.ready(), batch.add(hotspot.layers.floor)
			})), await batch.ready(), batch.mesh.frustumCulled = !1, Global.VR_READY.then((() => {
				batch.static = !0
			}))
		}(), RoomCulling.trackHotspots(_this), Tests.isVR() ? Global.VR_READY.then((() => {
			_this.startRender(check, 20), addListeners()
		})) : (_this.startRender(check, 20), addListeners()), _this.flag("isReady", !0), Global.LOADER.trigger(1)
	}(), this.get("hotspots", (_ => _hotspots)), this.ready = () => _this.wait("isReady"), this.hotspotsready = () => {
		const promises = [];
		return _hotspots.forEach((h => {
			promises.push(h.ready())
		})), Promise.all(promises)
	}
}), (_ => {
	HotSpotManager.TELEPORT = "HotSpotManager.TELEPORT", HotSpotManager.TELEPORT_POSITION = "HotSpotManager.TELEPORT_POSITION", HotSpotManager.TELEPORTING = "HotSpotManager.TELEPORTING", HotSpotManager.RADIUS = 2.5, HotSpotManager.uHotspotRadius = {
		value: HotSpotManager.RADIUS,
		ignoreUIL: !0
	}, HotSpotManager.uHotspotTransition = {
		value: 0,
		ignoreUIL: !0
	}, HotSpotManager.uHotspotPosition = {
		value: new Vector3,
		ignoreUIL: !0
	}, HotSpotManager.uHotspotEnter = {
		value: 1,
		ignoreUIL: !0
	}, HotSpotManager.uHotspotDirection = {
		value: 1,
		ignoreUIL: !0
	}, HotSpotManager.applyToShader = function(shader) {
		shader.uniforms.uHotspotTransition = HotSpotManager.uHotspotTransition, shader.uniforms.uHotspotPosition = HotSpotManager.uHotspotPosition, shader.uniforms.uHotspotRadius = HotSpotManager.uHotspotRadius, shader.uniforms.uHotspotEnter = HotSpotManager.uHotspotEnter, shader.uniforms.uHotspotPersist = {
			value: 0,
			ignoreUIL: !0
		}, shader.uniforms.uHotspotDirection = HotSpotManager.uHotspotDirection
	}
})), Class((function HotSpotShared() {
	Inherit(this, Object3D);
	const _this = this;
	_this.layout = _this.initClass(SceneLayout, "HotSpotShared")
})), Class((function HotSpotStore() {
	Inherit(this, Component), Inherit(this, AppStore);
	const _this = this;
	!async function() {
		await Hydra.ready(), _this.createAppStore({
			state: {
				active: !1,
				hotspot: null,
				visited: [],
				audioProgress: 0
			},
			mutations: {
				setActive(state, payload) {
					state.active = payload;
					const id = state?.hotspot?.id;
					id && -1 === state.visited.indexOf(id) && state.visited.push(id)
				},
				setHotSpot(state, payload) {
					state.hotspot = payload
				},
				setAudio(state, payload) {
					state.audio = payload
				}
			}
		})
	}()
}), "static"), Class((function InsideScene() {
	Inherit(this, FXScene);
	const _this = this;

	function loop() {
		HotSpotManager.uHotspotTransition.value < .001 || _this.render()
	}
	_this.create({
		manualRender: !0
	}), _this.useCamera(World.CAMERA), _this.startRender(loop, RenderManager.BEFORE_RENDER)
}), "singleton"), Class((function ArtworkShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	! function() {
		const nukeCondition = Global.PLAYGROUND || Tests.isVR();
		_shader.addUniforms({
			uScene: {
				value: nukeCondition ? null : World.NUKE.prevFrameRT
			},
			uScene2: {
				value: null
			},
			uHotspotTransition: HotSpotManager.uHotspotTransition,
			uPersist: {
				value: 0
			},
			tMap: {
				value: null
			},
			tMap2: {
				value: null
			},
			uTransition: {
				value: 0
			},
			uHero: {
				value: 0
			},
			uEnter: {
				value: 0
			},
			uStatic: {
				value: 0
			},
			transparent: !1,
			side: Shader.BACK_SIDE
		}), Tests.isVR() && (_shader.transparent = !0, _mesh.renderOrder = RenderOrder.ARTWORK_VR)
	}()
})), Class((function HotSpotBubbleShader() {
	Inherit(this, Component);
	const _this = this;
	this.getShader = function() {
		return _this.initClass(Shader, "HotSpotBubbleShader", {
			uColor: {
				value: new Color("#ffffff")
			},
			uAlpha: {
				value: 1,
				batchUnique: !0
			},
			blending: Shader.ADDITIVE_BLENDING,
			transparent: !0
		})
	}
}), "static"), Class((function CompassShader(_mesh, _shader, _group, _input) {
	Inherit(this, FBR, _shader);
	_shader.addUniforms({
		uHide: {
			value: 1,
			ignoreUIL: !0
		}
	})
})), Class((function HotSpotFloor(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		uColor: {
			value: new Color("#ffffff")
		},
		uHotspotTransition: HotSpotManager.uHotspotTransition,
		uHotspotPosition: HotSpotManager.uHotspotPosition
	}), _shader.transparent = !0, _mesh.renderOrder = RenderOrder.HOTSPOT_FLOOR
})), Class((function HotSpotGlowShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		uColor: {
			value: new Color("#ffffff")
		},
		uAlpha: {
			value: 1,
			batchUnique: !0
		},
		blending: Shader.ADDITIVE_BLENDING,
		uHotspotTransition: HotSpotManager.uHotspotTransition,
		transparent: !0
	}), _mesh.renderOrder = RenderOrder.HOTSPOT_GLOW
})), Class((function HotSpotSharedParticlesClass(_proton, _group, _input) {
	_proton.shader.set("DPR", World.DPR)
})), Class((function TeleportQuad() {
	Inherit(this, Object3D);
	const _this = this;
	let _mesh, _shader;

	function loop() {
		_mesh.visible = _shader.get("uTransition") > .01
	}
	_shader = _this.initClass(Shader, "TeleportQuad", {
		uTransition: TeleportQuad.TELEPORTING,
		transparent: !0,
		depthTest: !1,
		depthWrite: !1
	}), _mesh = new Mesh(World.QUAD, _shader), _mesh.renderOrder = RenderOrder.TELEPORT_QUAD, _mesh.frustumCulled = !1, _this.group.add(_mesh), Tests.useVFX() ? _mesh.visible = !1 : _this.startRender(loop), this.animateIn = async function() {
		await tween(TeleportQuad.TELEPORTING, {
			value: 1
		}, 600, "easeOutCubic").promise()
	}, this.animateOut = async function() {
		await tween(TeleportQuad.TELEPORTING, {
			value: 0
		}, 600, "easeOutCubic").promise()
	}
}), (() => {
	TeleportQuad.TELEPORTING = {
		value: 0
	}
})), Class((function HotSpotUI() {
	Inherit(this, Object3D);
	const _this = this;
	let _hotspot, _shader, _text, _copy, _batch, $root = $gl();
	$root.enable3D();
	let _arrowLeft, _arrowRight, _arrowLeftProxy, _arrowRightProxy, _arrowShaderLeft, _arrowShaderRight, _depthPanel, _uPersist = {
			value: 0
		},
		_uEnter = {
			value: 0
		},
		_uShow = {
			value: 0
		},
		_uFill = {
			value: new Color("#000000")
		},
		_renderRetina = Tests.uiRetina(),
		_showDescription = Tests.showDescription(),
		_checkDistance = !1,
		tUIDepth = {
			value: Global.UI_DEPTH
		},
		uFullRes = {
			value: new Vector2(1024, 1024)
		};

	function retinaLoop() {
		if (!_batch?.mesh) return;
		const shader = _batch.mesh.shader;
		tUIDepth.value = Global.UI_DEPTH, shader.depthWrite = !1, shader.depthTest = !1;
		const prev = World.RENDERER.autoClear;
		World.RENDERER.autoClear = !1, uFullRes.value.set(World.RENDERER.canvas.width, World.RENDERER.canvas.height), _batch.mesh._drawing && World.RENDERER.renderSingle(_batch.mesh, World.CAMERA), _arrowLeft.mesh._drawing && World.RENDERER.renderSingle(_arrowLeft.mesh, World.CAMERA), _arrowRight.mesh._drawing && World.RENDERER.renderSingle(_arrowRight.mesh, World.CAMERA), World.RENDERER.autoClear = prev, shader.depthWrite = !0, shader.depthTest = !0
	}

	function loop() {
		if (!_batch || !_batch.mesh) return;
		_renderRetina && (_batch.mesh.shader.nullRender = !0, _arrowLeft && (_arrowLeft.mesh.shader.nullRender = !0), _arrowRight && (_arrowRight.mesh.shader.nullRender = !0)), _batch.mesh.shader.depthWrite = !0, _batch.mesh.renderOrder = RenderOrder.BATCH_UI;
		const artworkShader = _hotspot.layers.artwork.shader;
		if (_uPersist.value = artworkShader.uniforms.uPersist.value, _uEnter.value = artworkShader.uniforms.uEnter.value, $root.group.position.y = .5 * -_uEnter.value, $root.group.position.z = 3.5 * -_uEnter.value, _checkDistance) {
			const target = _hotspot.distance < 30 ? 1 : 0;
			_uShow.value = Math.lerp(target, _uShow.value, .05), _batch.group.visible = _uShow.value > .001
		} else _batch.group.visible = !0, _uShow.value = 0;
		let targetColor = _hotspot.uiColor.normal;
		_uEnter.value > .8 && (targetColor = _hotspot.uiColor.inside), _hotspot.secondTrigger && (targetColor = _hotspot.uiColor.second), _uFill.value.lerp(targetColor, .1), _hotspot.prev ? _arrowLeft.group.visible = _uEnter.value > .1 : _arrowLeft.group.visible = !1, _hotspot.next ? _arrowRight.group.visible = _uEnter.value > .1 : _arrowRight.group.visible = !1, _depthPanel && (_depthPanel.group.visible = _batch.group.visible)
	}

	function parseString(s) {
		return s = s.replace("<br>", "\n")
	}
	async function onArtworkResize() {
		if (_this.done) return;
		_this.done = !0;
		const size = new Vector3;
		_hotspot.layers.artwork.geometry.boundingBox.getSize(size), size.x *= _hotspot.layers.artwork.scale.x, size.y *= _hotspot.layers.artwork.scale.y, size.z *= _hotspot.layers.artwork.scale.z;
		const titleWidth = _showDescription ? .4 : .8,
			fontSizeTitle = _showDescription ? .34 : .48;
		_text = $glText(parseString(_hotspot.data?.artPiece?.title), "Manrope-SemiBold", fontSizeTitle, {
			letterSpacing: -.04,
			color: 16777215,
			lineHeight: 1.1,
			width: size.x * titleWidth
		}), _text.useShader(_shader), await _text.text.ready(), _text.y = -.2, _text.x = -size.x / 2, $root.add(_text), _showDescription && (_copy = $glText(parseString(_hotspot.data?.artPiece?.description), "Manrope-SemiBold", .16, {
			letterSpacing: -.04,
			color: 16777215,
			lineHeight: 1.3,
			width: size.x * (1 - titleWidth) - .06 * size.x
		}), _copy.useShader(_shader), await _copy.text.ready(), _copy.y = _text.y - .06, _copy.x = -size.x / 2, _copy.x += size.x * titleWidth, _copy.x += .06 * size.x, $root.add(_copy)), _batch = _this.initClass(GLUIBatchText, {
			uPersist: {
				value: 0
			},
			uEnter: {
				value: 0
			},
			uShow: {
				value: 0
			},
			tUIDepth: tUIDepth,
			uFullRes: uFullRes,
			uTeleporting: TeleportQuad.TELEPORTING,
			uHotspotTransition: HotSpotManager.uHotspotTransition
		}, !1, "HotSpotUITextBatch"), $root.add(_batch), _batch.add(_text), _copy && _batch.add(_copy);
		_arrowLeft = $gl(.4, .4, "#ff0000"), _arrowLeft.useShader(_arrowShaderLeft), _arrowLeft.x = -size.x / 2, _arrowLeft.x += size.x, _arrowLeft.x -= .2, _arrowLeft.x -= .4, _arrowLeft.x -= .2, _arrowLeft.y = -.4, _arrowLeft.z += .05, _arrowLeftProxy = $gl(.8, .8, "#ff0000"), _arrowLeftProxy.x = -size.x / 2, _arrowLeftProxy.x += size.x, _arrowLeftProxy.x -= .2, _arrowLeftProxy.x -= .8, _arrowLeftProxy.x -= .2, _arrowLeftProxy.y = -.4, _arrowLeftProxy.z += .05, _arrowLeftProxy.mesh.shader.neverRender = !0;
		let interactionMeshLeft = Platform.usingVR() ? _arrowLeftProxy.mesh : _arrowLeft.mesh;
		Interaction3D.find(World.CAMERA).add(interactionMeshLeft, arrowHover, arrowLeftClick), $root.add(_arrowLeft), $root.add(_arrowLeftProxy), _arrowRight = $gl(.4, .4, "#ff0000"), _arrowRight.useShader(_arrowShaderRight), _arrowRight.x = -size.x / 2, _arrowRight.x += size.x, _arrowRight.x -= .2, _arrowRight.y = -.4, _arrowRight.z += .05, _arrowRight.mesh.shader.set("uRight", 1), _arrowRightProxy = $gl(.8, .8, "#ff00ff"), _arrowRightProxy.x = -size.x / 2, _arrowRightProxy.x += size.x, _arrowRightProxy.x -= .2, _arrowRightProxy.y = -.4, _arrowRightProxy.z += .05, _arrowRightProxy.mesh.shader.neverRender = !0;
		let interactionMeshRight = Platform.usingVR() ? _arrowRightProxy.mesh : _arrowRight.mesh;
		if (Interaction3D.find(World.CAMERA).add(interactionMeshRight, arrowHover, arrowRightClick), _arrowLeft.mesh.renderOrder = RenderOrder.BATCH_UI, _arrowRight.mesh.renderOrder = RenderOrder.BATCH_UI, $root.add(_arrowRight), $root.add(_arrowRightProxy), _renderRetina) {
			_depthPanel = $gl(1.5 * size.x, 1.5 * size.y, "#ff0000");
			const depthShader = _this.initClass(Shader, "DepthPanel", {
				uEnter: _uEnter
			});
			_depthPanel.useShader(depthShader), _depthPanel.mesh.renderOrder = RenderOrder.BATCH_UI, $root.add(_depthPanel)
		}
		_this.flag("isReady", !0)
	}

	function arrowHover(e) {
		"over" === e.action && (PlayerControlsPathfinding.DISABLED = !0), "out" === e.action && (PlayerControlsPathfinding.DISABLED = !1), e?.mesh?.shader && e.mesh.shader.tween("uHover", "over" === e.action ? 1 : 0, 600, "easeOutCubic")
	}

	function ready() {
		return _this.wait("isReady")
	}

	function arrowLeftClick() {
		_this.events.fire(HotSpotManager.TELEPORT, _hotspot.prev)
	}

	function arrowRightClick() {
		_this.events.fire(HotSpotManager.TELEPORT, _hotspot.next)
	}!async function() {
		! function initShader() {
			const depthWrite = !0;
			_shader = _this.initClass(Shader, "HotSpotUIText", {
				uPersist: _uPersist,
				uEnter: _uEnter,
				uShow: _uShow,
				uFill: _uFill,
				uFullRes: uFullRes,
				uHotspotTransition: HotSpotManager.uHotspotTransition,
				uTeleporting: TeleportQuad.TELEPORTING,
				depthWrite: depthWrite,
				depthTest: !0
			}), _arrowShaderLeft = _this.initClass(Shader, "HotSpotUIArrow", {
				tArrow: {
					value: Utils3D.getTexture("assets/images/hotspot/arrow-ui.png")
				},
				uPersist: _uPersist,
				uEnter: _uEnter,
				uShow: _uShow,
				uFill: _uFill,
				uFullRes: uFullRes,
				tUIDepth: tUIDepth,
				uTeleporting: TeleportQuad.TELEPORTING,
				uRight: {
					value: 0
				},
				uHover: {
					value: 0
				},
				uAlpha: {
					value: 1
				},
				transparent: !0,
				depthWrite: depthWrite,
				depthTest: !0
			}), _arrowShaderRight = _this.initClass(Shader, "HotSpotUIArrow", {
				tArrow: {
					value: Utils3D.getTexture("assets/images/hotspot/arrow-ui.png")
				},
				uPersist: _uPersist,
				uEnter: _uEnter,
				uShow: _uShow,
				uFill: _uFill,
				tUIDepth: tUIDepth,
				uFullRes: uFullRes,
				uTeleporting: TeleportQuad.TELEPORTING,
				uRight: {
					value: 1
				},
				uHover: {
					value: 0
				},
				uAlpha: {
					value: 1
				},
				transparent: !0,
				depthWrite: depthWrite,
				depthTest: !0
			})
		}(), _this.group.add($root.group), _hotspot = _this.findParent("HotSpot"), await _hotspot.ready(), _this.events.sub(_hotspot.artwork, HotSpotArtwork.RESIZE, onArtworkResize), _this.startRender(loop), _this.delayedCall((() => {
			_checkDistance = !0
		}), 4e3), _renderRetina && _this.events.sub(World.NUKE, Nuke.BEFORE_POST_RENDER, retinaLoop)
	}(), this.onEnter = async function() {
		await ready(), _arrowLeft.alpha = 0, _arrowRight.alpha = 0, _copy && tween(_copy, {
			alpha: 0
		}, 500), tween(_arrowLeft, {
			alpha: 1
		}, 500, "easeOutCubic", 1e3), tween(_arrowRight, {
			alpha: 1
		}, 500, "easeOutCubic", 1100)
	}, this.onLeave = async function() {
		await ready(), tween(_arrowLeft, {
			alpha: 0
		}, 500, "easeOutCubic"), tween(_arrowRight, {
			alpha: 0
		}, 500, "easeOutCubic"), _copy && tween(_copy, {
			alpha: 1
		}, 500, "easeOutCubic", 500)
	}
})), Class((function GLUIWrapper() {
	Inherit(this, GLUIElement);
	const _this = this,
		$this = _this.element;
	_this.ready = Promise.create();
	const CC = CaptionsController.instance();
	let _captions, _audioButton, _voiceChatButton, _muteButton, _playbackSpeedButton, _playbackSpeedButtonMobile, _playbackSpeedOptions, _instructionsButton, $centerWrapper, _isInPlayState = !1,
		_animatingOut = !1,
		_playbackSpeedOptionsOpen = !1;

	function handleVoiceChatMute({
		value: value
	}) {}

	function handlePlaybackSpeedToggle() {
		_playbackSpeedOptionsOpen = !_playbackSpeedOptionsOpen, _playbackSpeedOptionsOpen ? (_playbackSpeedOptions.animateIn(), _playbackSpeedButtonMobile.toActive()) : (_playbackSpeedOptions.animateOut(), _playbackSpeedButtonMobile.toInactive())
	}
	async function animateInOnAudio() {
		const duration = GLUIWrapper.CENTER_WRAPPER_TWEEN_DURATION;
		if ($centerWrapper.tween({
				x: $centerWrapper.__x - $centerWrapper.__tX
			}, duration, "easeOutExpo"), _audioButton.wrapper.y = GLUIWrapper.ICON_PADDING() / 4, _captions.animateIn(), StyleGuide.isMobile() && !StyleGuide.isLandscape()) {
			const _audioButtonTX = _audioButton.wrapper.__x + GLUIWrapper.ICON_SIZE() / 2 + GLUIWrapper.ICON_PADDING();
			_audioButton.wrapper.tween({
				x: _audioButtonTX
			}, duration, "easeOutExpo")
		}
		_playbackSpeedOptions.wrapper.x = GLUIWrapper.CAPTION_BAR_WIDTH() - _playbackSpeedOptions.bg.width, _playbackSpeedButton.wrapper.x = GLUIWrapper.CAPTION_BAR_WIDTH() - GLUIWrapper.ICON_SIZE() - GLUIWrapper.ICON_PADDING(), await _this.wait(1e3), StyleGuide.isMobile() && !StyleGuide.isLandscape() ? _playbackSpeedButtonMobile.animateIn() : _playbackSpeedButton.animateIn()
	}
	async function onToggleAudio({
		value: audio
	}) {
		audio ? (await _this.wait(500), animateInOnAudio(), _isInPlayState = !0) : (_captions.animateOut(), await _this.wait(800), $centerWrapper.tween({
			x: $centerWrapper.__x
		}, 400, "easeOutCubic"), StyleGuide.isMobile() && !StyleGuide.isLandscape() && (_audioButton.wrapper.x = _audioButton.wrapper.__x), _audioButton.wrapper.y = _audioButton.wrapper.__y, _isInPlayState = !1)
	}

	function onHotSpotActive(isActive) {
		isActive ? _this.showHotSpotUI() : _this.hideHotSpotUI()
	}

	function handleResize() {
		const lateralPadding = StyleGuide.nonCSSLateralPadding();
		// Platform.usingVR() || (StyleGuide.isMobile() && !StyleGuide.isLandscape() ? $this.add(_voiceChatButton.element) : $centerWrapper.add(_voiceChatButton.element)),
		 $this.y = Stage.height - lateralPadding - GLUIWrapper.ICON_SIZE(), GlobalUI.instance().sponsors?.sponsors?.length && StyleGuide.windowLessThan("m") && ($this.y -= 35), $centerWrapper.x = Stage.width / 2, StyleGuide.isMobile() && !StyleGuide.isLandscape() ? ($centerWrapper.y = 0 - GLUIWrapper.CONTAINER_OFFSET(), _playbackSpeedButton.element.hide(), _playbackSpeedButtonMobile.element.show()) : (_playbackSpeedButton.element.show(), _playbackSpeedButtonMobile.element.hide(), $centerWrapper.y = 0), $centerWrapper.__x = $centerWrapper.x, $centerWrapper.__tX = GLUIWrapper.CAPTION_BAR_WIDTH() / 2 + GLUIWrapper.ICON_PADDING(), StyleGuide.isMobile() && StyleGuide.isLandscape() && ($centerWrapper.__tX = GLUIWrapper.CAPTION_BAR_WIDTH() / 2 + GLUIWrapper.ICON_PADDING() - 100), _muteButton.wrapper.x = lateralPadding, _muteButton.wrapper.__x = _muteButton.wrapper.x, _voiceChatButton.wrapper.x = -1 * GLUIWrapper.ICON_SIZE() - GLUIWrapper.ICON_PADDING(), StyleGuide.isMobile() && !StyleGuide.isLandscape() && (_voiceChatButton.wrapper.x = Stage.width - lateralPadding - GLUIWrapper.ICON_SIZE(), _playbackSpeedButtonMobile.wrapper.x = Stage.width - lateralPadding - 2 * GLUIWrapper.ICON_SIZE()), _voiceChatButton.wrapper.__x = _voiceChatButton.wrapper.x, _voiceChatButton.wrapper.__y = _voiceChatButton.wrapper.y, _audioButton.wrapper.x = GLUIWrapper.ICON_PADDING(), StyleGuide.isMobile() && !StyleGuide.isLandscape() && (_audioButton.wrapper.x = -.5 * GLUIWrapper.ICON_SIZE()), _audioButton.wrapper.__x = _audioButton.wrapper.x, _audioButton.wrapper.__y = _audioButton.wrapper.y, _captions.text.x = GLUIWrapper.CAPTION_BAR_WIDTH() / 2 + GLUIWrapper.ICON_SIZE() / 2, _captions.text.__x = _captions.text.x, StyleGuide.isMobile() && (_captions.text.x = _captions.text.__x - 10), Platform.usingVR() ? (_captions.bg.size(GLUIWrapper.CAPTION_BAR_WIDTH(), VRCaptionWrapper.DIMENSIONS.height), _captions.text.y = .5 * VRCaptionWrapper.DIMENSIONS.height, _captions.text.__y = _captions.text.y) : (_captions.element.x = GLUIWrapper.ICON_PADDING(), _captions.element.y = GLUIWrapper.ICON_PADDING() / 2, _captions.bg.size(GLUIWrapper.CAPTION_BAR_WIDTH(), GLUIWrapper.ICON_SIZE() - GLUIWrapper.ICON_PADDING() / 2), StyleGuide.isMobile() || (_captions.text.x = _captions.text.__x - .5 * GLUIWrapper.ICON_SIZE()), _captions.text.y = GLUIWrapper.ICON_SIZE() / 2, _captions.text.__y = _captions.text.y), _instructionsButton.wrapper.x = lateralPadding + GLUIWrapper.ICON_SIZE() + GLUIWrapper.ICON_PADDING(), [_audioButton, _voiceChatButton, _muteButton, _playbackSpeedButton].forEach((e => e.bg.size(GLUIWrapper.ICON_SIZE(), GLUIWrapper.ICON_SIZE()))), _isInPlayState && (_captions.updateValues(), _audioButton.wrapper.y = GLUIWrapper.ICON_PADDING() / 4, $centerWrapper.x = Stage.width / 2 - GLUIWrapper.CAPTION_BAR_WIDTH() / 2), HotSpotStore.get("audio") && animateInOnAudio()
	}

	function hidePlaybackSpeedMenu() {
		_playbackSpeedOptionsOpen && (_playbackSpeedOptions.animateOut(), _playbackSpeedOptionsOpen = !1, _playbackSpeedButton.restore(), _playbackSpeedButtonMobile.toInactive())
	}!async function() {
		$centerWrapper = $gl(), $this.add($centerWrapper), await defer(),
			function initButtons() {
				_audioButton = _this.initClass(HotSpotUIAudio), $centerWrapper.add(_audioButton.element), _playbackSpeedButton = _this.initClass(UIPlaybackSpeedButton), $centerWrapper.add(_playbackSpeedButton.element), _playbackSpeedButtonMobile = _this.initClass(PlaybackSpeedButtonMobile), $centerWrapper.add(_playbackSpeedButtonMobile), _voiceChatButton = _this.initClass(HotSpotUIVoiceChatButton), _instructionsButton = _this.initClass(UIInstructionsButton), _muteButton = UIMuteButton.instance(), $this.add(_muteButton.element)
			}(), await async function initCaptions() {
					_captions = UICaption.instance(), Platform.usingVR() || $centerWrapper.add(_captions.element);
					await _captions.ready, CC.setElement(_captions)
				}(), _playbackSpeedOptions = UIPlaybackSpeed.instance(), _playbackSpeedOptions.element.y = -55, $centerWrapper.add(_playbackSpeedOptions.element), GLUI.Stage.add($this),
				function addHandlers() {
					_this.onResize(handleResize), _this.bindState(HotSpotStore, "active", onHotSpotActive), _this.events.sub(HotSpotAudioManager.PLAY_HOTSPOT_AUDIO, onToggleAudio), _this.events.sub(VoiceChatController.TOGGLE_MUTE, handleVoiceChatMute), _this.events.sub(UIPlaybackSpeedButton.TOGGLE_SPEED_OPTIONS, handlePlaybackSpeedToggle), _this.events.sub(PlaybackSpeedButtonMobile.TOGGLE_SPEED_OPTIONS, handlePlaybackSpeedToggle), _this.events.sub(UIPlaybackSpeedOption.PLAYBACK_OPTION_CLICKED, hidePlaybackSpeedMenu)
				}(), _this.ready.resolve(), PortalUtil.isPortal && $this.hide()
	}(), this.show = function() {
		PortalUtil.isPortal || Utils.query("no-UI") || ($this.show(), _muteButton.animateIn(), _instructionsButton.animateIn())
	}, this.hide = function() {
		PortalUtil.isPortal || Utils.query("no-UI") || (_this.hideHotSpotUI(), _muteButton.animateOut(), _instructionsButton.animateOut(), hidePlaybackSpeedMenu(), _this.delayedCall((() => {
			$this.hide()
		})))
	}, this.showHotSpotUI = async function() {
		PortalUtil.isPortal || Utils.query("no-UI") || (await _this.wait((() => !_animatingOut)), await _this.wait((() => !_isInPlayState)), _voiceChatButton.animateIn(), await _this.wait(120), _audioButton.animateIn())
	}, this.hideHotSpotUI = async function() {
		PortalUtil.isPortal || Utils.query("no-UI") || (await _this.wait((() => !_animatingOut)), _animatingOut = !0, hidePlaybackSpeedMenu(), _playbackSpeedButton.animateOut(), await _this.wait(400), _captions.animateOut(), _voiceChatButton.animateOut(), _playbackSpeedButtonMobile.animateOut(), await _this.wait(80), _audioButton.animateOut(), _this.delayedCall((() => {
			_animatingOut = !1
		}), 500))
	}, this.get("audioButton", (_ => _audioButton)), this.get("captions", (_ => _captions)), this.get("voiceChatButton", (_ => _voiceChatButton)), this.get("playbackSpeedButton", (_ => _playbackSpeedButton)), this.get("playbackSpeedOptions", (_ => _playbackSpeedOptions))
}), "singleton", (_ => {
	GLUIWrapper.CENTER_WRAPPER_TWEEN_DURATION = 700, GLUIWrapper.ICON_SIZE = function() {
		let iconSize = 50;
		return Stage.width < 1100 && (iconSize = 50), iconSize = (StyleGuide.isMobile(), 60), iconSize
	}, GLUIWrapper.CONTAINER_OFFSET = function() {
		let v = 0;
		return StyleGuide.isMobile() && (v = 120), v
	}, GLUIWrapper.HOTSPOT_UI_TRANSLATE_AUDIO_Y = function(val) {
		let m = 100;
		return StyleGuide.isMobile() && (m = 100, GlobalUI.instance().sponsors?.sponsors?.length && (m += 50)), StyleGuide.isMobile() && !StyleGuide.isLandscape() && (m = 250), val * m
	}, GLUIWrapper.HOTSPOT_UI_TRANSLATE_VOICE_Y = function(val) {
		let m = 100;
		return StyleGuide.isMobile() && (m = 100, GlobalUI.instance().sponsors?.sponsors?.length && (m += 50)), val * m
	}, GLUIWrapper.ICON_PADDING = function() {
		return 5
	}, GLUIWrapper.ICON_SCALE = function() {
		return .85
	}, GLUIWrapper.CAPTION_BAR_WIDTH = function() {
		if (Platform.usingVR()) return VRCaptionWrapper.DIMENSIONS.width;
		let val = Math.min(Stage.width / 1.5, 750);
		const lateralPadding = StyleGuide.nonCSSLateralPadding();
		return Stage.width < 1300 && (val = Math.max(Stage.width / 3.5, 450)), StyleGuide.isMobile() && StyleGuide.isLandscape() && (val = Stage.width - 2 * lateralPadding - 200), StyleGuide.isMobile() && !StyleGuide.isLandscape() && (val = Stage.width - 2 * lateralPadding), Stage.width > 2300 && (val = Math.max(Stage.width / 1.7, 900)), val
	}
})), Class((function UI3DHotspotPrompt() {
	Inherit(this, UI3DPromptLayout, "UIHotspotPrompt", 1, 1);
	const _this = this,
		GW = GLUIWrapper.instance();
	!async function() {
		await _this.ready(), await GW.ready, _this.layers = await _this.layout.getAllLayers()
	}(), this.show = function() {
		_this.open(), GW.show()
	}, this.hide = function() {
		_this.close(), GW.hide()
	}, this.get("audioButton", (_ => GW.audioButton))
}), "singleton"), Class((function HotSpotUIAudio() {
	Inherit(this, GLUIElement);
	const _this = this,
		$this = _this.element;
	_this.ready = Promise.create();
	const HAM = HotSpotAudioManager.instance();
	let _visible = !1,
		_width = GLUIWrapper.ICON_SIZE(),
		_height = GLUIWrapper.ICON_SIZE(),
		_paused = !0,
		_isInteractive = !0,
		_obj = {
			value: 1
		};
	const colors = {
		inactive: new Color("#FFFFFF"),
		active: new Color("#2D2D9E")
	};
	let $wrapper, $bg, _bgShader, $pause, $play;
	async function handleVoiceChatMute({
		value: value
	}) {
		HAM.complete || (value ? (await _this.wait(900), toPlay()) : _paused || (await _this.wait(1200), toPause()))
	}

	function onToggleAudio({
		value: audio
	}) {
		audio ? (_paused = !1, toPlay()) : (_paused = !0, toPause())
	}

	function toggleLoading(bool) {
		_bgShader.tween("uLoadingTransition", +bool, 1e3, "easeOutCubic")
	}
	async function toPlay() {
		await _this.wait((() => _isInteractive)), _isInteractive = !1, tween($play, {
			alpha: 0
		}, 300, "easeOutCubic"), tween($pause, {
			alpha: 1
		}, 500, "easeOutCubic", 100), $wrapper.tween({
			scale: .78
		}, 600, "easeOutCubic"), _bgShader.tween("uTransition", 1, 800, "easeOutCubic"), toggleLoading(!1), _this.delayedCall((() => {
			_bgShader.set("uTransition", 0), _bgShader.set("uColor1", colors.active), _bgShader.set("uColor2", colors.inactive), _isInteractive = !0
		}), 800)
	}
	async function toPause() {
		await _this.wait((() => _isInteractive)), _isInteractive = !1;
		const isActive = HotSpotStore.get("active");
		tween($pause, {
			alpha: 0
		}, 300, "easeOutCubic"), tween($play, {
			alpha: 1
		}, 500, "easeOutCubic", 100), $wrapper.tween({
			scale: isActive && !HAM.complete ? .78 : .9
		}, 600, "easeOutCubic"), _bgShader.tween("uTransition", 1, 800, "easeOutCubic", 0), _this.delayedCall((() => {
			_bgShader.set("uTransition", 0), _bgShader.set("uColor1", colors.inactive), _bgShader.set("uColor2", colors.active), _isInteractive = !0
		}), 800)
	}

	function onClick(e) {
		if (VoiceChatController.instance().muted && _isInteractive) {
			if (_bgShader.tween("uHover", .6, 600, "easeOutExpo"), _paused)
				if (HAM.complete) HAM.play(), _this.events.fire(HotSpotAudioManager.TOGGLE_COMPLETE, {
					value: !1
				});
				else {
					toPlay();
					HotSpotStore.get("audio").play()
				}
			else {
				toPause();
				HotSpotStore.get("audio").pause()
			}
			_paused = !_paused
		}
	}

	function onHover(e) {
		const isActive = HotSpotStore.get("active");
		_paused && !isActive || HAM.complete;
		"over" === e.action && (PlayerControlsPathfinding.DISABLED = !0, _bgShader.tween("uHover", 1, 1e3, "easeOutExpo")), "out" === e.action && (PlayerControlsPathfinding.DISABLED = !1, _bgShader.tween("uHover", 0, 1e3, "easeOutExpo"))
	}
	$wrapper = $gl(_width, _height),
		function initBackground() {
			$bg = $gl(_width, _height, DreamColors.instance().gray800), _bgShader = _this.initClass(Shader, "HotSpotUIAudioShader", {
				uSize: {
					value: new Vector2(_width, _height)
				},
				uColor: {
					value: new Color(StyleGuide.colors.royalBlue)
				},
				uColor1: {
					value: colors.inactive
				},
				uColor2: {
					value: colors.active
				},
				uOwnAlpha: {
					value: 0
				},
				uProgress: {
					value: 0
				},
				uTransition: {
					value: 0
				},
				uLoadingTransition: {
					value: 0
				},
				uHover: {
					value: 0
				},
				transparent: !0
			}), $bg.setZ(1), $bg.useShader(_bgShader), $wrapper.add($bg), $wrapper.tween({
				scale: .9
			}, 0, "easeOutCubic")
		}(),
		function initIcon() {
			$pause = $gl(_width, _height, Assets.getPath("assets/images/hotspot/pause.png")), $play = $gl(_width, _height, Assets.getPath("assets/images/hotspot/play.png")), $pause.alpha = 0, $play.alpha = 0, $pause.setZ(2), $play.setZ(2), $wrapper.add($pause), $wrapper.add($play)
		}(), $this.add($wrapper), _this.onResize((() => {
			const size = GLUIWrapper.ICON_SIZE(),
				scale = GLUIWrapper.ICON_SCALE(),
				scaleX = .15 * scale,
				scaleY = .3 * scale;
			$pause.scaleX = scaleX, $pause.scaleY = scaleY, $pause.x = size / 2 - size * (scaleX / 2), $pause.y = size / 2 - size * (scaleY / 2), $play.scaleX = scaleX, $play.scaleY = scaleY, $play.x = size / 2 - size * (scaleX / 2), $play.y = size / 2 - size * (scaleY / 2)
		})), $this.hide(),
		function addHandlers() {
			$bg.interact(onHover, onClick), _this.events.sub(HotSpotAudioManager.PLAY_HOTSPOT_AUDIO, onToggleAudio), _this.events.sub(VoiceChatController.TOGGLE_MUTE, handleVoiceChatMute)
		}(), this.setProgress = function(p) {
			_bgShader.set("uProgress", p)
		}, this.animateIn = async function() {
			$this.show(), toggleLoading(!0), tween(_obj, {
				value: 0
			}, 500, "easeOutCubic").onUpdate((() => {
				$wrapper.y = GLUIWrapper.HOTSPOT_UI_TRANSLATE_AUDIO_Y(_obj.value)
			})), tween($play, {
				alpha: 1
			}, 600, "easeOutCubic"), _bgShader.tween("uOwnAlpha", 1, 600, "easeOutCubic"), _visible = !0
		}, this.animateOut = async function() {
			tween(_obj, {
				value: 1
			}, 300, "easeOutCubic").onUpdate((() => {
				$wrapper.y = GLUIWrapper.HOTSPOT_UI_TRANSLATE_AUDIO_Y(_obj.value)
			})), $play.tween({
				alpha: 0
			}, 400, "easeOutCubic"), $pause.tween({
				alpha: 0
			}, 400, "easeOutCubic"), _bgShader.tween("uOwnAlpha", 0, 400, "easeOutCubic"), _this.setProgress(0), _visible = !1, _this.delayedCall((() => {
				$this.hide()
			}), 300)
		}, this.get("wrapper", (_ => $wrapper)), this.get("bg", (_ => $bg))
})), Class((function HotSpotUICaptions(args) {
	Inherit(this, UI3D);
	const _this = this;
	let $this, _width = HotSpotUI.PANEL_LEFT_MAX_WIDTH;
	_this.ready = Promise.create();
	let $captions, _shader, _visible = !1,
		_caption = "";
	!async function() {
		_this.create(_width, 120), $this = _this.root, await async function initText() {
			$captions = $glText(_caption, "Manrope-SemiBold", 25, {
				width: _width,
				align: "left",
				letterSpacing: -.04,
				wordBreak: !1,
				langBreak: !1,
				color: 16777215
			}), _shader = _this.initClass(Shader, "HotSpotUICaptionsShader", {
				uOwnAlpha: {
					value: 0
				},
				uColor: {
					value: new Color("#fff")
				},
				uTransition: {
					value: 1,
					ignoreUIL: !0
				},
				uWordCount: {
					value: 0,
					ignoreUIL: !0
				},
				uLetterCount: {
					value: 0,
					ignoreUIL: !0
				},
				uLineCount: {
					value: 0,
					ignoreUIL: !0
				},
				uByWord: {
					value: 0,
					ignoreUIL: !0
				},
				uBoundingMin: {
					value: new Vector3
				},
				uBoundingMax: {
					value: new Vector3
				},
				uDimensions: {
					value: new Vector2
				},
				uOverflows: {
					value: 0
				},
				uCaptionProgress: {
					value: 0
				},
				uElapsedTime: {
					value: 0
				},
				transparent: !0
			}), $captions.useShader(_shader), $captions.setZ(2), $this.add($captions)
		}(), _this.ready.resolve(), _this.hide(), $captions.hide(), _this.flag("hidden", !0), Global.PLAYGROUND && _this.animateIn()
	}(), this.setText = async function(text) {
		_caption !== text && (_caption = text, _this.flag("captionsDisabled") || await _this.wait("hidden"), $captions.setText(_caption))
	}, this.updateUniforms = async function() {
		await $captions.text.ready(), await $captions.loaded(), _this.setCaptionProgress(0), _shader.set("uBoundingMin", (new Vector3).copy($captions.dimensions.min)), _shader.set("uBoundingMax", (new Vector3).copy($captions.dimensions.max)), _shader.set("uDimensions", new Vector2($captions.dimensions.width, $captions.dimensions.height)), _shader.set("uDimensions", new Vector2($captions.dimensions.width, $captions.dimensions.height)), _shader.set("uOverflows", +(_width < $captions.dimensions.width)), _shader.set("uWordCount", $captions.mesh.geometry.wordCount), _shader.set("uLetterCount", $captions.mesh.geometry.letterCount), _shader.set("uLineCount", $captions.mesh.geometry.lineCount)
	}, this.setCaptionProgress = function(p) {
		_shader.set("uCaptionProgress", p)
	}, this.update = function(_artworkMesh) {
		if (!_visible) return;
		let UIOffset = HotSpotUI.getOffsetLeft(_artworkMesh.scale);
		_this.parent.group.position.x = _artworkMesh.position.x - _artworkMesh.scale.x - 2 - 2 * UIOffset, _this.parent.group.position.y = _artworkMesh.position.y - .2, _this.parent.group.position.z = _artworkMesh.position.z
	}, this.animateCaptionIn = async function() {
		_this.flag("hidden") && (await defer(), _this.flag("hidden", !1), _this.updateUniforms(), await _shader.tween("uOwnAlpha", 1, 400, "easeOutCubic").promise())
	}, this.animateCaptionOut = async function() {
		_this.flag("hidden") || (await _shader.tween("uOwnAlpha", 0, 400, "easeOutCubic").promise(), _this.setCaptionProgress(0), _this.flag("hidden", !0))
	}, this.animateIn = function() {
		_visible = !0, $captions.show(), _this.show()
	}, this.animateOut = function() {
		_this.setText(""), _visible = !1, $captions.hide(), _this.animateCaptionOut(), _this.hide()
	}, this.get("shader", (_ => _shader))
})), Class((function UIInstructionsButton() {
	Inherit(this, GLUIElement);
	const _this = this,
		$this = _this.element;
	let $wrapper, $qm, $bg, _bgShader, _width = GLUIWrapper.ICON_SIZE(),
		_height = GLUIWrapper.ICON_SIZE(),
		_obj = {
			value: 1
		},
		_visible = !0;

	function onFAQButtonVisChange(visible) {
		visible ? _this.animateIn() : _this.animateOut()
	}

	function onClick(e) {
		Storage.set("tutorials", null), DreamUI.Tutorial.instance().showTutorial()
	}

	function onHover(e) {
		"over" === e.action && (PlayerControlsPathfinding.DISABLED = !0, _bgShader.tween("uHover", 1, 1e3, "easeOutExpo")), "out" === e.action && (PlayerControlsPathfinding.DISABLED = !1, _bgShader.tween("uHover", 0, 1e3, "easeOutExpo"))
	}!async function() {
		$wrapper = $gl(_width, _height),
			function initBackground() {
				$bg = $gl(_width, _height, DreamColors.instance().gray600), _bgShader = _this.initClass(Shader, "UIInstructionsButtonShader", {
					uColor: {
						value: new Color(DreamColors.instance().gray600)
					},
					uOwnAlpha: {
						value: 0
					},
					uHover: {
						value: 0
					},
					transparent: !0
				}), $bg.setZ(1), $bg.useShader(_bgShader), $wrapper.add($bg), $wrapper.tween({
					scale: .9
				}, 0, "easeOutCubic")
			}(), await async function initQuestionMark() {
					let {
						family: family,
						size: size,
						options: options
					} = StyleGuide.getStyle("p", 600), s = 1.2 * size;
					$qm = $glText("?", family, s, {
						...options,
						width: .25 * GLUIWrapper.ICON_SIZE(),
						align: "center",
						color: StyleGuide.colors.white
					}), await $qm.text.ready, $qm.alpha = 0, $qm.x = _width / 2, $qm.y = _height / 2 - .65 * s, $qm.setZ(2), $bg.add($qm)
				}(),
				function addEvents() {
					if (PortalUtil.isPortal || Utils.query("no-UI")) return;
					_this.bindState(UIStore.state, "doShowFAQButton", onFAQButtonVisChange)
				}(), $this.add($wrapper), _this.onResize((() => {
					StyleGuide.isMobile() && _visible ? ($this.hide(), _visible = !1) : _visible || ($this.show(), _visible = !0)
				})), (Utils.query("spawnDebug") || Utils.query("skip")) && _this.animateIn(!0),
				function addHandlers() {
					$bg.interact(onHover, onClick)
				}()
	}(), this.animateIn = function(skip = !1) {
		(UIStore.state.doShowFAQButton && !StyleGuide.isMobile() || skip) && ($qm.tween({
			alpha: 1
		}, 500, "easeOutCubic"), tween(_obj, {
			value: 0
		}, 500, "easeOutCubic").onUpdate((() => {
			$wrapper.y = 100 * _obj.value
		})), _bgShader.tween("uOwnAlpha", .7, 600, "easeOutCubic"), _visible = !0)
	}, this.animateOut = async function() {
		_bgShader.tween("uOwnAlpha", 0, 400, "easeOutCubic", 400), $qm.tween({
			alpha: 0
		}, 500, "easeOutCubic"), tween(_obj, {
			value: 1
		}, 500, "easeOutCubic").onUpdate((() => {
			$wrapper.y = 100 * _obj.value
		})), _visible = !1
	}, this.get("wrapper", (_ => $wrapper)), this.get("bg", (_ => $bg))
}), "singleton", (_ => {})), Class((function UIMuteButton() {
	Inherit(this, GLUIElement), Inherit(this, StateComponent);
	const _this = this,
		$this = _this.element;
	let $wrapper, $bg, _bgShader, _width = GLUIWrapper.ICON_SIZE(),
		_height = GLUIWrapper.ICON_SIZE(),
		_obj = {
			value: 1
		},
		_visible = !0,
		_muted = !1;

	function onClick(e) {
		VoiceChatController.instance().muted && (_this.events.fire(AudioController.TOGGLE_MUTE, {
			value: !_muted
		}), UIStore.commit("setShouldMuteFromUserSettings", !UIStore.get("shouldMuteFromUserSettings")))
	}

	function onHover(e) {
		"over" === e.action && (PlayerControlsPathfinding.DISABLED = !0, _bgShader.tween("uHover", 1, 1e3, "easeOutExpo")), "out" === e.action && (PlayerControlsPathfinding.DISABLED = !1, _bgShader.tween("uHover", 0, 1e3, "easeOutExpo"))
	}
	$wrapper = $gl(_width, _height),
		function initBackground() {
			$bg = $gl(_width, _height, DreamColors.instance().gray600), _bgShader = _this.initClass(Shader, "UIMuteButtonShader", {
				uColor: {
					value: new Color(DreamColors.instance().gray600)
				},
				uOwnAlpha: {
					value: 0
				},
				uTransition: {
					value: 0
				},
				uAmplitude: {
					value: .3
				},
				uHover: {
					value: 0
				},
				transparent: !0
			}), $bg.setZ(1), $bg.useShader(_bgShader), $wrapper.add($bg), $wrapper.tween({
				scale: .9
			}, 0, "easeOutCubic")
		}(), $this.add($wrapper), _this.onResize((() => {
			Device.mobile && _visible && $this.hide()
		})),
		function addHandlers() {
			$bg.interact(onHover, onClick), _this.events.sub(AudioController.TOGGLE_MUTE, (({
				value: value
			}) => {
				let amp = value ? .1 : .3;
				_bgShader.tween("uAmplitude", amp, 600, "easeOutCubic"), _muted = value
			}))
		}(), this.animateIn = async function() {
			tween(_obj, {
				value: 0
			}, 500, "easeOutCubic").onUpdate((() => {
				$wrapper.y = 100 * _obj.value
			})), _bgShader.tween("uOwnAlpha", .4, 600, "easeOutCubic"), _visible = !0
		}, this.animateOut = async function() {
			_bgShader.tween("uOwnAlpha", 0, 400, "easeOutCubic", 400), tween(_obj, {
				value: 1
			}, 500, "easeOutCubic").onUpdate((() => {
				$wrapper.y = 100 * _obj.value
			})), _visible = !1
		}, this.get("wrapper", (_ => $wrapper)), this.get("bg", (_ => $bg)), this.get("muted", (_ => _muted))
}), "singleton", (_ => {})), Class((function UIPlaybackSpeed() {
	Inherit(this, GLUIElement);
	const _this = this,
		$this = _this.element;
	let $wrapper, $bg, $optionContainer, _bgShader, _width = .75 * GLUIWrapper.CAPTION_BAR_WIDTH(),
		BGWIDTH = 2;
	const SPEEDS = ["1.0", "1.5", "2.0", "2.5"],
		SPEED_OPTIONS = [];
	let _prevSpeedIndex = 0,
		_delayedHideCall = null;
	const AC = AudioController.instance();

	function handleSpeedOptionClicked(speed, buttonIndex) {
		_prevSpeedIndex !== buttonIndex && (SPEED_OPTIONS[_prevSpeedIndex].applyInActiveState?.(), SPEED_OPTIONS[buttonIndex].applyActiveState?.(), _prevSpeedIndex = buttonIndex, HotSpotAudioManager.instance().currentTrack.playbackRate = speed, AC.setPlaybackSpeed(speed))
	}
	$wrapper = $gl(_width, 1e3), $this.add($wrapper),
		function initPlaybackSpeeds() {
			const iconWidth = GLUIWrapper.ICON_SIZE() - 10,
				iconHeight = .85 * (GLUIWrapper.ICON_SIZE() - 10);
			let totalWidth = 0;
			$optionContainer = $gl(), $wrapper.add($optionContainer), SPEEDS.forEach(((speed, i) => {
				SPEED_OPTIONS[i] = _this.initClass(UIPlaybackSpeedOption, speed, iconWidth, iconHeight, i, handleSpeedOptionClicked), SPEED_OPTIONS[i].wrapper.setZ(1), $optionContainer.add(SPEED_OPTIONS[i].element), SPEED_OPTIONS[i].element.x = totalWidth, totalWidth += iconWidth
			})), $optionContainer.width = totalWidth, $optionContainer.height = iconHeight, GLUIWrapper.ICON_PADDING();
			const size = new Vector2(1.05 * totalWidth, 1.1 * iconHeight);
			$bg = $gl(size.x, size.y, StyleGuide.colors.royalBlue), _bgShader = _this.initClass(Shader, "UIPlaybackSpeedShader", {
				uSize: {
					value: new Vector2(size.x, size.y)
				},
				uColor: {
					value: new Color(0, 0, 0)
				},
				uScale: {
					value: 1
				},
				uOwnAlpha: {
					value: 0
				},
				uTransition: {
					value: 0
				},
				uBorderRadius: {
					value: 23
				},
				transparent: !0
			}), $bg.useShader(_bgShader), $bg.setZ(0), $wrapper.add($bg), BGWIDTH = size.x, $optionContainer.x = .5 * (size.x - totalWidth), $optionContainer.y = .5 * (size.y - iconHeight)
		}(), SPEED_OPTIONS[0].applyActiveState(), _this.animateIn = function animateIn() {
			$this.show(), _delayedHideCall && clearTimeout(_delayedHideCall), _bgShader.tween("uOwnAlpha", 1, 600, "easeOutCubic"), SPEED_OPTIONS.forEach(((option, index) => {
				option.animateIn(10 * index)
			}))
		}, _this.animateOut = function animateOut() {
			_bgShader.tween("uOwnAlpha", 0, 300, "easeOutCubic"), SPEED_OPTIONS.forEach(((option, index) => {
				option.animateOut()
			})), _delayedHideCall = _this.delayedCall((_ => {
				$this.hide()
			}), 310)
		}, _this.show = function show() {}, _this.hide = function hide() {}, _this.width = _width, _this.height = 1e3, this.get("bg", (_ => $bg)), this.get("wrapper", (_ => $wrapper))
}), "singleton", (_ => {
	UIPlaybackSpeed.AUDIO_SPEED_APPLIED = "uiaudiospeedapplied"
})), Class((function UIPlaybackSpeedOption(_speed = 1, __width, __height, index, clickCallback) {
	Inherit(this, GLUIElement);
	const _this = this,
		$this = _this.element;
	let $wrapper, $bg, $speedLabel, _bgShader, _visible = !1,
		_width = __width || GLUIWrapper.ICON_SIZE(),
		_height = __height || GLUIWrapper.ICON_SIZE(),
		_isCurrentPlaybackSpeed = !1,
		_hideDelayedCall = null;
	const colors = {
			inactive: new Color(0, 0, 0),
			active: new Color(1, 1, 1)
		},
		textColors = {
			active: new Color(0, 0, 0),
			inactive: new Color(1, 1, 1)
		};

	function onClick(e) {
		clickCallback(parseFloat(_speed), index), _this.events.fire(UIPlaybackSpeedOption.PLAYBACK_OPTION_CLICKED, _speed)
	}

	function onHover(e) {
		HotSpotStore.get("active");
		if ("over" === e.action) {
			if (PlayerControlsPathfinding.DISABLED = !0, _isCurrentPlaybackSpeed) return;
			_bgShader.tween("uHover", 1, 1e3, "easeOutExpo"), $speedLabel.text.tweenColor(textColors.active, 300, "linear")
		}
		if ("out" === e.action) {
			if (PlayerControlsPathfinding.DISABLED = !1, _isCurrentPlaybackSpeed) return;
			_bgShader.tween("uHover", 0, 1e3, "easeOutExpo"), $speedLabel.text.tweenColor(textColors.inactive, 300, "linear")
		}
	}
	$wrapper = $gl(_width, _height), $this.add($wrapper),
		function initBackground() {
			$bg = $gl(_width, _height, DreamColors.instance().gray800), _bgShader = _this.initClass(Shader, "UIPlaybackSpeedOptionShader", {
				uSize: {
					value: new Vector2(_width, _height)
				},
				uScale: {
					value: 1
				},
				uBorderRadius: {
					value: 23
				},
				uColor: {
					value: colors.inactive
				},
				uColor1: {
					value: colors.inactive
				},
				uColor2: {
					value: colors.active
				},
				uOwnAlpha: {
					value: 0
				},
				uProgress: {
					value: 0
				},
				uTransition: {
					value: 1
				},
				uLoadingTransition: {
					value: 1
				},
				uHover: {
					value: 0
				},
				transparent: !0
			}), $bg.setZ(1), $bg.useShader(_bgShader), $wrapper.add($bg)
		}(),
		function initIcon() {
			$speedLabel = $glText(`${_speed}x`, "Manrope-SemiBold", 20, {
				width: _width,
				align: "center",
				color: 16777215
			}), $speedLabel.setZ(2), $wrapper.add($speedLabel)
		}(), _this.onResize((async () => {
			await $speedLabel.text.ready(), await $speedLabel.loaded(), await defer();
			const textSize = $speedLabel.dimensions,
				scale = GLUIWrapper.ICON_SCALE();
			$wrapper.scale = .9, $speedLabel.scale = scale, $speedLabel.x = _width / 2, $speedLabel.y = _height / 2 - .75 * textSize.height
		})), $this.hide(), _bgShader.set("uOwnAlpha", 0), $wrapper.alpha = 0, $speedLabel.alpha = 0,
		function addHandlers() {
			$bg.interact(onHover, onClick)
		}(), this.animateIn = async function(delay = 0) {
			$this.show(), _hideDelayedCall && clearTimeout(_hideDelayedCall), _bgShader.tween("uOwnAlpha", 1, 600, "easeOutCubic", delay), tween($wrapper, {
				alpha: 1
			}, 600, "easeOutCubic", delay), tween($speedLabel, {
				alpha: 1
			}, 600, "easeOutCubic", delay), _visible = !0
		}, this.animateOut = async function() {
			_bgShader.tween("uOwnAlpha", 0, 300, "easeOutCubic"), tween($wrapper, {
				alpha: 0
			}, 300, "easeOutCubic"), tween($speedLabel, {
				alpha: 0
			}, 300, "easeOutCubic"), _visible = !1, _hideDelayedCall = _this.delayedCall((() => {
				$this.hide()
			}), 310)
		}, _this.applyActiveState = function applyActiveState() {
			_isCurrentPlaybackSpeed = !0, _bgShader.tween("uHover", 1, 1e3, "easeOutExpo"), $speedLabel.text.tweenColor(textColors.active, 300, "linear")
		}, _this.applyInActiveState = function applyInActiveState() {
			_isCurrentPlaybackSpeed = !1, _bgShader.tween("uHover", 0, 1e3, "easeOutExpo"), $speedLabel.text.tweenColor(textColors.inactive, 300, "linear")
		}, this.get("wrapper", (_ => $wrapper)), this.get("bg", (_ => $bg))
}), (_ => {
	UIPlaybackSpeedOption.PLAYBACK_OPTION_CLICKED = "uiplaybackspeedoptionplaybackoptionclicked"
})), Class((function UIPlaybackSpeedButton() {
	Inherit(this, GLUIElement);
	const _this = this,
		$this = _this.element;
	_this.ready = Promise.create();
	let _visible = !1,
		_width = GLUIWrapper.ICON_SIZE(),
		_height = GLUIWrapper.ICON_SIZE(),
		_isInteractive = !0;
	const colors = {
		inactive: new Color(StyleGuide.colors.royalBlue),
		active: new Color("#2D2D9E")
	};
	let $wrapper, $bg, $currentSpeed, $underScore, _bgShader, _underscoreShader;

	function onClick(e) {
		_isInteractive && (_isInteractive = !1, _bgShader.tween("uHover", .6, 600, "easeOutExpo"), _this.events.fire(UIPlaybackSpeedButton.TOGGLE_SPEED_OPTIONS))
	}

	function onHover(e) {
		HotSpotStore.get("active");
		!1 !== _isInteractive && ("over" === e.action && (PlayerControlsPathfinding.DISABLED = !0, tween($wrapper, {
			scale: .85
		}, 1e3, "easeOutExpo"), _bgShader.tween("uHover", 1, 1e3, "easeOutExpo"), _underscoreShader.tween("uTransition", 1, 1e3, "easeOutExpo")), "out" === e.action && (PlayerControlsPathfinding.DISABLED = !1, tween($wrapper, {
			scale: .75
		}, 1e3, "easeOutExpo"), _bgShader.tween("uHover", 0, 1e3, "easeOutExpo"), _underscoreShader.tween("uTransition", 0, 1e3, "easeOutExpo")))
	}
	async function handlePlaybackSpeedUpdate(speed) {
		await tween($currentSpeed, {
			alpha: 0
		}, 0, "easeOutExpo").promise(), $currentSpeed.setText(`${speed}x`), tween($currentSpeed, {
			alpha: 1
		}, 800, "easeOutExpo")
	}
	$wrapper = $gl(_width, _height),
		function initBackground() {
			$bg = $gl(_width, _height, DreamColors.instance().gray800), _bgShader = _this.initClass(Shader, "UIPlaybackSpeedButtonShader", {
				uSize: {
					value: new Vector2(_width, _height)
				},
				uColor: {
					value: new Color(StyleGuide.colors.royalBlue)
				},
				uColor1: {
					value: colors.inactive
				},
				uColor2: {
					value: colors.active
				},
				uOwnAlpha: {
					value: 0
				},
				uProgress: {
					value: 0
				},
				uTransition: {
					value: 1
				},
				uLoadingTransition: {
					value: 1
				},
				uHover: {
					value: 0
				},
				transparent: !0
			}), $bg.setZ(1), $bg.useShader(_bgShader), $wrapper.add($bg)
		}(),
		function initIcon() {
			$currentSpeed = $glText("1.0x", "Manrope-SemiBold", 25, {
				width: _width,
				align: "center",
				color: 16777215
			}), $currentSpeed.setZ(2), $wrapper.add($currentSpeed), $underScore = $gl(20, 2, DreamColors.instance().gray800), _underscoreShader = _this.initClass(Shader, "SpeedButtonTextUnderscoreShader", {
				uColor: {
					value: new Color(1, 1, 1)
				},
				uTransition: {
					value: 0
				},
				transparent: !0
			}), $underScore.useShader(_underscoreShader), $underScore.setZ(2), $wrapper.add($underScore)
		}(), $this.add($wrapper), _this.onResize((async () => {
			await $currentSpeed.text.ready(), await $currentSpeed.loaded(), await defer();
			const size = GLUIWrapper.ICON_SIZE(),
				textSize = $currentSpeed.dimensions,
				scale = .9 * GLUIWrapper.ICON_SCALE(),
				scaleX = .15 * scale,
				scaleY = .3 * scale;
			$wrapper.scale = .75, $currentSpeed.scale = scale, $currentSpeed.x = size / 2 - size * (scaleX / 2) + .25 * textSize.height, $currentSpeed.y = size / 2 - size * (scaleY / 2) - .25 * textSize.height, $underScore.width = textSize.width - 10.5, $underScore.x = $currentSpeed.x - .5 * (textSize.width - 10.5), $underScore.y = $currentSpeed.y + textSize.height + .25 * textSize.height
		})), $this.hide(),
		function addHandlers() {
			$bg.interact(onHover, onClick), _this.events.sub(UIPlaybackSpeedOption.PLAYBACK_OPTION_CLICKED, handlePlaybackSpeedUpdate)
		}(), this.animateIn = async function() {
			$this.show(), _bgShader.tween("uOwnAlpha", 1, 600, "easeOutCubic"), _underscoreShader.tween("uAlpha", 1, 600, "easeOutCubic"), tween($wrapper, {
				alpha: 1
			}, 600, "easeOutCuboc"), _visible = !0
		}, this.animateOut = async function() {
			_bgShader.tween("uOwnAlpha", 0, 300, "easeOutCubic"), _underscoreShader.tween("uAlpha", 0, 300, "easeOutCubic"), tween($wrapper, {
				alpha: 0
			}, 300, "easeOutCuboc"), _visible = !1, _this.delayedCall((() => {
				$this.hide()
			}), 400)
		}, this.restore = function restore() {
			_isInteractive = !0, tween($wrapper, {
				scale: .75
			}, 1e3, "easeOutExpo"), _underscoreShader.tween("uTransition", 0, 1e3, "easeOutExpo")
		}, this.get("wrapper", (_ => $wrapper)), this.get("bg", (_ => $bg))
}), "singleton", (_ => {
	UIPlaybackSpeedButton.TOGGLE_SPEED_OPTIONS = "uiplaybackspeedbuttontogglespeedoptions"
})), Class((function PlaybackSpeedButtonMobile() {
	Inherit(this, GLUIElement), Inherit(this, StateComponent);
	const _this = this,
		$this = _this.element;
	let $wrapper, $bg, _bgShader, $icon, $purpleIcon, $currentSpeed, $underScore, _underscoreShader, _visible = !1,
		_obj = {
			value: 1
		},
		_width = GLUIWrapper.ICON_SIZE(),
		_height = GLUIWrapper.ICON_SIZE(),
		_state = "INACTIVE";
	const colors = {
		active: new Color(StyleGuide.colors.royalBlue),
		inactive: new Color(1, 1, 1)
	};

	function toInactive() {
		_bgShader.tween("uTransition", 0, 800, "easeOutCubic"), "ACTIVE" === _state && ($purpleIcon.tween({
			alpha: 0
		}, 600, "easeOutCubic"), $icon.tween({
			alpha: 1
		}, 600, "easeOutCubic"), $currentSpeed.text.setColor(colors.inactive)), _state = "INACTIVE"
	}

	function onClick(e) {
		_this.events.fire(PlaybackSpeedButtonMobile.TOGGLE_SPEED_OPTIONS)
	}

	function onHover(e) {
		if ("over" === e.action) {
			if (PlayerControlsPathfinding.DISABLED = !0, StyleGuide.isMobile() && !Platform.usingVR()) return;
			_bgShader.tween("uHover", 1, 1e3, "easeOutExpo")
		}
		if ("out" === e.action) {
			if (PlayerControlsPathfinding.DISABLED = !1, StyleGuide.isMobile() && !Platform.usingVR()) return;
			_bgShader.tween("uHover", 0, 1e3, "easeOutExpo")
		}
	}
	async function handlePlaybackSpeedUpdate(speed) {
		$currentSpeed.setText(`${speed}x`)
	}!async function() {
		$wrapper = $gl(_width, _height),
			function initBackground() {
				$bg = $gl(_width, _height, "#FFFFFF"), _bgShader = _this.initClass(Shader, "PlaybackSpeedButtonMobileShader", {
					uColor1: {
						value: colors.active
					},
					uColor2: {
						value: colors.inactive
					},
					uOwnAlpha: {
						value: 0
					},
					uTransition: {
						value: 0
					},
					uHover: {
						value: 0
					},
					uLoadingTransition: {
						value: 0
					},
					transparent: !0
				}), $bg.setZ(1), $bg.useShader(_bgShader), $wrapper.add($bg), $wrapper.tween({
					scale: .9
				}, 0, "easeOutCubic")
			}(),
			function initIcon() {
				$icon = $gl(_width, _height, null), $icon.setZ(2), $icon.alpha = 1, $purpleIcon = $gl(_width, _height, null), $purpleIcon.setZ(2), $purpleIcon.alpha = 1, $wrapper.add($icon), $wrapper.add($purpleIcon), $currentSpeed = $glText("1.0x", "Manrope-SemiBold", 25, {
					width: _width,
					align: "center",
					color: 16777215
				}), $currentSpeed.setZ(2), $wrapper.add($currentSpeed), $underScore = $gl(20, 2, DreamColors.instance().gray800), _underscoreShader = _this.initClass(Shader, "SpeedButtonTextUnderscoreShader", {
					uColor: {
						value: new Color(1, 1, 1)
					},
					uTransition: {
						value: 0
					},
					transparent: !0
				}), $underScore.useShader(_underscoreShader), $underScore.setZ(2)
			}(), $this.add($wrapper),
			function addHandlers() {
				$bg.interact(onHover, onClick), _this.events.sub(UIPlaybackSpeedOption.PLAYBACK_OPTION_CLICKED, handlePlaybackSpeedUpdate)
			}(), _this.onResize((async () => {
				await $currentSpeed.text.ready(), await $currentSpeed.loaded(), await defer();
				const size = GLUIWrapper.ICON_SIZE(),
					scale = GLUIWrapper.ICON_SCALE();
				const scaleX = .35 * scale,
					scaleY = .35 * scale,
					textSize = $currentSpeed.dimensions;
				$icon.scaleX = scaleX, $icon.scaleY = scaleY, $icon.x = size / 2 - size * (scaleX / 2) - .5, $icon.y = size / 2 - size * (scaleY / 2) - .25, $purpleIcon.scaleX = scaleX, $purpleIcon.scaleY = scaleY, $purpleIcon.x = $icon.x, $purpleIcon.y = $icon.y, $currentSpeed.scale = .75 * GLUIWrapper.ICON_SCALE(), $currentSpeed.x = size / 2, $currentSpeed.y = size / 2 - .5 * textSize.height, $underScore.width = textSize.width - 10.5, $underScore.x = $currentSpeed.x - .5 * (textSize.width - 10.5), $underScore.y = $currentSpeed.y + textSize.height + .25 * textSize.height
			})), $this.hide(), _this.flag("interactive", !0)
	}(), this.animateIn = async function() {
		"ACTIVE" !== _state && (await _this.wait((() => !_this.flag("animatingOut"))), $this.show(), $icon.tween({
			alpha: 1
		}, 400, "easeOutCubic"), tween(_obj, {
			value: 0
		}, 500, "easeOutExpo").onUpdate((() => {
			$wrapper.y = GLUIWrapper.HOTSPOT_UI_TRANSLATE_VOICE_Y(_obj.value)
		})), _bgShader.tween("uOwnAlpha", 1, 600, "easeOutCubic"), _visible = !0)
	}, this.animateOut = function() {
		_this.flag("animatingOut", !0), "ACTIVE" === _state && toInactive(), _bgShader.tween("uOwnAlpha", 0, 400, "easeOutCubic", 400), $icon.tween({
			alpha: 0
		}, 400, "easeOutCubic"), $purpleIcon.tween({
			alpha: 0
		}, 400, "easeOutCubic"), tween(_obj, {
			value: 1
		}, 300, "easeOutExpo").onUpdate((() => {
			$wrapper.y = GLUIWrapper.HOTSPOT_UI_TRANSLATE_VOICE_Y(_obj.value)
		})), _visible = !1, _this.delayedCall((() => {
			! function prepareAnimateIn() {
				$icon.alpha = 0, $purpleIcon.alpha = 0, _state = "INACTIVE"
			}(), $this.hide(), _this.flag("animatingOut", !1)
		}), 400)
	}, this.get("wrapper", (_ => $wrapper)), this.get("bg", (_ => $bg)), this.toInactive = toInactive, this.toActive = function toActive() {
		_state = "ACTIVE", _this.flag("interactive", !1), _bgShader.tween("uTransition", 1, 800, "easeOutCubic"), $icon.tween({
			alpha: 0
		}, 600, "easeOutCubic"), $purpleIcon.tween({
			alpha: 1
		}, 600, "easeOutCubic"), $currentSpeed.text.setColor(colors.active)
	}
}), (_ => {
	PlaybackSpeedButtonMobile.TOGGLE_SPEED_OPTIONS = "playbackspeedbuttonmobiletogglespeedoptions"
})), Class((function HotSpotUIVoiceChatButton() {
	Inherit(this, GLUIElement), Inherit(this, StateComponent);
	const _this = this,
		$this = _this.element;
	let $wrapper, $bg, _bgShader, $mic, $purpleMic, _visible = !1,
		_obj = {
			value: 1
		};
	VoiceChatController.instance();
	let $text, _width = GLUIWrapper.ICON_SIZE(),
		_height = GLUIWrapper.ICON_SIZE(),
		_state = "INACTIVE";
	const colors = {
			inactive: new Color(StyleGuide.colors.royalBlue),
			muted: new Color(StyleGuide.colors.royalBlue),
			active: new Color("#FFFFFF")
		},
		text = {
			muted: Device.mobile ? "Tap to Chat" : "Click to Chat",
			active: "Chat Active"
		};

	function wrapWithPermissions(fn, ...args) {
		return fn(...args)
	}

	function handleNonAutoJoinEnter() {
		_state = "ENTER_NON_AUTOJOIN", toMuted()
	}

	function handleVoiceChatConnect({
		value: value
	}) {
		value ? Tests.autoJoinChatOnEnterHotspot() ? toMuted() : toActive() : toInactive()
	}

	function handleVoiceChatMute({
		value: value
	}) {
		value ? toMuted() : toActive()
	}

	function handleVoiceChatConnecting() {
		_state = "CONNECTING", toggleLoading(!0)
	}

	function handleVoiceChatError({
		message: message
	}) {
		toInactive()
	}

	function toggleLoading(bool) {
		_bgShader.tween("uLoadingTransition", +bool, 1e3, "easeOutCubic")
	}
	async function toActive() {
		_state = "ACTIVE", $text.tween({
			alpha: 0,
			y: $text.__y + 20
		}, 600, "easeOutQuint", 300), await _this.wait(900), $text.text.setText(text.active), await _this.wait(250), HotSpotStore.get("active") && (toggleLoading(!1), _this.flag("interactive", !1), _bgShader.tween("uTransition", 1, 800, "easeOutCubic"), $text.tween({
			alpha: 1,
			y: $text.__y
		}, 800, "easeOutQuint"), $mic.tween({
			alpha: 0
		}, 600, "easeOutCubic"), $purpleMic.tween({
			alpha: 1
		}, 600, "easeOutCubic"), _this.delayedCall((() => {
			_this.flag("canPulse", !0), _bgShader.set("uTransition", 0), _bgShader.set("uLoadingTransition", 0), _bgShader.set("uColor1", colors.active), _bgShader.set("uColor2", colors.muted), _this.flag("interactive", !0)
		}), 1500))
	}
	async function toMuted() {
		HotSpotStore.get("active") && (_this.flag("canPulse", !1), "ACTIVE" === _state && ($text.tween({
			alpha: 0,
			y: $text.__y + 20
		}, 600, "easeOutQuint", 300), await _this.wait(900), $text.text.setText(text.muted)), "ACTIVE" === _state && ($purpleMic.tween({
			alpha: 0
		}, 600, "easeOutCubic"), $mic.tween({
			alpha: 1
		}, 600, "easeOutCubic")), _state = "ENTER_NON_AUTOJOIN" === _state ? "INACTIVE" : "MUTED", toggleLoading(!1), _this.flag("interactive", !1), _bgShader.tween("uTransition", 1, 800, "easeOutCubic"), $text.tween({
			alpha: 1,
			y: $text.__y
		}, 800, "easeOutQuint"), _this.delayedCall((() => {
			_bgShader.set("uTransition", 0), _bgShader.set("uLoadingTransition", 0), _bgShader.set("uColor1", colors.muted), _bgShader.set("uColor2", colors.active), _this.flag("interactive", !0)
		}), 1500))
	}

	function toInactive() {
		"MUTED" === _state && _bgShader.set("uColor2", colors.inactive), _this.flag("canPulse", !1), $text.tween({
			alpha: 0,
			y: $text.__y + 20
		}, 800, "easeOutQuint"), _bgShader.tween("uTransition", 1, 800, "easeOutCubic"), "ACTIVE" === _state && ($purpleMic.tween({
			alpha: 0
		}, 600, "easeOutCubic"), $mic.tween({
			alpha: 1
		}, 600, "easeOutCubic")), _state = "INACTIVE", _this.delayedCall((() => {
			_bgShader.set("uTransition", 0), _bgShader.set("uLoadingTransition", 0), _bgShader.set("uColor1", colors.inactive), _bgShader.set("uColor2", colors.muted), $text.alpha = 0, $text.y = $text.__y + 20, $purpleMic.alpha = 0, $mic.alpha = 1, $text.text.setText(text.muted)
		}), 1300)
	}
	async function onClick(e) {
		if ("CONNECTING" !== _state && _this.flag("interactive")) {
			if (Tests.autoJoinChatOnEnterHotspot()) {
				const shouldMute = "ACTIVE" === _state;
				_this.events.fire(VoiceChatController.TOGGLE_MUTE, {
					value: shouldMute
				})
			} else if ("INACTIVE" === _state || "ENTER_NON_AUTOJOIN" === _state) VoiceChatController.instance().connect();
			else {
				const shouldMute = "ACTIVE" === _state;
				_this.events.fire(VoiceChatController.TOGGLE_MUTE, {
					value: shouldMute
				})
			}
			TrackAnalytics.track("HotspotAudioChatClicked")
		}
	}

	function onHover(e) {
		"over" === e.action && (PlayerControlsPathfinding.DISABLED = !0, _bgShader.tween("uHover", 1, 1e3, "easeOutExpo")), "out" === e.action && (PlayerControlsPathfinding.DISABLED = !1, _bgShader.tween("uHover", 0, 1e3, "easeOutExpo"))
	}!async function() {
		$wrapper = $gl(_width, _height),
			function initBackground() {
				$bg = $gl(_width, _height, "#FFFFFF"), _bgShader = _this.initClass(Shader, "HotSpotUIVoiceChatButtonShader", {
					uColor1: {
						value: colors.inactive
					},
					uColor2: {
						value: colors.muted
					},
					uOwnAlpha: {
						value: 0
					},
					uTransition: {
						value: 0
					},
					uHover: {
						value: 0
					},
					uLoadingTransition: {
						value: 0
					},
					transparent: !0
				}), $bg.setZ(1), $bg.useShader(_bgShader), $wrapper.add($bg), $wrapper.tween({
					scale: .9
				}, 0, "easeOutCubic")
			}(),
			function initIcon() {
				$mic = $gl(_width, _height, Assets.getPath("assets/images/hotspot/mic-white.png")), $mic.setZ(2), $mic.alpha = 0, $purpleMic = $gl(_width, _height, Assets.getPath("assets/images/hotspot/mic-purple.png")), $purpleMic.setZ(2), $purpleMic.alpha = 0, $wrapper.add($mic), $wrapper.add($purpleMic)
			}(), await async function initText() {
				let {
					family: family,
					size: size,
					options: options
				} = StyleGuide.getStyle("p", 600);
				const width = GLUIWrapper.ICON_SIZE() + 50;
				$text = $glText(text.muted, family, size, {
					...options,
					width: width,
					align: "center",
					color: StyleGuide.colors.white
				}), await $text.text.ready, $text.alpha = 0, $text.x = GLUIWrapper.ICON_SIZE() / 2, $text.y = -33, $text.__y = $text.y, $text.y += 20, $wrapper.add($text)
			}(), $this.add($wrapper), Utils.query("portalMute") || function addHandlers() {
				$bg.interact(onHover, onClick), _this.events.sub(VoiceChatController.CONNECTED, ((...args) => wrapWithPermissions(handleVoiceChatConnect, ...args))), _this.events.sub(VoiceChatController.CONNECTING, ((...args) => wrapWithPermissions(handleVoiceChatConnecting, ...args))), _this.events.sub(VoiceChatController.TOGGLE_MUTE, ((...args) => wrapWithPermissions(handleVoiceChatMute, ...args))), _this.events.sub(VoiceChatController.ERROR, ((...args) => wrapWithPermissions(handleVoiceChatError, ...args))), _this.events.sub(VoiceChatController.NON_AUTO_JOIN_ENTER, ((...args) => wrapWithPermissions(handleNonAutoJoinEnter, ...args)))
			}(), _this.startRender((t => {
				_this.flag("canPulse") && ($text.alpha = 1 - Math.sin(t / 300))
			})), _this.onResize((() => {
				const size = GLUIWrapper.ICON_SIZE(),
					scale = GLUIWrapper.ICON_SCALE(),
					scaleX = .25 * scale,
					scaleY = .32 * scale;
				$mic.scaleX = scaleX, $mic.scaleY = scaleY, $mic.x = size / 2 - size * (scaleX / 2), $mic.y = size / 2 - size * (scaleY / 2), $purpleMic.scaleX = scaleX, $purpleMic.scaleY = scaleY, $purpleMic.x = $mic.x, $purpleMic.y = $mic.y
			})), $this.hide(), _this.flag("interactive", !0)
	}(), this.animateIn = async function() {
		Utils.query("portalMute") || (await _this.wait((() => !_this.flag("animatingOut"))), $this.show(), $mic.tween({
			alpha: 1
		}, 400, "easeOutCubic"), tween(_obj, {
			value: 0
		}, 500, "easeOutExpo").onUpdate((() => {
			$wrapper.y = GLUIWrapper.HOTSPOT_UI_TRANSLATE_VOICE_Y(_obj.value)
		})), _bgShader.tween("uOwnAlpha", 1, 600, "easeOutCubic"), _visible = !0)
	}, this.animateOut = function() {
		Utils.query("portalMute") || (_this.flag("animatingOut", !0), "ACTIVE" === _state && toInactive(), _bgShader.tween("uOwnAlpha", 0, 400, "easeOutCubic", 400), $mic.tween({
			alpha: 0
		}, 400, "easeOutCubic"), $purpleMic.tween({
			alpha: 0
		}, 400, "easeOutCubic"), tween(_obj, {
			value: 1
		}, 300, "easeOutExpo").onUpdate((() => {
			$wrapper.y = GLUIWrapper.HOTSPOT_UI_TRANSLATE_VOICE_Y(_obj.value)
		})), _visible = !1, _this.delayedCall((() => {
			! function prepareAnimateIn() {
				$mic.alpha = 0, $purpleMic.alpha = 0, _state = "INACTIVE", $text.alpha = 0, $text.y = $text.__y + 20
			}(), $this.hide(), _this.flag("animatingOut", !1)
		}), 400))
	}, this.get("wrapper", (_ => $wrapper)), this.get("bg", (_ => $bg))
}), (_ => {})), Class((function EndPortal(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tMap: {
			value: null
		}
	})
})), Class((function FloorMirror(_mesh, _shader) {
	Inherit(this, Component);
	const _this = this;
	var _mirror;
	(_mirror = _this.initClass(FX.Mirror, _mesh, {
		normal: new Vector3(0, 1, 0),
		size: 1024,
		enabled: Tests.renderMirror()
	})).start(), _this.mirror = _mirror, async function initLayers() {
		let layers = await _this.parent.getAllLayers();
		for (let id in layers) {
			let layer = layers[id];
			layer?.wildcard?.indexOf("reflect") > -1 && (layer.batch ? _this.mirror.add(layer.batch.mesh) : layer.mesh ? _this.mirror.add(layer.mesh) : _this.mirror.add(layer))
		}
		if (_this.parent?.parent?.parent) {
			let layers = await (_this.parent?.parent?.parent?.getAllLayers?.());
			for (let id in layers) {
				let layer = layers[id];
				layer?.wildcard?.indexOf("reflect") > -1 && (layer.batch ? _this.mirror.add(layer.batch.mesh) : _this.mirror.add(layer))
			}
		}
	}(), async function initAvatar() {
		if (await _this.wait(1e3), !Global.PLAYGROUND && Tests.displayAvatarReflections()) {
			let env = AbstractEnvironment.findParent(_this),
				mesh = await env.avatarPromise;
			if (mesh) {
				let clone = _this.mirror.addObject(mesh);
				Tests.onlyUserAvatarReflection() && (clone.maxInstancedCount = 1)
			}
		}
	}()
})), Class((function FOEFNFTGalleryEnvironment(_options = {}) {
	Inherit(this, AbstractEnvironment), Inherit(this, StateComponent), Inherit(this, BroadcastListener), Inherit(this, DreamwavePortal);
	const _this = this;
	let _player, _particles, _skinParticles, _fxScene = _options.fxScene,
		_name = (_options.fxScene?.nuke || World.NUKE, _options.name),
		_v1 = new Vector2,
		_v2 = new Vector2,
		_center = new Vector2,
		_v = new Vector2,
		dist = 1e4,
		_v3 = new Vector3;
	_v3.cylinder = !0;
	let transition = 0,
		transitionType = 0,
		_boundingBoxes = [];
	let layers, _vVel = new Vector3,
		_v0 = new Vector3,
		particlesColors = [new Color("#AAABBC"), new Color("#8B8982"), new Color("#373F47"), new Color("#6C91C2"), new Color("#C3C9E9")];
	const WHITE = new Color("#ffffff"),
		MODERATOR = new Color("#5757D8");
	_this.avatarPromise = Promise.create(), _this.ready = Promise.create();

	function showTutorial() {
		DreamUI.Tutorial.instance().showTutorial(), _this.delayedCall((() => {
			UIStore.dispatch("hasEnteredExperience", !0)
		}), 500)
	}

	function updatePlayerColor() {
		function evaluateTransition() {
			let minLength = _v1.sub(_center).length(),
				maxLength = _v2.sub(_center).length();
			return (_v.clone().sub(_center).length() - minLength) / (maxLength - minLength)
		}
		_v.set(_this.player.group.position.x, _this.player.group.position.z), _v1.set(-357, -196), _v2.set(-390, -207), _center.set(-406, -213), dist = evaluateTransition(), Math.abs(dist) < 5 ? (_v.x > -357 && (dist = 0), _this.player.view.changeBasedOnSpace(dist, 1), SpaceAudioManager.instance().updateTransition(dist, "outdoor", "galaxy")) : (_center.set(-83, -.467), _v1.set(-107, -23), _v2.set(-133, -50), dist = Math.min(1, Math.max(0, evaluateTransition())), _v.x > -90 && (dist = 0), _this.player.view.changeBasedOnSpace(dist, 0), SpaceAudioManager.instance().updateTransition(dist, "gallery", "outdoor"))
	}!async function() {
		UI3DPromptLayout.FORCE_RETINA = Tests.useVFX(), Global.LOADER.add(1), Global.LOADER.add(1), World.SCENE.opaqueSortOrder = Scene.FRONT_TO_BACK_BOUNDING,
			function initTutorials() {
				Utils.query("debugTutorials") && _this.delayedCall(showTutorial, 2e3);
				Tests.isVR() ? Global.VR_READY.then((() => {
					_this.delayedCall(showTutorial, 2500)
				})) : _this.events.sub(LandingUIEnter.CLICK, (() => {
					if (GlobalUI.instance().sponsors?.sponsors?.length && Device.mobile) {
						let joystick = document.querySelector(".joystick");
						joystick && (joystick.style.bottom = "90px")
					}
					_this.delayedCall(showTutorial, 2e3)
				}))
			}(), async function initPortal() {
				if (await AppCMSConfig.ready(), !AppCMSConfig.portal.visible) return;
				_this.initPortal({
					viewOnly: !1,
					duration: 20,
					delayReconnect: 1
				}), _this.portalState.bind("broadcast", (stream => {
					stream?.videoTexture?.texture ? (DreamPortalShader.SHADER.set("tVideo", stream.videoTexture.texture), DreamPortalShader?.SHADER?.tween("uConnected", 1, 1e3, "easeOutSine")) : DreamPortalShader?.SHADER?.tween("uConnected", 0, 1e3, "easeOutSine")
				}))
			}(), (_fxScene || Global.PLAYGROUND) && function initNuke(nuke) {
				if (Utils.query("disabledVFX")) return;
				_this.nuke = nuke,
					function initVFX() {
						_this.vfx = _this.initClass(VFX, _this.nuke, _name)
					}()
			}(_fxScene?.nuke || World.NUKE), _fxScene && (_fxScene.nuke.camera.near = .5, _fxScene.nuke.camera.far = 1e3, _fxScene.nuke.camera.updateProjectionMatrix()), _name || (_name = Utils.getConstructorName(_this).replace(/Environment$/, "").replace(/[A-Z]+(?![a-z])|[A-Z]/g, ((s, offset) => (offset ? "-" : "") + s.toLowerCase()))), _this.setupMultiplayer({
				community: !0,
				maxInRoom: 250,
				roomKey: _name
			});
		const config = {
			camera: _options.camera,
			avatarInteraction: Utils.query("flyover") ? null : {
				interactWithUserAvatar: !0
			},
			hideAvatar: Utils.query("flyover") || Platform.usingVR(),
			preventMovement: Utils.query("flyover"),
			blockTeleport: !Tests.isVR(),
			controlsConfig: Tests.controlsConfig(_name),
			maxMouseTeleport: Tests.maxMouseTeleport(),
			controlsFOV: Tests.controlsFOV(),
			moveMultiplier: Utils.query("fast") ? 10 : 1.4,
			videoChatZones: {
				audioOnly: !0,
				shader: HotSpotBubbleShader.getShader(),
				blockingAreas: [new Vector3(10, -1, 5)],
				playerDistance: 3,
				radius: 3
			},
			joystickSpeed: 5,
			vrTransitionWaitTime: 1e3,
			playerPhysics: !0,
			clickPathfinding: !Utils.query("uil") && !Tests.isVR(),
			noJumping: Device.mobile,
			..._options
		};
		Config.MODERATION_ENABLED && (config.profilePrompt = {
			view: UIProfilePrompt
		});
		const spawn = Utils.query("spawnDebug");
		if (spawn) {
			let req = "hotspot1";
			spawn.length > 2 && (req = spawn);
			const layerSpawn = await _this.layout.getLayer(req);
			config.customSpawnCode = function() {
				const c = new Group;
				return c.position.copy(layerSpawn.position), c
			}
		}
		_this.configureSpace(config), _this.flag("initialized", !0), _particles = await _this.layout.getLayer("particles"), await _particles.ready(), _particles.spawn.useColor(), _skinParticles = await _this.layout.getLayer("skinPeelParticles"), await _skinParticles.ready(), _skinParticles.customClass?.shader?.set("color", Utils.query("wsjAdmin") ? MODERATOR : WHITE), Tests.avatarTransitionSpawn() || (_particles.visible = !1, _particles.group.visible = !1, _particles.antimatter.stopRender(), _skinParticles.visible = !1, _skinParticles.group.visible = !1, _skinParticles.antimatter.stopRender()), _boundingBoxes[0] = await _this.layout.getLayer("bb_first_room"), _boundingBoxes[0].visible = !1, _boundingBoxes[1] = await _this.layout.getLayer("bb_second_room"), _boundingBoxes[1].visible = !1, _boundingBoxes[2] = await _this.layout.getLayer("bb_third_room"), _boundingBoxes[2].visible = !1, _boundingBoxes[3] = await _this.layout.getLayer("bb_fourth_room"), _boundingBoxes[3].visible = !1, _boundingBoxes[4] = await _this.layout.getLayer("bb_fifth_room"), _boundingBoxes[4].visible = !1, _boundingBoxes[5] = await _this.layout.getLayer("bb_sixth_room"), _boundingBoxes[5].visible = !1, Global.LOADER.add(2), layers = await _this.layout.getAllLayers(), await _this.wait(100), await Initializer3D.uploadAllAsync(_this.layout.group), await _this.wait(100), Global.LOADER.trigger(2), _this.ready.resolve(), Global.LOADER.trigger(1), Utils.query("portalMute") && (_this.videoChatZones.dialog.visible = !1), Tests.isVR() ? Global.VR_READY.then((() => {
			RoomCulling.start(_this)
		})) : RoomCulling.start(_this)
	}(), this.onCreateBatch = async function(batch, mesh, key) {
		"avatar" === key && (batch.useDynamic = !0, await batch.ready(), "avatar" === key && (Tests.isVR() && (batch.mesh.renderOrder = RenderOrder.AVATAR_VR), _this.avatarPromise.resolve(batch.mesh)))
	}, this.onActivate = async function() {
		if (_player = _this.getPlayerController(), _this.videoChatZones?.setSpeakingUniform("uIsTalking"), _player) {
			await _player.view.ready(), await _this.wait("initialized"), _this.player = _player, _this.player.view.setModeratorColor();
			let spawnArea = {
				pos: new Vector3(10, 0, -1),
				radius: 10
			};
			_this.videoChatZones.addBlockedArea(spawnArea), _this.hotspots?.areas?.forEach((area => {
				let forbidArea = {
					pos: area.group.position,
					radius: 5
				};
				_this.videoChatZones.addBlockedArea(forbidArea)
			}));
			let portalArea = {
				pos: new Vector3(-13.501, 1, 0),
				radius: 10
			};
			_this.videoChatZones.addBlockedArea(portalArea), _this.videoChatZones.promptOffsetFirstPerson(-4);
			let boxDist = (p, b) => {
				let f = p.clone(),
					q = f.set(Math.abs(f.x), Math.abs(f.y), Math.abs(f.z)).sub(b),
					m = Math.max(q.x, q.y);
				return m = Math.max(m, q.z), m = Math.max(m, 0), m + Math.min(Math.max(q.x, Math.max(q.y, q.z)), 0)
			};
			_this.startRender((() => {
				_this.player.view.shader.set("uScene2", _this.nuke.prevFrameRT_TEST), layers?.D_transition?.shader.set("uScene2", _this.nuke.prevFrameRT_TEST), layers?.F_end?.shader.set("uScene2", _this.nuke.prevFrameRT_TEST), layers?.light_shafts?.shader.set("uScene2", _this.nuke.prevFrameRT_TEST), layers?.testPlane?.shader.set("tMap", _this.nuke.prevFrameRT_TEST), layers.hotspots.children.map((el => {
					el.hotspot?.layers?.artwork?.shader.set("uScene2", _this.nuke.prevFrameRT_TEST)
				})), _boundingBoxes.map(((bb, index) => {
					if (boxDist(_player.group.position.clone().sub(bb.position), bb.scale.clone().multiplyScalar(.5)) <= 0) switch (index) {
						case 0:
							_this.commit(RoomsStore, "setRoom", RoomsStore.FIRST_ROOM);
							break;
						case 1:
							_this.commit(RoomsStore, "setRoom", RoomsStore.SECOND_ROOM);
							break;
						case 2:
							_this.commit(RoomsStore, "setRoom", RoomsStore.ROTUNDA);
							break;
						case 3:
							_this.commit(RoomsStore, "setRoom", RoomsStore.OUTSIDE);
							break;
						case 4:
							_this.commit(RoomsStore, "setRoom", RoomsStore.BRIDGE);
							break;
						case 5:
							_this.commit(RoomsStore, "setRoom", RoomsStore.GALAXY)
					}
				})), updatePlayerColor(), Platform.usingVR() || _player.controls.cameraVerticalOffset(_player.view.shader.uniforms.cameraVerticalOffset.value);
				let p = _player.view.mesh.batch.geom.attributes.offset.array,
					v = _player.view.mesh.batch.geom.attributes.a_uVelocity.array,
					t = _player.view.mesh.batch.geom.attributes.a_uTransition.array;
				for (let j = 0; j < p.length / 3; j += 1) {
					_v3.set(p[3 * j], p[3 * j + 1], p[3 * j + 2]), _vVel.set(v[4 * j], v[4 * j + 1], v[4 * j + 2]), transition = t[2 * j], transitionType = t[2 * j + 1];
					let cond1 = transition > 0 && transition < 1,
						cond2 = _player.view.visible,
						cond3 = _vVel.length() > .01,
						cond4 = 0 == transitionType;
					if (cond1 && cond2 && cond3)
						if (cond4) {
							let h = 1.8 * transition;
							_particles.visible && _particles.spawn.release(_v3, 4, [.2, h], _v0, particlesColors[Math.floor(particlesColors.length * Math.random())]), _v3.set(p[3 * j], p[3 * j + 1] + h, p[3 * j + 2]), _skinParticles.visible && _skinParticles.spawn.release(_v3, 1, [.2, .2], _v0, WHITE)
						} else _v3.set(p[3 * j], p[3 * j + 1], p[3 * j + 2]), _particles.visible && _particles.spawn.release(_v3, 10, [.2, 1.85], _v0, particlesColors[Math.floor(particlesColors.length * Math.random())])
				}
			}))
		}
		_this.animateIn && _this.animateIn(), Global.LOADER.trigger(1)
	}, this.onInvisible = function() {
		_this.animateOut && _this.animateOut()
	}, this.onDeactivate = function() {
		_this.stopRender(updatePlayerColor)
	}
})), Class((function InitEnvironment(_fxScene) {
	Inherit(this, FOEFNFTGalleryEnvironment, {
		fxScene: _fxScene,
		name: "init"
	});
	const _this = this;
	!async function() {
		if (Global.LOADER.add(1), _this.layers = await _this.layout.getAllLayers(), _this.isPlayground()) {
			World.CAMERA.far = 1e5, World.CAMERA.updateProjectionMatrix();
			let _nuke = _fxScene?.nuke || World.NUKE;
			_nuke.camera.far = 1e5, _nuke.camera.updateProjectionMatrix()
		}
		if (_this.isPlayground() || "landing" !== UIStore.get("view") || (_this.hotspots = _this.initClass(HotSpotManager, _this), _this.landing = _this.initClass(Landing)), _this.isPlayground()) {
			(await _this.layout.getAllMatching("hotspot")).forEach((hotMesh => {
				const shad = Utils3D.getTestShader(),
					plane = new Mesh(World.BOX, shad);
				plane.position.set(-.5, 0, .5), plane.scale.setScalar(.1), hotMesh.add(plane)
			}))
		}
		Global.LOADER.trigger(1)
	}()
})), Class((function TheFieldPortal(_mesh) {
	Inherit(this, Component);
	const _this = this;
	let _player, _prompt, _env;
	const RADIUS = Tests.isVR() ? 10 : 7;

	function loop() {
		if (!_player || !_player.group) return;
		_player.group.position.distanceTo(_mesh.getWorldPosition()) <= RADIUS ? _this.flag("needs_reset") || (! function trigger() {
			Tests.isVR() ? function showPrompt() {
				TrackAnalytics.track("TheFieldPrompt");
				const pos = (new Vector3).copy(_mesh.getWorldPosition());
				pos.y -= 1, Tests.isVR() ? (pos.lerp(_player.group.position, .7, !1), _prompt.setPosition(pos)) : (_prompt.setPosition(pos), _prompt.promptOffsetFirstPerson(-7));
				_prompt.open(), Tests.isVR() || _prompt.$gluiObject.group.scale.setScalar(3.5)
			}() : (TrackAnalytics.track("TheFieldExit"), window.location.href = "https://thefield.wsjbarrons.com")
		}(), _this.flag("needs_reset", !0)) : (! function leave() {
			_prompt.close()
		}(), _this.flag("needs_reset", !1))
	}
	_prompt = _this.initClass(TheFieldPortalPrompt), _this.startRender(loop, 24), this.onVisible = async function() {
		_env = await DreamWorld.getActiveEnvironment(), _env && (_env.group.add(_prompt.group), _player = await _env.awaitPlayerController())
	}
})), Class((function TheFieldPortalPrompt() {
	Inherit(this, UI3DPromptLayout, "TheFieldPortalPrompt");
	const _this = this;

	function handleHover({
		action: action,
		object: object
	}) {
		switch (action) {
			case "over":
				object.tween({
					alpha: .5
				}, 400, "easeOutCubic");
				break;
			case "out":
				object.tween({
					alpha: 1
				}, 400, "easeOutCubic")
		}
	}!async function() {
		await async function initLayers() {
				_this.layers = await _this.layout.getAllLayers()
			}(),
			function initHandlers() {
				_this.layers.acceptButton && _this.layers.acceptButton.mesh.interact(handleHover, (_ => {
					TrackAnalytics.track("TheFieldPrompt_Accept"), Tests.isVR() ? (_this.events.sub(XRDeviceManager.SESSION_END, (_ => {
						window.setTimeout((() => {
							window.location.href = "thefieldvr.html"
						}), 1e3)
					})), XRDeviceManager.endSession()) : (TrackAnalytics.track("TheFieldExit"), window.open("https://thefield.wsjbarrons.com", "_blank")), _this.close()
				}));
				_this.layers.cancelButton && _this.layers.cancelButton.mesh.interact(handleHover, (_ => {
					TrackAnalytics.track("TheFieldPrompt_Cancel"), _this.close()
				}))
			}()
	}()
})), Class((function InstancedPeelTriangles(_proton, _group, _input) {
	Inherit(this, Object3D);
	const _this = this;
	_this.shader = null, async function() {
		await async function initMesh() {
			let geom = new Geometry,
				vertices = [0, 0, -1, 1, 0, 1, -1, 0, 1],
				normals = [0, 1, 0, 0, 1, 0, 0, 1, 0];
			geom.addAttribute("position", new GeometryAttribute(new Float32Array(vertices), 3)), geom.addAttribute("normal", new GeometryAttribute(new Float32Array(normals), 3)), geom = (new Geometry).instanceFrom(geom), _proton.applyToInstancedGeometry(geom), _this.shader = _this.initClass(Shader, "instancedPeelTriangles", {
				color: {
					value: new Color("#ffffff")
				},
				tLife: {
					value: null
				},
				uScale: {
					value: .01
				},
				uScaleRange: {
					value: new Vector2(1, .5)
				},
				unique: !0,
				side: Shader.DOUBLE_SIDE
			}), _proton.applyToShader(_this.shader), ShaderUIL.add(_this.shader, _group).setLabel("Shader");
			let mesh = new Mesh(geom, _this.shader);
			mesh.frustumCulled = !1, _this.add(mesh), await _proton.spawn.ready(), _this.startRender((() => {
				_this.shader.set("tLife", _proton.spawn.lifeOutput.texture)
			}))
		}()
	}()
})), Class((function InfiniteSkyShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tMap: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uHue: {
			value: 0
		},
		uHueSpread: {
			value: .2
		},
		uBrightness: {
			value: new Vector2(1.6, 5)
		},
		tFlow: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		tClouds: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uColor0: {
			value: new Color("#fffcf0")
		},
		uColor1: {
			value: new Color("#6bceff")
		},
		uColor2: {
			value: new Color("#f894ff")
		},
		uColor3: {
			value: new Color("#f894ff")
		},
		uParams: {
			value: new Vector4(.55, .08, .04, 3)
		},
		depthWrite: !1,
		depthTest: !1
	}), _mesh.renderOrder = RenderOrder.INFINITE_SKY
})), Class((function SkyDomeOuter() {
	Inherit(this, FXScene);
	const _this = this;
	!async function() {
		_this.layout = _this.initClass(SceneLayout, "SkyDomeOuter_layout"), _this.layout.layers = await _this.layout.getAllLayers(), _this.layout.layers[0] && (_this.scene.add(_this.layout.group), _this.create({
			manualRender: !0
		}), Platform.usingVR() || _this.startRender((_ => {
			_this.layout.layers[0].frustumCulled = !1, _this.draw()
		}), RenderManager.BEFORE_RENDER), _this.flag("isReady", !0))
	}(), this.ready = async function() {
		await _this.wait(_this, "isReady")
	}
}), "singleton"), Class((function SkyDomeShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	!async function() {
		_shader.addUniforms({
			tMap: {
				value: null,
				ignoreUIL: !0
			}
		}), Platform.usingVR() || (await SkyDomeOuter.instance().ready(), _shader.set("tMap", SkyDomeOuter.instance().rt.texture))
	}()
})), Class((function WaterfallShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	Tests.renderWaterfall() ? (_shader.addUniforms({
		tNormal: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		tEnv: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uTiling: {
			value: new Vector2(3, 3)
		},
		uSpeed: {
			value: .05
		},
		uColor: {
			value: new Color
		},
		uSpecColor: {
			value: new Color("#FFFFFF")
		},
		uScrollDirection: {
			value: new Vector3
		},
		uParams: {
			value: new Vector3(2, 1.14, 0)
		},
		uNormalIntensity: {
			value: 2.5
		},
		uEnv: {
			value: new Vector3(0, 0, -.064)
		},
		uAlpha: {
			value: 1
		},
		transparent: !0
	}), _mesh.renderOrder = RenderOrder.WATERFALL) : _mesh.visible = !1
})), Class((function BuildingTransitionShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	const _this = this;
	! function() {
		const nukeCondition = Global.PLAYGROUND || Tests.isVR();
		_shader.addUniforms({
			uScene: {
				value: nukeCondition ? null : World.NUKE.prevFrameRT
			},
			uScene2: {
				value: null
			},
			tMap: {
				value: null
			},
			uMixShadow: {
				value: 0
			},
			uFresnel: {
				value: new Vector3(0, 1, .2)
			},
			uIrridFreq: {
				value: new Vector3(.25, .15, .02)
			},
			uIrridOffset: {
				value: new Vector3(.6, -.15, .25)
			},
			uRenderReticle: {
				value: 0
			},
			v2: {
				value: new Vector2(-122, -44)
			},
			v1: {
				value: new Vector2(-110, -25)
			},
			center: {
				value: new Vector2(-90, 0)
			},
			uPathReticle: PlayerControlsPathfinding.RETICLE_UNIFORM
		}), _mesh.renderOrder = RenderOrder.TRANSPARENT_BUILDING, _this.startRender((() => {
			_shader.set("uRenderReticle", Number(PlayerControls.ENABLED))
		}))
	}()
})), Class((function FrostedGlassShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tMap: {
			value: null
		},
		uVR: {
			value: Platform.usingVR() || !Tests.useVFX() ? 1 : 0
		}
	}), _shader.transparent = !0
})), Class((function FrostedGlassShaderPBR(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tLogo: {
			value: null
		},
		uVR: {
			value: Platform.usingVR() || !Tests.useVFX() ? 1 : 0
		}
	}), _shader.side = Tests.frostedGlassDoubled() ? Shader.DOUBLE_SIDE_TRANSPARENCY : Shader.DOUBLE_SIDE, _shader.transparent = !0
})), Class((function GlassShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		uIrridFreq: {
			value: new Vector3(.25, .15, .02)
		},
		uIrridOffset: {
			value: new Vector3(.6, -.15, .25)
		}
	}), _shader.transparent = !0
})), Class((function GreyboxShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	const _this = this;
	_shader.addUniforms({
		tMap: {
			value: null
		},
		uMixShadow: {
			value: 0
		},
		uFresnel: {
			value: new Vector3(0, 1, .2)
		},
		uRenderReticle: {
			value: 0
		},
		uPathReticle: PlayerControlsPathfinding.RETICLE_UNIFORM
	}), _this.startRender((() => {
		_shader.set("uRenderReticle", Number(PlayerControls.ENABLED))
	}))
})), Class((function MarbleShaderPBR(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	const _this = this;
	_shader.addUniforms({
		uRenderReticle: {
			value: 0
		},
		uFrequency: {
			value: .2
		},
		uGamma: {
			value: 1
		},
		uColorMinMax: {
			value: new Vector2(.4, 1)
		},
		uPathReticle: PlayerControlsPathfinding.RETICLE_UNIFORM
	}), _this.startRender((() => {
		_shader.set("uRenderReticle", Number(PlayerControls.ENABLED))
	}))
})), Class((function PBR(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	const _this = this;
	_shader.addUniforms({
		uRenderReticle: {
			value: 0
		},
		uPathReticle: PlayerControlsPathfinding.RETICLE_UNIFORM
	}), _this.startRender((() => {
		_shader.set("uRenderReticle", Number(PlayerControls.ENABLED))
	}))
})), Class((function RoomsStore() {
	Inherit(this, Component), Inherit(this, AppStore);
	const _this = this;
	_this.FIRST_ROOM = "space_first_room", _this.SECOND_ROOM = "space_second_room", _this.ROTUNDA = "space_rotunda", _this.OUTSIDE = "space_outside", _this.BRIDGE = "space_bridge", _this.GALAXY = "space_galaxy", async function() {
		await Hydra.ready(), _this.createAppStore({
			state: {
				currentRoom: _this.FIRST_ROOM
			},
			mutations: {
				setRoom(state, payload) {
					payload != state.currentRoom && (state.currentRoom = payload)
				}
			}
		})
	}()
}), "static"), Class((function InsideWsj() {
	Inherit(this, BaseInside);
	const _this = this;
	let _active = !1;
	_this.init = async function() {
		_this.swirl = _this.layers.swirl, _this.isPlayground() && (_active = !0), async function initSwirl() {
			await _this.swirl.tubes.ready(), _this.swirl.mesh.frustumCulled = !1;
			let _origin = new Vector3;
			_origin.cylinder = !0, _origin.height = 5;
			let _velocity = new Vector3(1, 0, 0);
			_this.startRender((() => {
				_active && _this.swirl.tubes.release(_origin, 1, 10, _velocity)
			}), 60)
		}()
	}, this.onSetData = function(data) {
		const bg = _this.layers.bg;
		_this.swirl.tubes.shader.set("uColorA", new Color(data.swirlsColor1.hex)), _this.swirl.tubes.shader.set("uColorB", new Color(data.swirlsColor2.hex)), _this.swirl.tubes.shader.set("uColorC", new Color(data.swirlsColor3.hex)), _this.swirl.tubes.shader.set("uColorD", new Color(data.swirlsColor4.hex)), bg.shader.set("uColorA", new Color(data.backgroundColor1.hex)), bg.shader.set("uColorB", new Color(data.backgroundColor2.hex))
	}, this.onShow = async function() {
		_active = !0
	}, this.onHide = async function() {
		_active = !1
	}
})), Class((function InsideWsjBg(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		uColorA: {
			value: new Color("#ff0000")
		},
		uColorB: {
			value: new Color("#ff0000")
		}
	})
})), Class((function InsideAxie() {
	Inherit(this, BaseInside);
	const _this = this;
	let _data;
	this.init = async function() {
		_data = Gallery.activeHotspots.find((item => item.artPiece.title === InsideOrigin.TITLE))
	}, this.onSetData = function(data) {
		_this.layers.images.onSetData(data)
	}, this.onShow = async function() {}, this.onHide = async function() {}
})), Class((function InsideAxieCoinCloud() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _base;
	!async function() {
		_base = await _this.parent.getLayer("coin"), _base.visible = !1,
			function initShader() {
				_shader = _base.shader.clone()
			}(),
			function initMesh() {
				const batch = new MeshBatch;
				batch.static = !0, _this.add(batch.group);
				const baseGeo = _base.geometry,
					center = new Vector3(0, 0, 0),
					COL = 30,
					ROWS = 10,
					START_Y = -10,
					END_Y = 28;
				for (let i = 0; i < ROWS; i++)
					for (let j = 0; j < COL; j++) {
						if (Math.random() < .4) continue;
						const mesh = new Mesh(baseGeo, _shader),
							height = Math.range(i, 0, ROWS, START_Y, END_Y);
						let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
						teta += i / ROWS;
						const radius = Math.random(8, 16, 3);
						mesh.position.x = Math.sin(teta) * radius, mesh.position.z = Math.cos(teta) * radius, mesh.position.y = height, mesh.position.y += Math.random(-1, 1, 3), mesh.rotation.x = Math.random(0, 2 * Math.PI, 3), mesh.rotation.y = Math.random(0, 2 * Math.PI, 3), mesh.rotation.z = Math.random(0, 2 * Math.PI, 3);
						const scale = Math.random(.03, .1, 4);
						mesh.scale.setScalar(scale), center.y = height, mesh.attributes = {
							random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4))
						}, batch.add(mesh)
					}
			}()
	}(), this.show = function() {
		return _shader.set("uAppear", 0), _shader.tween("uAppear", 1, 1e4, "easeOutCirc").promise()
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 4e3, "easeInOutCubic").promise()
	}
})), Class((function InsideAxieCoinPBR(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		uLightColor: {
			value: new Color("#ffffff")
		}
	})
})), Class((function InsideAxieImages() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _video;
	! function initShader() {
		_video = _this.initClass(VideoTexture, "assets/images/inside/default.mp4"), _video.start(), _shader = _this.initClass(Shader, "InsideAxieImagesShader", {
			tMap: {
				value: _video.texture,
				ignoreUIL: !0
			},
			uAppear: {
				value: 1,
				ignoreUIL: !0
			},
			transparent: !0
		})
	}(),
	function initMesh() {
		const batch = new MeshBatch;
		batch.static = !0, _this.add(batch.group);
		const baseGeo = new PlaneGeometry(4, 2.248, 1, 1),
			center = new Vector3(0, 0, 0),
			COL = 20,
			ROWS = 14,
			RADIUS = 16,
			START_Y = -10,
			END_Y = 28;
		for (let i = 0; i < ROWS; i++)
			for (let j = 0; j < COL; j++) {
				if (Math.random() < .6) continue;
				const mesh = new Mesh(baseGeo, _shader),
					height = Math.range(i, 0, ROWS, START_Y, END_Y);
				let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
				teta += i / ROWS, mesh.position.x = Math.sin(teta) * RADIUS, mesh.position.z = Math.cos(teta) * RADIUS, mesh.position.y = height, center.y = height, mesh.lookAt(center), mesh.attributes = {
					random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4))
				}, batch.add(mesh)
			}
	}(), this.onSetData = function(data) {
		_video && _video.stop(), _video.src = data.video.asset.url, _video.start()
	}, this.show = function() {
		return _shader.set("uAppear", 0), _shader.tween("uAppear", 1, 1e4, "easeOutCirc").promise()
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 4e3, "easeInOutCubic").promise()
	}
})), Class((function InsideSushi() {
	Inherit(this, BaseInside);
	const _this = this;
	this.init = async function() {
		_this.lidar = _this.layers.lidar, Tests.renderLidars() || (_this.lidar.visible = !1, _this.lidar.mesh.visible = !1, _this.lidar.antimatter.stopRender())
	}, this.onShow = async function() {}, this.onHide = async function() {}
})), Class((function InsideSushiBg(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		uColor: {
			value: new Color("#8dbeec")
		}
	})
})), Class((function InsideEvolute() {
	Inherit(this, BaseInside);
	const _this = this;
	this.init = async function() {
		_this.lidar = _this.layers.lidar, Tests.renderLidars() || (_this.lidar.visible = !1, _this.lidar.mesh.visible = !1, _this.lidar.antimatter.stopRender())
	}, this.onShow = async function() {}, this.onHide = async function() {}
})), Class((function InsideTaco() {
	Inherit(this, BaseInside);
	const _this = this;
	_this.internalId = "NFT014", this.init = async function() {
		_this.images = _this.layers.images, _this.bud = _this.layers.bud, _this.bg = _this.layers.bg
	}, this.onShow = async function() {
		_this.layers.bg.shader.set("uTransition", 0), _this.images.show(), _this.bud.hide()
	}, this.onAnimateOut = async function() {
		_this.bud.hide(), await _this.images.hide()
	}, this.onSetData = function(data) {
		_this.images.onSetData(data), _this.bud.onSetData(data), _this.bg.shader.set("uColor", new Color(data.backgroundColor1.hex)), _this.bg.shader.set("uColorA", new Color(data.backgroundColor2.hex)), _this.bg.shader.set("uColorB", new Color(data.backgroundColor3.hex))
	}, this.onHide = async function() {}, this.transitionToSecond = async function() {
		_this.images.hide(), _this.bud.show(), _this.layers.bg.shader.tween("uTransition", 1, 2e3, "easeInOutCubic")
	}
})), Class((function InsideTacoBudImages() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _aspect = new Vector2;
	! function initShader() {
		_shader = _this.initClass(Shader, "InsideTacoBudImagesShader", {
			tMap: {
				value: Utils3D.getTexture("assets/images/inside/default.jpg"),
				ignoreUIL: !0
			},
			uAppear: {
				value: 1,
				ignoreUIL: !0
			},
			uAspectRatio: {
				value: _aspect
			},
			depthTest: !1,
			transparent: !0
		})
	}(), async function initMesh() {
		await _this.wait("dataSet");
		const batch = new MeshBatch;
		batch.static = !0, _this.add(batch.group);
		const baseGeo = new PlaneGeometry(2, 2, 1, 1),
			center = new Vector3(0, 0, 0),
			COL = 30,
			ROWS = 15,
			RADIUS = 16,
			START_Y = -15,
			END_Y = 28,
			a = _aspect.x / _aspect.y;
		for (let i = 0; i < ROWS; i++)
			for (let j = 0; j < COL; j++) {
				const mesh = new Mesh(baseGeo, _shader),
					height = Math.range(i, 0, ROWS, START_Y, END_Y);
				let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
				teta += i / ROWS, mesh.position.x = Math.sin(teta) * RADIUS * a, mesh.position.z = Math.cos(teta) * RADIUS * a, mesh.position.y = height, mesh.scale.x *= a, center.y = height, mesh.lookAt(center), mesh.attributes = {
					random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4)),
					row: i / ROWS
				}, batch.add(mesh)
			}
	}(), this.onSetData = function(data) {
		const image = data.spriteSheet || "";
		if (image && _shader.set("tMap", Utils3D.getTexture(image)), data.imagesRatio) {
			let [x, y] = data.imagesRatio.split("x").map((x => Number(x)));
			_aspect.set(x, y), _shader.set("uAspectRatio", _aspect)
		}
		_this.flag("dataSet", !0)
	}, this.show = function() {
		return _shader.set("uAppear", 0), _shader.tween("uAppear", 1, 1e4, "easeOutCirc").promise()
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 800, "easeInOutCubic").promise()
	}
})), Class((function InsideTacoImages() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _video;
	! function initShader() {
		_video = _this.initClass(VideoTexture, "assets/images/inside/default.mp4"), _video.start(), _shader = _this.initClass(Shader, "InsideTacoImagesShader", {
			tMap: {
				value: _video.texture,
				ignoreUIL: !0
			},
			uAppear: {
				value: 1,
				ignoreUIL: !0
			},
			transparent: !0
		})
	}(),
	function initMesh() {
		const batch = new MeshBatch;
		batch.static = !0, _this.add(batch.group);
		const baseGeo = new PlaneGeometry(2, 2, 1, 1),
			center = new Vector3(0, 0, 0),
			COL = 40,
			ROWS = 12,
			RADIUS = 15,
			START_Y = -10,
			END_Y = 20;
		for (let i = 0; i < ROWS; i++)
			for (let j = 0; j < COL; j++) {
				const mesh = new Mesh(baseGeo, _shader),
					height = Math.range(i, 0, ROWS, START_Y, END_Y);
				let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
				teta += i / ROWS, mesh.position.x = Math.sin(teta) * RADIUS, mesh.position.z = Math.cos(teta) * RADIUS, mesh.position.y = height, center.y = height, mesh.lookAt(center), mesh.attributes = {
					random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4)),
					row: i / ROWS
				}, batch.add(mesh)
			}
	}(), this.onSetData = function(data) {
		_video && _video.stop(), _video.src = data.video.asset.url, _video.start()
	}, this.show = function() {
		return _shader.set("uAppear", 0), _shader.tween("uAppear", 1, 1e4, "easeOutCirc").promise()
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 4e3, "easeInOutCubic").promise()
	}
})), Class((function InsideDna() {
	Inherit(this, BaseInside);
	this.init = async function() {}, this.onShow = async function() {}, this.onHide = async function() {}
})), Class((function InsideDnaBg(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		uColorA: {
			value: new Color("#ff0000")
		},
		uColorB: {
			value: new Color("#ff0000")
		}
	})
})), Class((function InsideDnaCloud() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _base;
	!async function() {
		_base = await _this.parent.getLayer("dna"), _base.visible = !1,
			function initShader() {
				_shader = _this.initClass(Shader, "InsideDnaShader", {})
			}(),
			function initMesh() {
				const batch = new MeshBatch;
				batch.static = !0, _this.add(batch.group);
				const baseGeo = _base.geometry,
					center = new Vector3(0, 0, 0),
					COL = 30,
					ROWS = 10,
					START_Y = -10,
					END_Y = 28;
				for (let i = 0; i < ROWS; i++)
					for (let j = 0; j < COL; j++) {
						if (Math.random() < .4) continue;
						const mesh = new Mesh(baseGeo, _shader),
							height = Math.range(i, 0, ROWS, START_Y, END_Y);
						let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
						teta += i / ROWS;
						const radius = Math.random(8, 16, 3);
						mesh.position.x = Math.sin(teta) * radius, mesh.position.z = Math.cos(teta) * radius, mesh.position.y = height, mesh.position.y += Math.random(-1, 1, 3), mesh.rotation.x = Math.random(0, 2 * Math.PI, 3), mesh.rotation.y = Math.random(0, 2 * Math.PI, 3), mesh.rotation.z = Math.random(0, 2 * Math.PI, 3);
						const scale = Math.random(.03, .1, 4);
						mesh.scale.setScalar(scale), center.y = height, mesh.attributes = {
							random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4))
						}, batch.add(mesh)
					}
			}()
	}(), this.show = function() {
		return _shader.set("uAppear", 0), _shader.tween("uAppear", 1, 1e4, "easeOutCirc").promise()
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 4e3, "easeInOutCubic").promise()
	}
})), Class((function InsideDao() {
	Inherit(this, BaseInside);
	const _this = this;
	let _active = !1,
		_origin = new Vector3,
		_velocity = new Vector3(0, 1, 0);

	function spawn(teta = !1) {
		if (!_active) return;
		const angle = teta || Math.random(0, 2 * Math.PI, 4);
		_origin.x = 10 * Math.sin(angle), _origin.z = 10 * Math.cos(angle), _origin.y = 0, _this.swirl.tubes.release(_origin, 600, .4, _velocity)
	}
	_this.init = async function() {
		_this.swirl = _this.layers.swirl, _this.bg = _this.layers.bg, _this.isPlayground() && (_active = !0), async function initSwirl() {
			await _this.swirl.tubes.ready(), _this.swirl.mesh.frustumCulled = !1, _this.startRender(spawn, .13)
		}()
	}, this.onShow = async function() {
		_active = !0, spawn(6.2)
	}, this.onHide = async function() {
		_active = !1
	}, this.transitionToSecond = async function() {}
})), Class((function InsideOrigin() {
	Inherit(this, BaseInside);
	const _this = this;
	this.init = async function() {
		_this.images = _this.layers.images, _this.fog = _this.layers.fog, _this.bg = _this.layers.bg
	}, this.onSetData = function(data) {
		_this.images.setData(data), _this.layers.bg.shader.set("uColor", new Color(data.color1.hex)), _this.layers.bg.shader.set("uColorSecond", new Color(data.color2.hex))
	}, this.onShow = async function(data) {
		_this.layers.bg.shader.set("uTransition", 0), _this.images.show(), _this.fog.show()
	}, this.onAnimateOut = async function() {
		_this.fog.hide(), await _this.images.hide()
	}, this.transitionToSecond = async function() {
		_this.images.transition(), _this.layers.bg.shader.tween("uTransition", 1, 2e3, "easeInOutCubic")
	}
})), Class((function InsideOriginImages() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _aspect = new Vector2;
	! function initShader() {
		_shader = _this.initClass(Shader, "InsideOriginImagesShader", {
			tMap: {
				value: Utils3D.getTexture("assets/images/inside/default.jpg"),
				ignoreUIL: !0
			},
			tMap2: {
				value: Utils3D.getTexture("assets/images/inside/default.jpg"),
				ignoreUIL: !0
			},
			uAppear: {
				value: 1,
				ignoreUIL: !0
			},
			uTransition: {
				value: 0
			},
			uAspectRatio: {
				value: new Vector2
			},
			transparent: !0,
			side: Shader.DOUBLE_SIDE
		})
	}(), async function initMesh() {
		await _this.wait("dataSet");
		const batch = new MeshBatch;
		batch.static = !0, _this.add(batch.group);
		const baseGeo = new PlaneGeometry(2, 2, 1, 1),
			center = new Vector3(0, 0, 0),
			COL = 32,
			ROWS = 15,
			RADIUS = 15,
			START_Y = -10,
			END_Y = 28,
			a = _aspect.x / _aspect.y;
		for (let i = 0; i < ROWS; i++)
			for (let j = 0; j < COL; j++) {
				const mesh = new Mesh(baseGeo, _shader),
					height = Math.range(i, 0, ROWS, START_Y, END_Y);
				let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
				teta += i / ROWS, mesh.position.x = Math.sin(teta) * RADIUS * a, mesh.position.z = Math.cos(teta) * RADIUS * a, mesh.position.y = height, center.y = height, mesh.lookAt(center), mesh.attributes = {
					random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4)),
					row: i / ROWS
				}, batch.add(mesh)
			}
	}(), this.show = function() {
		return _shader.set("uAppear", 0), _shader.set("uTransition", 0), _shader.tween("uAppear", 1, 1e4, "easeInOutCubic", 1e3).promise()
	}, this.setData = function(data) {
		const image1 = data.spriteSheet1 || "",
			image2 = data.spriteSheet2 || "";
		if (data.imagesRatio) {
			let [x, y] = data.imagesRatio.split("x").map((x => Number(x)));
			_aspect.set(x, y), _shader.set("uAspectRatio", _aspect)
		}
		image1 && _shader.set("tMap", Utils3D.getTexture(image1)), image2 && _shader.set("tMap2", Utils3D.getTexture(image2)), _this.flag("dataSet", !0)
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 1e3, "easeInOutCubic").promise()
	}, this.transition = function() {
		return _shader.set("uTransition", 0), _shader.tween("uTransition", 1, 4e3, "easeInOutCubic").promise()
	}
})), Class((function InsideGenerative() {
	Inherit(this, BaseInside);
	const _this = this;
	let _active = !1;
	_this.init = function() {
		_this.swirl = _this.layers.swirl, _this.bg = _this.layers.bg, _this.isPlayground() && (_active = !0), async function initSwirl() {
			await _this.swirl.tubes.ready(), _this.swirl.mesh.frustumCulled = !1;
			let _origin = new Vector3;
			_origin.cylinder = !0, _origin.height = 5;
			let _velocity = new Vector3(1, 0, 0);
			_this.startRender((() => {
				_active && _this.swirl.tubes.release(_origin, 1, 10, _velocity)
			}), 60)
		}()
	}, this.onSetData = function(data) {
		_this.layers.bg.shader.set("uColor", new Color(data.color1.hex)), _this.layers.bg.shader.set("uColorSecond", new Color(data.color2.hex))
	}, this.onShow = async function() {
		_this.layers.swirl.behavior.shader.set("uLerp", .4), _this.layers.swirl.behavior.shader.set("uCurlNoiseScale", 1.5), _this.layers.swirl.tubes.shader.set("uTransition", 0), _this.layers.bg.shader.set("uTransition", 0), _active = !0
	}, this.onAnimateOut = async function() {
		_active = !1
	}, this.onHide = async function() {
		_active = !1, _this.layers.swirl.spawn.pass.shader.set("uSetup", 1), defer((() => {
			_this.layers.swirl.spawn.pass.shader.set("uSetup", 0)
		}))
	}, this.transitionToSecond = async function() {
		_this.layers.bg.shader.tween("uTransition", 1, 2e3, "easeInOutCubic"), _this.layers.swirl.tubes.shader.tween("uTransition", 1, 2e3, "easeInOutCubic"), _this.layers.swirl.behavior.shader.tween("uLerp", .95, 4e3, "linear"), _this.layers.swirl.behavior.shader.tween("uCurlNoiseScale", 4, 3e3, "linear")
	}
})), Class((function InsideScam() {
	Inherit(this, BaseInside);
	const _this = this;
	let _data, _active = !1;
	this.init = async function() {
		_data = Gallery.activeHotspots.find((item => item.artPiece.title === InsideScam.TITLE)), _this.fog = _this.layers.fog, _this.rain = _this.layers.rain, _this.swirl = _this.layers.swirl, _this.isPlayground() && (_active = !0), async function initSwirl() {
			await _this.swirl.tubes.ready(), _this.swirl.mesh.frustumCulled = !1;
			let _origin = new Vector3;
			_origin.cylinder = !0, _origin.height = 5;
			let _velocity = new Vector3(1, 0, 0);
			_this.startRender((() => {
				_active && _this.swirl.tubes.release(_origin, 1, 10, _velocity)
			}), 10)
		}()
	}, this.onShow = async function() {
		_active = !0, _this.fog.show(), _this.rain.customClass.show()
	}, this.onHide = async function() {
		_active = !1, _this.fog.hide(), _this.rain.customClass.hide()
	}
})), Class((function InsideScamRain(_proton, _group, _input) {
	Inherit(this, Object3D);
	const _this = this;
	let _baseGeometry, _shader;
	! function initBaseMesh() {
		_baseGeometry = new CylinderGeometry(.03, .05, 1, 4, 1);
		const aSplashData1 = new Array(1 * _baseGeometry.attributes.position.count).fill(0);
		_baseGeometry.addAttribute("aSplash", new GeometryAttribute(new Float32Array(aSplashData1), 1));
		const _splash = new PlaneGeometry(2, 2),
			aSplashData = new Array(1 * _splash.attributes.position.count).fill(1);
		_splash.addAttribute("aSplash", new GeometryAttribute(new Float32Array(aSplashData), 1)), _splash.applyMatrix((new Matrix4).makeRotationX(-Math.PI / 2)), _splash.applyMatrix((new Matrix4).makeTranslation(0, -.5, 0)), _baseGeometry.merge(_splash)
	}(),
	function initMesh() {
		let geometry = (new Geometry).instanceFrom(_baseGeometry);
		_shader = _this.initClass(Shader, "InsideScamRain", {
			uTransition: {
				value: 1
			},
			uHeight: {
				value: new Vector2(.5, 1.5)
			},
			uWidth: {
				value: new Vector2(.5, 1.5)
			},
			uAlpha: {
				value: .8
			},
			uAlphaSplash: {
				value: 1
			},
			uSplashDuration: {
				value: 3
			},
			uRotation: {
				value: 2
			},
			uColor: {
				value: new Color("#ffffff")
			},
			uSplashColor: {
				value: new Color("#ffffff")
			},
			uLightPosition: {
				value: new Vector3(0, 0, 0)
			},
			uLightIntensity: {
				value: 1
			},
			uLightFalloff: {
				value: new Vector2(0, 5)
			},
			tMatcap: {
				value: null
			},
			tNormal: {
				value: null,
				getTexture: Utils3D.getRepeatTexture
			},
			depthTest: !1,
			depthWrite: !1,
			transparent: !0
		}), ShaderUIL.add(_shader, _group).setLabel("Particles Rain"), _proton.applyToInstancedGeometry(geometry), _proton.applyToShader(_shader);
		let mesh = new Mesh(geometry, _shader);
		mesh.frustumCulled = !1, _this.add(mesh)
	}(), this.show = async function() {
		return _shader.set("uTransition", 0), _shader.set("uAlpha", 0), _shader.tween("uAlpha", .22, 4e3), _shader.tween("uTransition", 1, 1e4, 3e3).promise()
	}, this.hide = async function() {
		return _shader.tween("uTransition", 0, 1e3).promise()
	}
})), Class((function InsideHokusai() {
	Inherit(this, BaseInside);
	const _this = this;
	let _data;
	this.init = async function() {
		_data = Gallery.activeHotspots.find((item => item.artPiece.title === InsideHokusai.TITLE)), _this.floor = _this.layers.floor, _this.floor.geometry = new PlaneGeometry(1, 1), _this.floor.geometry.applyMatrix((new Matrix4).makeRotationX(Math.PI / 2))
	}, this.onShow = async function() {}, this.onHide = async function() {}
})), Class((function InsideHokusaiPool(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tNormal: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		tEnv: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uTiling: {
			value: new Vector2(5, 5)
		},
		uSpeed: {
			value: .15
		},
		uColor: {
			value: new Color("#a4b6df")
		},
		uSpecColor: {
			value: new Color("#FFFFFF")
		},
		uParams: {
			value: new Vector3(2, 1, 0)
		},
		uNormalIntensity: {
			value: 2
		},
		uScrollDirection: {
			value: new Vector3
		},
		uEnv: {
			value: new Vector3
		},
		uMirrorStrength: {
			value: 1
		},
		uMirrorRoughness: {
			value: 1
		},
		uRippleTile: {
			value: new Vector2(1, 1)
		},
		uRippleStrength: {
			value: 1
		},
		uRippleSpeed: {
			value: 1
		},
		uAlpha: {
			value: 1
		}
	})
})), Class((function InsideHokusaiWaveShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tMap: {
			value: null
		}
	})
})), Class((function InsideMemo() {
	Inherit(this, BaseInside);
	const _this = this;
	let _data;
	this.init = async function() {
		_data = Gallery.activeHotspots.find((item => item.artPiece.title === InsideMemo.TITLE))
	}, this.onSetData = function(data) {
		const url = SanityImageUrlBuilder.build(data.image).width(1200).quality(90).dpr(World.DPR).url();
		_this.layers.bg.shader.set("tMap", Utils3D.getTexture(url))
	}, this.onShow = async function() {}, this.onHide = async function() {}
})), Class((function InsideMemoBgShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tMap: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		}
	})
})), Class((function InsideDecentraland() {
	Inherit(this, BaseInside);
	const _this = this;
	this.init = async function() {
		_this.images = _this.layers.images, _this.lidar = _this.layers.lidar, Tests.renderLidars() || (_this.lidar.visible = !1, _this.lidar.mesh.visible = !1, _this.lidar.antimatter.stopRender())
	}, this.onSetData = function(data) {
		_this.images.onSetData(data)
	}, this.onShow = async function() {
		_this.images.show()
	}, this.onAnimateOut = async function() {
		_this.images.hide()
	}, this.onHide = async function() {}
})), Class((function InsideDecentralandImages() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _video;
	! function initShader() {
		_video = _this.initClass(VideoTexture, "assets/images/inside/default.mp4"), _shader = _this.initClass(Shader, "InsideDecentralandImagesShader", {
			tMap: {
				value: _video.texture,
				ignoreUIL: !0
			},
			uAppear: {
				value: 1,
				ignoreUIL: !0
			},
			transparent: !0
		})
	}(),
	function initMesh() {
		const batch = new MeshBatch;
		batch.static = !0, _this.add(batch.group);
		const baseGeo = new PlaneGeometry(4, 2.372, 1, 1),
			center = new Vector3(0, 0, 0),
			COL = 12,
			ROWS = 8,
			RADIUS = 16,
			START_Y = -10,
			END_Y = 28;
		for (let i = 0; i < ROWS; i++)
			for (let j = 0; j < COL; j++) {
				const mesh = new Mesh(baseGeo, _shader),
					height = Math.range(i, 0, ROWS, START_Y, END_Y);
				let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
				teta += i / ROWS, mesh.position.x = Math.sin(teta) * RADIUS, mesh.position.z = Math.cos(teta) * RADIUS, mesh.position.y = height, center.y = height, mesh.lookAt(center), mesh.attributes = {
					random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4))
				}, batch.add(mesh)
			}
	}(), this.onSetData = function(data) {
		_video && _video.stop(), _video.src = data.video.asset.url, _video.start()
	}, this.show = function() {
		return _shader.set("uAppear", 0), _shader.tween("uAppear", 1, 1e4, "easeOutCirc").promise()
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 4e3, "easeInOutCubic").promise()
	}
})), Class((function InsideDual() {
	Inherit(this, BaseInside);
	const _this = this;
	this.init = async function() {
		_this.images = _this.layers.images, _this.pizza = _this.layers.pizza, _this.bg = _this.layers.bg
	}, this.onSetData = function(data) {
		_this.images.onSetData(data), _this.pizza.onSetData(data)
	}, this.onShow = async function() {
		_this.layers.bg.shader.set("uTransition", 0), _this.images.show(), _this.pizza.hide()
	}, this.onAnimateOut = async function() {
		_this.pizza.hide(), await _this.images.hide()
	}, this.onHide = async function() {}, this.transitionToSecond = async function() {
		_this.images.hide(), _this.pizza.show(), _this.layers.bg.shader.tween("uTransition", 1, 2e3, "easeInOutCubic")
	}
})), Class((function InsideDualImages() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _video;
	! function initShader() {
		_video = _this.initClass(VideoTexture, "assets/images/inside/default.mp4"), _video.start(), _shader = _this.initClass(Shader, "InsideDualImagesShader", {
			tMap: {
				value: _video.texture,
				ignoreUIL: !0
			},
			uAppear: {
				value: 1,
				ignoreUIL: !0
			},
			transparent: !0,
			side: Shader.DOUBLE_SIDE
		})
	}(),
	function initMesh() {
		const batch = new MeshBatch;
		batch.static = !0, _this.add(batch.group);
		const baseGeo = new PlaneGeometry(.8 * 6, 6, 10, 10),
			center = new Vector3(0, 0, 0),
			COL = 10,
			ROWS = 4,
			RADIUS = 15,
			START_Y = -10,
			END_Y = 28;
		for (let i = 0; i < ROWS; i++)
			for (let j = 0; j < COL; j++) {
				const mesh = new Mesh(baseGeo, _shader),
					height = Math.range(i, 0, ROWS, START_Y, END_Y);
				let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
				teta += i / ROWS, mesh.position.x = Math.sin(teta) * RADIUS, mesh.position.z = Math.cos(teta) * RADIUS, mesh.position.y = height, center.y = height, mesh.lookAt(center), mesh.attributes = {
					random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4)),
					row: i / ROWS
				}, batch.add(mesh)
			}
	}(), this.onSetData = function(data) {
		_video && _video.stop(), _video.src = data.video.asset.url, _video.start()
	}, this.show = function() {
		return _shader.set("uAppear", 0), _shader.tween("uAppear", 1, 1e4, "easeOutCirc").promise()
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 4e3, "easeInOutCubic").promise()
	}
})), Class((function InsideDualPizza() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _aspect = new Vector2;
	! function initShader() {
		_shader = _this.initClass(Shader, "InsideDualPizzaShader", {
			tMap: {
				value: Utils3D.getTexture("assets/images/inside/default.jpg"),
				ignoreUIL: !0
			},
			uAppear: {
				value: 1,
				ignoreUIL: !0
			},
			uAspectRatio: {
				value: _aspect
			},
			transparent: !0,
			depthTest: !1
		})
	}(), async function initMesh() {
		await _this.wait("dataSet");
		const batch = new MeshBatch;
		batch.static = !0, _this.add(batch.group);
		const baseGeo = new PlaneGeometry(4, 4, 1, 1),
			center = new Vector3(0, 0, 0),
			COL = 15,
			ROWS = 7,
			RADIUS = 19,
			START_Y = -15,
			END_Y = 28,
			a = _aspect.x / _aspect.y;
		for (let i = 0; i < ROWS; i++)
			for (let j = 0; j < COL; j++) {
				const mesh = new Mesh(baseGeo, _shader),
					height = Math.range(i, 0, ROWS, START_Y, END_Y);
				let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
				teta += i / ROWS, mesh.position.x = Math.sin(teta) * RADIUS, mesh.position.z = Math.cos(teta) * RADIUS, mesh.position.y = height, mesh.scale.x *= a, center.y = height, mesh.lookAt(center), mesh.attributes = {
					random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4)),
					row: i / ROWS
				}, batch.add(mesh)
			}
	}(), this.onSetData = function(data) {
		const image = data.spriteSheet || "";
		if (data.imagesRatio) {
			let [x, y] = data.imagesRatio.split("x").map((x => Number(x)));
			_aspect.set(x, y), _shader.set("uAspectRatio", _aspect)
		}
		image && _shader.set("tMap", Utils3D.getTexture(image)), _this.flag("dataSet", !0)
	}, this.show = function() {
		return _shader.set("uAppear", 0), _shader.tween("uAppear", 1, 1e4, "easeOutCirc").promise()
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 800, "easeInOutCubic").promise()
	}
})), Class((function InsideVee() {
	Inherit(this, BaseInside);
	const _this = this;
	_this.internalId = "NFT008", this.init = async function() {
		_this.images = _this.layers.images, _this.images2 = _this.layers.images2, _this.bg = _this.layers.bg
	}, this.onSetData = function(data) {
		_this.images.onSetData(data), _this.images2.onSetData(data), _this.bg.shader.set("uColor", new Color(data.backgroundColor1.hex)), _this.bg.shader.set("uColorA", new Color(data.backgroundColor2.hex)), _this.bg.shader.set("uColorB", new Color(data.backgroundColor3.hex))
	}, this.onShow = async function() {
		_this.layers.bg.shader.set("uTransition", 0), _this.images2.show(), _this.images.hide()
	}, this.onAnimateOut = async function() {
		_this.images2.hide(), await _this.images.hide()
	}, this.transitionToSecond = async function() {
		_this.images2.hide(), _this.images.show(), _this.layers.bg.shader.tween("uTransition", 1, 2e3, "easeInOutCubic")
	}
})), Class((function InsideVeeBgShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		uColor: {
			value: new Color("#ff0000")
		},
		uColorA: {
			value: new Color("#ff0000")
		},
		uColorB: {
			value: new Color("#ff0000")
		},
		uTransition: {
			value: 0
		}
	})
})), Class((function InsideVeeImages() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _aspect = new Vector2;
	! function initShader() {
		_shader = _this.initClass(Shader, "InsideVeeImagesShader", {
			tMap: {
				value: Utils3D.getTexture("assets/images/inside/default.jpg"),
				ignoreUIL: !0
			},
			uAppear: {
				value: 0,
				ignoreUIL: !0
			},
			uAspectRatio: {
				value: _aspect
			},
			depthTest: !1,
			transparent: !0
		})
	}(), async function initMesh() {
		await _this.wait("dataSet");
		const batch = new MeshBatch;
		batch.static = !0, _this.add(batch.group);
		const baseGeo = new PlaneGeometry(2.976, 4, 1, 1),
			center = new Vector3(0, 0, 0),
			COL = 24,
			ROWS = 8,
			RADIUS = 15,
			START_Y = -15,
			END_Y = 28,
			a = _aspect.x / _aspect.y;
		for (let i = 0; i < ROWS; i++)
			for (let j = 0; j < COL; j++) {
				const mesh = new Mesh(baseGeo, _shader),
					height = Math.range(i, 0, ROWS, START_Y, END_Y);
				let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
				teta += i / ROWS, mesh.position.x = Math.sin(teta) * RADIUS * a, mesh.position.z = Math.cos(teta) * RADIUS * a, mesh.position.y = height, mesh.scale.setScalar(Math.random(.8, 1.2, 3)), mesh.scale.x *= a, center.y = height, mesh.lookAt(center), mesh.attributes = {
					random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4)),
					row: i / ROWS
				}, batch.add(mesh)
			}
	}(), this.onSetData = function(data) {
		const image = data.spriteSheet || "";
		if (data.imagesRatio) {
			let [x, y] = data.imagesRatio.split("x").map((x => Number(x)));
			_aspect.set(x, y), _shader.set("uAspectRatio", _aspect)
		}
		image && _shader.set("tMap", Utils3D.getTexture(image)), _this.flag("dataSet", !0)
	}, this.show = function() {
		return _shader.set("uAppear", 0), _shader.tween("uAppear", 1, 13e3, "easeOutCirc").promise()
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 800, "easeInOutCubic").promise()
	}
})), Class((function InsideVeeUS() {
	Inherit(this, Object3D);
	const _this = this;
	let _shader, _video;
	! function initShader() {
		_video = _this.initClass(VideoTexture, "assets/images/inside/default.mp4"), _video.start(), _shader = _this.initClass(Shader, "InsideVeeUSShader", {
			tMap: {
				value: _video.texture,
				ignoreUIL: !0
			},
			uAppear: {
				value: 0,
				ignoreUIL: !0
			},
			transparent: !0
		})
	}(),
	function initMesh() {
		const batch = new MeshBatch;
		batch.static = !0, _this.add(batch.group);
		const baseGeo = new PlaneGeometry(7, 7, 1, 1),
			center = new Vector3(0, 0, 0),
			COL = 7,
			ROWS = 4,
			RADIUS = 10,
			START_Y = -10,
			END_Y = 28;
		for (let i = 0; i < ROWS; i++)
			for (let j = 0; j < COL; j++) {
				const mesh = new Mesh(baseGeo, _shader),
					height = Math.range(i, 0, ROWS, START_Y, END_Y);
				let teta = Math.range(j, 0, COL, 0, 2 * Math.PI);
				teta += i / ROWS, mesh.position.x = Math.sin(teta) * RADIUS, mesh.position.z = Math.cos(teta) * RADIUS, mesh.position.y = height, center.y = height, mesh.lookAt(center), mesh.attributes = {
					random: new Vector4(Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4), Math.random(0, 1, 4))
				}, batch.add(mesh)
			}
	}(), this.onSetData = function(data) {
		_video && _video.stop(), _video.src = data.video.asset.url, _video.start()
	}, this.show = function() {
		return _shader.set("uAppear", 0), _shader.tween("uAppear", 1, 1e4, "easeOutCirc").promise()
	}, this.hide = function() {
		return _shader.tween("uAppear", 0, 4e3, "easeInOutCubic").promise()
	}
})), Class((function InsideGucci() {
	Inherit(this, BaseInside);
	const _this = this;
	this.init = async function() {
		_this.lidar = _this.layers.lidar, Tests.renderLidars() || (_this.lidar.visible = !1, _this.lidar.mesh.visible = !1, _this.lidar.antimatter.stopRender())
	}, this.onShow = async function() {}, this.onHide = async function() {}
})), Class((function InsideGucciLightShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	! function() {
		let _tex = Utils3D.getRepeatTexture("assets/images/lightshaft/light-mask.jpg"),
			_noise = Utils3D.getRepeatTexture("assets/images/lightshaft/noise_combined.jpg");
		_shader.addUniforms({
			tMap: {
				value: _tex,
				ignoreUIL: !0
			},
			tNoise: {
				value: _noise,
				ignoreUIL: !0
			},
			uColor: {
				value: new Color("#ffffff")
			}
		}), _shader.transparent = !0, _shader.blending = Shader.ADDITIVE_BLENDING, _shader.side = Shader.DOUBLE_SIDE_TRANSPARENCY, _shader.depthWrite = !1
	}()
})), Class((function BaseInside({
	scenelayout: scenelayout
} = {}) {
	Inherit(this, Object3D);
	const _this = this;
	this.ready = Promise.create(), async function() {
		let nameScenelayout = scenelayout || Utils.getConstructorName(_this);
		_this.layout = _this.initClass(SceneLayout, nameScenelayout), _this.layers = await _this.layout.getAllLayers(), await Gallery.ready(), await (_this.init?.()), Global.LOADER.add(1), await Initializer3D.uploadAllAsync(_this.layout.group), await Initializer3D.uploadAllAsync(_this.group), await _this.wait(50), Global.LOADER.trigger(1), _this.isPlayground() || (_this.visible = !1), _this.ready.resolve()
	}(), _this.setData = async function(data) {
		await _this.layout.getAllLayers(), _this.onSetData?.(_this.getEnvironmentTemplate(data))
	}, _this.show = function(data) {
		_this.visible = !0, _this.onShow?.(data)
	}, _this.animateOut = async function() {
		await (_this.onAnimateOut?.())
	}, _this.hide = async function() {
		await (_this.onHide?.()), _this.visible = !1
	}, _this.getEnvironmentTemplate = function(data) {
		return data.artPiece?.hotspotDetail?.environmentTemplate
	}
})), Class((function ImageCloud() {
	Inherit(this, BaseInside);
	const _this = this;
	let _copy, _proton, _mesh, _behavior, _vertices, _count, _revealDuration = 5;
	const TAU = 2 * Math.PI;

	function initTunnelMode(params) {
		const imageShiftProgram = _proton.customClass.imageShiftProgram,
			isHorizontal = params?.horizontal,
			size = params?.size;
		let sliceCount = Math.floor(Math.sqrt(_count));
		const imagesPerSliceCount = .25 * sliceCount;
		let vertexIterator = 0;
		for (let i = 0; i < sliceCount; i++)
			for (let j = 0; j < imagesPerSliceCount; j++) {
				let phase = (j + .5) / imagesPerSliceCount,
					angle = Math.range(phase, 0, 1, 0, TAU);
				for (let k = 0; k < 4; k++) isHorizontal ? (_vertices.buffer[vertexIterator++] = Math.cos(angle), _vertices.buffer[vertexIterator++] = Math.sin(angle), _vertices.buffer[vertexIterator++] = 0, _vertices.buffer[vertexIterator++] = k / 3) : (_vertices.buffer[vertexIterator++] = Math.cos(angle), _vertices.buffer[vertexIterator++] = (i + .5) / sliceCount * 2 - 1, _vertices.buffer[vertexIterator++] = Math.sin(angle), _vertices.buffer[vertexIterator++] = k / 3)
			}
		switch (size) {
			case "small":
				imageShiftProgram.shader.set("uSpeed", 1), _mesh.shader.set("uImageScale", 5), _mesh.shader.set("uTunnelRadius", 8), _mesh.shader.set("uTunnelHeight", 101);
				break;
			case "medium":
				imageShiftProgram.shader.set("uSpeed", 1), _mesh.shader.set("uImageScale", 3), _mesh.shader.set("uTunnelRadius", 8), _mesh.shader.set("uTunnelHeight", 100);
				break;
			default:
				imageShiftProgram.shader.set("uSpeed", 2), _mesh.shader.set("uImageScale", 4), _mesh.shader.set("uTunnelRadius", 8), _mesh.shader.set("uTunnelHeight", 100)
		}
		let fogVal = _this.inputUIL.get("Tunnel Fog MinMax");
		_mesh.shader.set("uTunnelFogParams", new Vector2(fogVal[0], fogVal[1])), _vertices.needsUpdate = !0, updateBuffer({
			mode: 0
		})
	}

	function updateBuffer({
		mode: mode
	}) {
		_behavior.setUniform("uMode", mode), _mesh.shader.set("uMode", mode), _mesh.shader.set("uParticleCount", _count), _copy.shader.set("tMap", _vertices.texture), World.RENDERER.renderSingle(_copy, World.CAMERA, _proton.antimatter.getOutput().value)
	}

	function applyVariation({
		variationMode: variationMode,
		params: params = null
	}) {
		switch (variationMode) {
			case "tunnel":
				initTunnelMode(params);
				break;
			case "tornado":
				!async function initTornadoMode(params) {
					let initHeight = _behavior.getUniform("uTornadoHeight"),
						initRadius = _behavior.getUniform("uTornadoRadius"),
						vertexIterator = 0;
					const R = (1 + Math.sqrt(5)) / 2;
					for (let i = 0; i < _count; i++) {
						let angle = TAU * (i / R),
							r = Math.range(Math.random(), 0, 1, initRadius, 1.5 * initRadius);
						_vertices.buffer[vertexIterator++] = Math.cos(angle) * r, _vertices.buffer[vertexIterator++] = Math.range(i, 0, _count - 1, -initHeight, initHeight), _vertices.buffer[vertexIterator++] = Math.sin(angle) * r, _vertices.buffer[vertexIterator++] = Math.random()
					}
					_mesh.shader.set("uImageScale", 1);
					const speed = params?.speed;
					switch (_mesh.shader.set("uTornadoMinMaxSize", new Vector2(.5, 1.5)), speed) {
						case "slow":
							_behavior.setUniform("uTornadoRotationSpeed", .3), _behavior.setUniform("uTornadoElevationSpeed", .15), _behavior.setUniform("uTornadoCurlNoiseSpeed", .3);
							break;
						case "medium":
						default:
							_behavior.setUniform("uTornadoRotationSpeed", .8), _behavior.setUniform("uTornadoElevationSpeed", .5), _behavior.setUniform("uTornadoCurlNoiseSpeed", .8);
							break;
						case "fast":
							_behavior.setUniform("uTornadoRotationSpeed", 1.5), _behavior.setUniform("uTornadoElevationSpeed", 1), _behavior.setUniform("uTornadoCurlNoiseSpeed", 1.2)
					}
					let fogVal = _this.inputUIL.get("Tornado Fog MinMax");
					_mesh.shader.set("uTornadoFogParams", new Vector2(fogVal[0], fogVal[1])), _vertices.needsUpdate = !0, updateBuffer({
						mode: 1
					})
				}(params);
				break;
			case "floating":
				! function initFloatingMode(params) {
					let vertexIterator = 0;
					const R = (1 + Math.sqrt(5)) / 2;
					for (let i = 0; i < _count; i++) {
						let angle = TAU * (i / R),
							angle2 = Math.acos(1 - 2 * i / _count),
							r = Math.range(Math.random(), 0, 1, 10, 20);
						_vertices.buffer[vertexIterator++] = Math.cos(angle) * Math.sin(angle2) * r, _vertices.buffer[vertexIterator++] = Math.cos(angle2) * r, _vertices.buffer[vertexIterator++] = Math.sin(angle) * Math.sin(angle2) * r, _vertices.buffer[vertexIterator++] = Math.random()
					}
					const minMaxSize = params?.minMaxSize;
					minMaxSize ? _mesh.shader.set("uFloatingMinMaxSize", new Vector2(minMaxSize.min, minMaxSize.max)) : _mesh.shader.set("uFloatingMinMaxSize", new Vector2(.5, 1.3));
					const speed = params?.speed;
					switch (speed) {
						case "slow":
							_behavior.setUniform("uTornadoCurlNoiseSpeed", .5);
							break;
						case "medium":
						default:
							_behavior.setUniform("uTornadoCurlNoiseSpeed", 2.4);
							break;
						case "fast":
							_behavior.setUniform("uTornadoCurlNoiseSpeed", 5)
					}
					let fogVal = _this.inputUIL.get("Floating Fog MinMax");
					_mesh.shader.set("uFloatingFogParams", new Vector2(fogVal[0], fogVal[1])), _mesh.shader.set("uImageScale", 1), _vertices.needsUpdate = !0, updateBuffer({
						mode: 2
					})
				}(params)
		}
	}
	_this.init = async function() {
		_proton = _this.layers.particles, await _proton.ready(), _this.inputUIL = InputUIL.create("animationSettings"), _this.inputUIL.onUpdate = (key, val) => {
				_this.onUIUpdate?.(key, val)
			},
			function initUIL() {
				_this.inputUIL.setLabel("Image Cloud Settings"), _this.inputUIL.addSelect("Mode", [{
					label: "Tunnel",
					value: "tunnel"
				}, {
					label: "Tornado",
					value: "tornado"
				}, {
					label: "Floating",
					value: "floating"
				}]), _this.inputUIL.addNumber("Reveal Duration", _revealDuration), _this.inputUIL.addVector("Tunnel Fog MinMax", [0, 40], {
					min: 0,
					max: 50
				}), _this.inputUIL.addVector("Tornado Fog MinMax", [0, 40], {
					min: 0,
					max: 50
				}), _this.inputUIL.addVector("Floating Fog MinMax", [0, 40], {
					min: 0,
					max: 50
				}), _this.inputUIL.addColor("Fog Color", new Color)
			}(),
			function initCopyPass() {
				let program = _this.initClass(Shader, "CopyData");
				_copy = new Mesh(World.QUAD, program), _copy.noMatrices = !0, _copy.transient = !0
			}(), _mesh = _proton.customClass.mesh, _mesh.frustumCulled = !1, _behavior = _proton.behavior, _vertices = _proton.antimatter.vertices, _count = _vertices.buffer.length / 4, _this.isPlayground() || (_this.layers.platform.visible = !1, _this.layers.background.visible = !1), initTunnelMode()
	}, _this.onUIUpdate = function(key, val) {
		if (_proton = _this.layers.particles, _vertices = _proton.antimatter.vertices, _count = _vertices.buffer.length / 4, "Mode" === key && applyVariation({
				variationMode: val
			}), _revealDuration = _this.inputUIL.getNumber("Reveal Duration"), "Tunnel Orientation" === key) {
			let params = {};
			params.horizontal = "horizontal" === val, initTunnelMode(params)
		}
		let tunnelFog = _this.inputUIL.get("Tunnel Fog MinMax");
		_mesh.shader.set("uTunnelFogParams", new Vector2(tunnelFog[0], tunnelFog[1]));
		let tornadoFog = _this.inputUIL.get("Tornado Fog MinMax");
		_mesh.shader.set("uTornadoFogParams", new Vector2(tornadoFog[0], tornadoFog[1]));
		let floatingFog = _this.inputUIL.get("Floating Fog MinMax");
		_mesh.shader.set("uFloatingFogParams", new Vector2(floatingFog[0], floatingFog[1])), _mesh.shader.set("uFogColor", new Color(_this.inputUIL.get("Fog Color")))
	}, _this.onShow = function(data = null) {
		const hotspotData = data?.artPiece?.hotspotDetail,
			{
				environmentTemplate: environmentTemplate
			} = hotspotData,
			duration = Utils.query("imagecloudrevealduration") ? parseFloat(Utils.query("imagecloudrevealduration")) : 1e3 * _revealDuration;
		let variation;
		_mesh.shader.set("uFogColor", new Color(_this.inputUIL.get("Fog Color"))), variation = Utils.query("randomimagecloud") ? ["tunnel", "tornado", "floating"].random() : environmentTemplate.type;
		const {
			spriteSheet: spriteSheet,
			images: images,
			photoAmount: photoAmount,
			size: size,
			speed: speed
		} = environmentTemplate;
		! function updateSpriteSheetDataAndAspectRatio({
			spriteSheet: spriteSheet,
			images: images,
			aspectRatio: aspectRatio
		}) {
			const texture = Utils3D.getTexture(spriteSheet),
				rowCount = Math.ceil(images.length / 5);
			let aspect = 1;
			switch (aspectRatio) {
				case "1x1":
				default:
					aspect = 1;
					break;
				case "9x16":
				case "16x9":
					aspect = 1.7777778
			}
			_mesh.shader.set("uAspectRatio", aspect), _mesh.shader.set("tMap", texture), _mesh.shader.set("uGridCount", new Vector2(5, rowCount))
		}({
			spriteSheet: spriteSheet,
			images: images,
			aspectRatio: environmentTemplate.imagesRatio
		}), applyVariation({
			variationMode: variation,
			params: {
				photoAmount: photoAmount,
				size: size,
				speed: speed
			}
		}), _mesh.shader.set("uReveal", 0), _mesh.shader.tween("uReveal", 1, duration, "linear")
	}, _this.onHide = function() {
		return _mesh.shader.tween("uReveal", 0, 500, "linear").promise()
	}, this.applyVariation = applyVariation
}), (_ => {
	ImageCloud.REVEAL_IMAGES = "imagetunnelrevealimages", ImageCloud.HIDE_IMAGES = "imagetunnelhideimages"
})), Class((function ImageParticles(_proton, _group, _input) {
	Inherit(this, Object3D);
	const _this = this;
	let _mesh, _imageShiftStateProgram, _imageshiftStateFBO = {};

	function loop() {
		! function updateImageShiftState() {
			_imageShiftStateProgram.shader.set("tPos", _proton.antimatter.getOutput().value), World.RENDERER.renderSingle(_imageShiftStateProgram, World.CAMERA, _imageshiftStateFBO.write);
			let tmp = _imageshiftStateFBO.read;
			_imageshiftStateFBO.read = _imageshiftStateFBO.write, _imageshiftStateFBO.write = tmp, _imageShiftStateProgram.shader.set("tImageShift", _imageshiftStateFBO.read), _mesh.shader.set("tImageShiftState", _imageshiftStateFBO.read)
		}()
	}! function initImageShifting() {
		let textureSize = _proton.antimatter.textureSize,
			count = _proton.antimatter.vertices.buffer.length / 4;
		const imageShiftData = new Float32Array(4 * count);
		let initImageShiftDataIterator = 0;
		for (let i = 0; i < count; i++) imageShiftData[initImageShiftDataIterator++] = Math.map(Math.random(), 0, 1, .1, 1), imageShiftData[initImageShiftDataIterator++] = Math.map(Math.random(), 0, 1, .001, .005), imageShiftData[initImageShiftDataIterator++] = 0, imageShiftData[initImageShiftDataIterator++] = Math.map(Math.random(), 0, 1, .2, .8);
		let format = Texture.RGBAFormat,
			type = "ios" == Device.system.os ? Texture.HALF_FLOAT : Texture.FLOAT;
		const options = {
				type: type,
				minFilter: Texture.NEAREST,
				magFilter: Texture.NEAREST,
				format: format,
				generateMipmaps: !1
			},
			initImageShift = new DataTexture(imageShiftData, textureSize, textureSize, format, type);
		initImageShift.destroyDataAfterUpload = !0, _imageshiftStateFBO.read = new RenderTarget(textureSize, textureSize, options), _imageshiftStateFBO.write = new RenderTarget(textureSize, textureSize, options);
		const program = _this.initClass(Shader, "ImageShiftState", {
			tImageShift: {
				value: initImageShift,
				ignoreUIL: !0
			},
			tPos: {
				value: null,
				ignoreUIL: !0
			},
			uSpeed: {
				value: 1
			},
			uMinMaxLifeRate: {
				value: new Vector2(.001, .005)
			},
			uSmoothstepMinMax: {
				value: new Vector2(.2, .8)
			}
		});
		ShaderUIL.add(program, _group).setLabel("Image shift params"), _imageShiftStateProgram = new Mesh(World.QUAD, program)
	}(),
	function initMesh() {
		const geo = (new Geometry).instanceFrom(new PlaneGeometry(.5, .5, 1, 1));
		_proton.applyToInstancedGeometry(geo);
		const program = _this.initClass(Shader, "ImageParticles", {
			tMap: {
				value: Utils3D.getTexture("assets/images/test/georgetest2.jpeg"),
				ignoreUIL: !0
			},
			tBlueNoise: {
				value: Utils3D.getTexture("assets/images/test/bluenoise64.png", {
					minFilter: Texture.NEAREST,
					magFilter: Texture.NEAREST,
					wrapS: Texture.REPEAT,
					wrapT: Texture.REPEAT,
					generateMipmaps: !1
				}),
				ignoreUIL: !0
			},
			tImageShiftState: {
				value: _imageshiftStateFBO.read.texture,
				ignoreUIL: !0
			},
			uGridCount: {
				value: new Vector2(5, 3),
				ignoreUIL: !0
			},
			uAspectRatio: {
				value: 1.7777777778,
				ignoreUIL: !0
			},
			uImageScale: {
				value: 1
			},
			uMode: {
				value: 0,
				ignoreUIL: !0
			},
			uParticleCount: {
				value: Tests.imageParticleCount(),
				ignoreUIL: !0
			},
			uImageTransitionMode: {
				value: 0
			},
			uTunnelRadius: {
				value: 10
			},
			uTunnelHeight: {
				value: 20
			},
			uTornadoDistanceSmoothstep: {
				value: new Vector2(.5, 1)
			},
			uTornadoDistanceScale: {
				value: new Vector2(1, 3)
			},
			uTornadoHeight: {
				value: 40,
				ignoreUIL: !0
			},
			uTornadoMinMaxSize: {
				value: new Vector2(.5, 1.3)
			},
			uFloatingDistanceSmoothstep: {
				value: new Vector2(.5, 1)
			},
			uFloatingDistanceScale: {
				value: new Vector2(1, 3)
			},
			uFloatingMinMaxSize: {
				value: new Vector2(.5, 1.3)
			},
			uReveal: {
				value: Global.PLAYGROUND ? 1 : 0
			},
			uTunnelFogParams: {
				value: new Vector2(5, 25)
			},
			uTornadoFogParams: {
				value: new Vector2(5, 20)
			},
			uFloatingFogParams: {
				value: new Vector2(5, 30)
			},
			uFogColor: {
				value: new Color(0, 0, 0)
			},
			receiveShadow: !1,
			transparent: !0
		});
		program.side = Shader.DOUBLE_SIDE, _proton.applyToShader(program), ShaderUIL.add(program, _group).setLabel("Shader"), _mesh = new Mesh(geo, program), _this.add(_mesh)
	}(), _this.startRender(loop), this.get("proton", (_ => _proton)), this.get("mesh", (_ => _mesh)), this.get("imageShiftProgram", (_ => _imageShiftStateProgram))
})), Class((function ImageCloudBackground(_mesh, _shader) {
	Inherit(this, Component);
	_shader.addUniforms({
		uColor: {
			value: new Color(1, 1, 1)
		}
	})
})), Class((function ImageCloudPresets() {
	Inherit(this, Component);
	this.tunnelMode = []
}), "static"), Class((function FloatingImageParticles(_proton, _group, _input) {
	Inherit(this, Object3D);
	const _this = this;
	! function initRandomPositions() {
		let vertices = _proton.antimatter.vertices,
			count = vertices.buffer.length / 4;
		const TAU = 2 * Math.PI;
		let vertexIterator = 0;
		const R = (1 + Math.sqrt(5)) / 2;
		for (let i = 0; i < count; i++) {
			let angle = TAU * (i / R),
				angle2 = Math.acos(1 - 2 * i / count),
				r = Math.range(Math.random(), 0, 1, 10, 20);
			vertices.buffer[vertexIterator++] = Math.cos(angle) * Math.sin(angle2) * r, vertices.buffer[vertexIterator++] = Math.cos(angle2) * r, vertices.buffer[vertexIterator++] = Math.sin(angle) * Math.sin(angle2) * r, vertices.buffer[vertexIterator++] = Math.random()
		}
		vertices.needsUpdate = !0
	}(),
	function initMesh() {
		const geo = (new Geometry).instanceFrom(new PlaneGeometry(.5, .5, 1, 1));
		_proton.applyToInstancedGeometry(geo);
		const program = _this.initClass(Shader, "FloatingImageParticles", {
			tMap: {
				value: Utils3D.getTexture("assets/images/test/2k_atlas.jpg")
			},
			uGridCount: {
				value: new Vector2(13, 13)
			},
			uScale: {
				value: 1
			},
			uScaleRange: {
				value: new Vector2(.5, 1)
			},
			uApplyNoiseDisplacement: {
				value: 0
			},
			uApplyDistanceScale: {
				value: 0
			},
			uDistanceSmoothstep: {
				value: new Vector2(.5, 1)
			},
			uDistanceScale: {
				value: new Vector2(1, 3)
			},
			receiveShadow: !1,
			transparent: !1
		});
		program.side = Shader.DOUBLE_SIDE, _proton.applyToShader(program), ShaderUIL.add(program, _group).setLabel("Shader");
		const mesh = new Mesh(geo, program);
		_this.add(mesh), _proton.upload(!0)
	}()
})), Class((function ImageOcean() {
	Inherit(this, Object3D);
	const _this = this;
	!async function() {
		_this.layout = _this.initClass(SceneLayout, Utils.getConstructorName(_this)), _this.layers = await _this.layout.getAllLayers()
	}()
})), Class((function ImageTornado() {
	Inherit(this, Object3D);
	const _this = this;
	!async function() {
		_this.layout = _this.initClass(SceneLayout, Utils.getConstructorName(_this)), _this.layers = await _this.layout.getAllLayers()
	}()
})), Class((function TornadoParticles(_proton, _group, _input) {
	Inherit(this, Object3D);
	const _this = this;
	! function initRandomPositions() {
		let vertices = _proton.antimatter.vertices,
			count = vertices.buffer.length / 4;
		const TAU = 2 * Math.PI;
		let vertexIterator = 0;
		const R = (1 + Math.sqrt(5)) / 2;
		for (let i = 0; i < count; i++) {
			let angle = TAU * (i / R),
				r = Math.range(Math.random(), 0, 1, 15, 20);
			vertices.buffer[vertexIterator++] = Math.cos(angle) * r, vertices.buffer[vertexIterator++] = Math.range(i, 0, count - 1, -40, 40), vertices.buffer[vertexIterator++] = Math.sin(angle) * r, vertices.buffer[vertexIterator++] = Math.random()
		}
		vertices.needsUpdate = !0
	}(),
	function initMesh() {
		const geo = (new Geometry).instanceFrom(new PlaneGeometry(.5, .5, 1, 1));
		_proton.applyToInstancedGeometry(geo);
		const program = _this.initClass(Shader, "TornadoParticles", {
			tMap: {
				value: Utils3D.getTexture("assets/images/test/spritesheet1k.png")
			},
			uGridCount: {
				value: new Vector2(4, 4)
			},
			uScale: {
				value: 1
			},
			uScaleRange: {
				value: new Vector2(.5, 1)
			},
			uApplyNoiseDisplacement: {
				value: 0
			},
			uApplyDistanceScale: {
				value: 0
			},
			uDistanceSmoothstep: {
				value: new Vector2(.5, 1)
			},
			uDistanceScale: {
				value: new Vector2(1, 3)
			},
			uTornadoHeight: {
				value: 40
			},
			receiveShadow: !1,
			transparent: !1
		});
		program.side = Shader.DOUBLE_SIDE, _proton.applyToShader(program), ShaderUIL.add(program, _group).setLabel("Shader");
		const mesh = new Mesh(geo, program);
		_this.add(mesh), _proton.upload()
	}()
})), Class((function ImageTunnel() {
	Inherit(this, Object3D);
	const _this = this;
	!async function() {
		_this.layout = _this.initClass(SceneLayout, Utils.getConstructorName(_this)), _this.layers = await _this.layout.getAllLayers()
	}()
})), Class((function TunnelImages(_proton, _group, _input) {
	Inherit(this, Object3D);
	const _this = this;
	let _mesh, _time, _currentTimeLimit, _indexOffset, _imageShiftStateProgram, _imageshiftStateFBO = {};

	function animateIn(args) {
		const {
			immediate: immediate,
			duration: duration
		} = args;
		immediate && _mesh.shader.set("uReveal", 1), _mesh.shader.tween("uReveal", 1, duration, "easeInOutCubic")
	}

	function animateOut(args) {
		const {
			immediate: immediate,
			duration: duration
		} = args;
		immediate && _mesh.shader.set("uReveal", 1), _mesh.shader.tween("uReveal", 0, duration, "easeInOutCubic")
	}

	function loop(t, dt) {
		_imageShiftStateProgram.shader.set("tImageShift", _imageshiftStateFBO.read), World.RENDERER.renderSingle(_imageShiftStateProgram, World.CAMERA, _imageshiftStateFBO.write);
		let tmp = _imageshiftStateFBO.read;
		_imageshiftStateFBO.read = _imageshiftStateFBO.write, _imageshiftStateFBO.write = tmp, _mesh.shader.set("tImageShiftState", _imageshiftStateFBO.read)
	}!async function() {
		! function initPositions() {
			let vertices = _proton.antimatter.vertices,
				count = vertices.buffer.length / 4;
			const TAU = 2 * Math.PI,
				sliceCount = Math.floor(Math.sqrt(count)),
				imagesPerSliceCount = sliceCount;
			let vertexIterator = 0;
			for (let i = 0; i < sliceCount; i++)
				for (let j = 0; j < imagesPerSliceCount; j++) {
					let phase = (j + .5) / imagesPerSliceCount,
						angle = Math.range(phase, 0, 1, 0, TAU);
					vertices.buffer[vertexIterator++] = Math.cos(angle), vertices.buffer[vertexIterator++] = Math.map(i + .5, 0, sliceCount - 1, -1, 1), vertices.buffer[vertexIterator++] = Math.sin(angle), vertices.buffer[vertexIterator++] = i / sliceCount
				}
			vertices.needsUpdate = !0
		}(),
		function initImageShifting() {
			let textureSize = _proton.antimatter.textureSize,
				count = _proton.antimatter.vertices.buffer.length / 4;
			const imageShiftData = new Float32Array(4 * count);
			let initImageShiftDataIterator = 0;
			for (let i = 0; i < count; i++) imageShiftData[initImageShiftDataIterator++] = 1, imageShiftData[initImageShiftDataIterator++] = Math.map(Math.random(), 0, 1, .01, .1), imageShiftData[initImageShiftDataIterator++] = 0, imageShiftData[initImageShiftDataIterator++] = Math.map(Math.random(), 0, 1, .2, .7);
			let format = Texture.RGBAFormat,
				type = "ios" == Device.system.os ? Texture.HALF_FLOAT : Texture.FLOAT;
			const options = {
					type: type,
					minFilter: Texture.NEAREST,
					magFilter: Texture.NEAREST,
					format: format,
					generateMipmaps: !1
				},
				initImageShift = new DataTexture(imageShiftData, textureSize, textureSize, format, type);
			initImageShift.destroyDataAfterUpload = !0, _imageshiftStateFBO.read = new RenderTarget(textureSize, textureSize, options), _imageshiftStateFBO.write = new RenderTarget(textureSize, textureSize, options);
			const program = _this.initClass(Shader, "ImageShiftState", {
				tImageShift: {
					value: initImageShift,
					ignoreUIL: !0
				},
				uSpeed: {
					value: 1
				},
				uMinMaxLifeRate: {
					value: new Vector2(.001, .005)
				},
				uSmoothstepMinMax: {
					value: new Vector2(.3, .7)
				}
			});
			ShaderUIL.add(program).setLabel("Image shift Params"), _imageShiftStateProgram = new Mesh(World.QUAD, program)
		}(),
		function initMesh() {
			const geo = (new Geometry).instanceFrom(new PlaneGeometry(.5, .5, 1, 1));
			_proton.applyToInstancedGeometry(geo);
			const program = _this.initClass(Shader, "TunnelImages", {
				tMap: {
					value: Utils3D.getTexture("assets/images/test/spritesheet1k.png")
				},
				tImageShiftState: {
					value: _imageshiftStateFBO.read.texture
				},
				uGridCount: {
					value: new Vector2(4, 4)
				},
				uImageScale: {
					value: 1
				},
				uTunnelRadius: {
					value: 10
				},
				uTunnelHeight: {
					value: 20
				},
				uLowResTunnel: {
					value: 0
				},
				uReveal: {
					value: Global.PLAYGROUND ? 1 : 0
				},
				uRevealOffsetScale: {
					value: .5
				},
				uParabolaPow: {
					value: 1
				},
				uShuffleAnimPhase: {
					value: 0
				},
				uIndexOffset: {
					value: 0
				},
				receiveShadow: !1,
				transparent: !0
			});
			program.side = Shader.DOUBLE_SIDE, _proton.applyToShader(program), ShaderUIL.add(program, _group).setLabel("Shader"), _mesh = new Mesh(geo, program), _this.add(_mesh)
		}(),
		function addHandlers() {
			_this.events.sub(ImageCloud.REVEAL_IMAGES, animateIn), _this.events.sub(ImageCloud.HIDE_IMAGES, animateOut)
		}(), _indexOffset = 0, _time = 0, _currentTimeLimit = [1500, 3e3, 5e3].random(), _this.startRender(loop)
	}(), this.loop = loop, this.get("proton", (_ => _proton))
})), Class((function InsideLidar(_input, _group) {
	Inherit(this, BaseInside, {
		scenelayout: "InsideLidar"
	});
	const _this = this;
	let _val = 1;
	const _uniforms = {
			uLidarPosition: [0, 0, 0],
			uLidarRotation: [0, 0, 0, 1],
			uLidarScale: [1, 1, 1],
			uRandomSize: [.5, 2],
			uColor: new Color("#4d91ff")
		},
		LIDAR_CONFIG = [{
			name: "fairground"
		}, {
			name: "subway"
		}, {
			name: "house"
		}];
	let _proton, _activeLidar;

	function updateLidarUniform(uniform, _val) {
		if (!_activeLidar) return;
		const UIL = LIDAR_CONFIG.find((l => l.name === _activeLidar)).UIL;
		let val;
		switch (val = _val || UIL.get(uniform), uniform) {
			case "uLidarPosition":
			case "uLidarRotation":
			case "uLidarScale":
				_proton.behavior.shader.uniforms[uniform].value.set(...val)
		}
	}
	_this.init = async function() {
		! function addSettings() {
			LIDAR_CONFIG.forEach((lidar => {
				lidar.UIL = InputUIL.create(`Lidar ${lidar.name.capitalize()} Settings`), Object.keys(_uniforms).forEach((uniform => {
					const val = _uniforms[uniform];
					if ("uColor" === uniform) lidar.UIL.addColor(uniform, val);
					else lidar.UIL.addVector(uniform, val)
				})), lidar.UIL.onUpdate = updateLidarUniform
			}))
		}(), _proton = _this.layers.lidar, await _proton.ready(), _proton.mesh.frustumCulled = !1, Dev.expose("showLidar", (() => {
			_this.onShow()
		})), Dev.expose("hideLidar", (() => {
			_this.onHide()
		})), Global.PLAYGROUND && _this.onShow(), _this.startRender((time => {
			_proton.behavior.shader.set("uLidarTime", _val), _val += .01
		}))
	}, _this.onReset = function() {
		_activeLidar = null, _proton.behavior.shader.set("uReset", 1)
	}, _this.onShow = function(_data) {
		_this.visible = !0;
		const data = _data?.artPiece?.hotspotDetail?.environmentTemplate;
		data && (_activeLidar = function getLidarGeometry(name) {
			return name ?? LIDAR_CONFIG.random()
		}().name, function setLidarPointCloud(name) {
			const path = `assets/geometry/lidar/${name}/${name}`;
			_proton.setPointCloud(path)
		}(_activeLidar), function setLidarUniformsOnEnter({
			color: color,
			particleSize: particleSize,
			particleAmount: particleAmount
		}) {
			let amount, sizeRange;
			switch (particleAmount) {
				case "more":
					amount = Tests.lidarParticleAmountMore();
					break;
				case "normal":
					amount = Tests.lidarParticleAmountNormal();
					break;
				case "less":
					amount = Tests.lidarParticleAmountLess()
			}
			switch (particleSize) {
				case "large":
					sizeRange = [.8, 1.1];
					break;
				case "medium":
					sizeRange = [.4, .8];
					break;
				case "small":
					sizeRange = [.2, .5]
			}
			_proton.mesh.shader.set("uColor", new Color(color)), _proton.mesh.shader.set("uRandomSize", new Vector2(...sizeRange)), Object.keys(_uniforms).forEach((uniform => {
				updateLidarUniform(uniform)
			}))
		}({
			color: data.color1.hex,
			particleSize: data.particleSize,
			particleAmount: data.particleAmount
		}), _proton.behavior.shader.set("uReset", 1), _this.delayedCall((() => {
			_proton.behavior.shader.set("uReset", 0)
		}), 100), _proton.behavior.shader.set("uForm", 0), _proton.mesh.shader.set("uTransition", 0), _proton.mesh.shader.tween("uTransition", 1, 5e3, "linear", 0), _proton.behavior.shader.tween("uForm", 1, 1e4, "easeInOutSine", 4e3))
	}, _this.onHide = function() {
		_proton.behavior.shader.tween("uForm", 0, 400, "easeInOutSine"), _proton.mesh.shader.tween("uTransition", 0, 400, "easeInOutSine")
	}
})), Class((function LidarPointCloud(_proton, _group, _input) {
	Inherit(this, Object3D);
	let _shader, _vertices, _count;
	! function() {
		_shader = _proton.mesh.shader, _vertices = _proton.antimatter.vertices, _count = _vertices.buffer.length / 4;
		let sliceCount = Math.floor(Math.sqrt(_count));
		const particlesPerSliceCount = sliceCount;
		let vertexIterator = 0;
		const TAU = 2 * Math.PI;
		let particleIterator = 0;
		for (let i = 0; i < sliceCount; i++)
			for (let j = 0; j < particlesPerSliceCount; j++) {
				let c = particleIterator / _count,
					angle = Math.range(c, 0, 1, 0, TAU);
				_vertices.buffer[vertexIterator++] = 7 * Math.cos(angle), _vertices.buffer[vertexIterator++] = 1, _vertices.buffer[vertexIterator++] = 7 * Math.sin(angle), _vertices.buffer[vertexIterator++] = c, particleIterator++
			}
		_vertices.needsUpdate = !0
	}()
})), Class((function InsideBg(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		uColor: {
			value: new Color("#ff0000")
		},
		uColorSecond: {
			value: new Color("#ff0000")
		},
		uTransition: {
			value: 0
		}
	})
})), Class((function InsideFog(_input, _group) {
	Inherit(this, Object3D);
	const _this = this,
		_originalInput = _input;
	var _input, _shader, _batch;
	let _rt;

	function initShader() {
		_shader = _this.initClass(Shader, "InsideFogShader", {
			tMap: {
				value: Utils3D.getTexture("assets/images/inside/cloud.jpg"),
				ignoreUIL: !0
			},
			uColor: {
				value: new Color
			},
			uFadeDist: {
				value: new Vector2(2, 6)
			},
			uFadeFloor: {
				value: new Vector2(0, .08)
			},
			uAppear: {
				value: 1,
				ignoreUIL: !0
			},
			uScale: {
				value: 1
			},
			uSpeed: {
				value: 1
			},
			uNoiseScale: {
				value: .55
			},
			uNoiseTime: {
				value: .15
			},
			uNoiseStrength: {
				value: 1
			},
			uCullDistance: {
				value: 999
			},
			transparent: !0,
			depthWrite: !1,
			depthTest: !1,
			blending: Shader.ADDITIVE_BLENDING,
			UILPrefix: `${_originalInput.prefix}_cloud`
		})
	}

	function initMesh() {
		let total = eval(_input.get("planes")),
			width = _input.get("width"),
			height = _input.get("height"),
			depth = _input.get("depth");
		_batch = _this.initClass(MeshBatch), _batch.static = !0, _this.add(_batch.group);
		for (let i = 0; i < total; i++) {
			let mesh = new Mesh(World.PLANE, _shader);
			const radius = Math.random(4, 10, 3),
				teta = Math.random(0, 2 * Math.PI);
			mesh.position.x = radius * Math.cos(teta), mesh.position.y = Math.random(height[0], height[1], 4), mesh.position.z = radius * Math.sin(teta), mesh.attributes = {
				random: new Vector4(Math.random(), Math.random(), Math.random(), Math.random())
			}, _batch.add(mesh)
		}
	}
	Tests.renderInsideFog() ? ((_input = InputUIL.create(`${_input.prefix} CloudFog`, _group)).setLabel("CloudFog"), _input.add("planes", 20), _input.addVector("width", [-1, 1]), _input.addVector("height", [-1, 1]), _input.addVector("depth", [-1, 1]), _input.addVector("fadeDist", [2, 6]), _input.addNumber("scale", 1, .05), _input.addNumber("alpha", 1, .05), _input.addNumber("speed", 1, .05), _input.addNumber("noise", 0, .05), _input.addNumber("cullDistance", 999), initShader(), initMesh(), ShaderUIL.add(_shader, _group).setLabel("Fog Shade")) : _this.group.visible = !1, this.show = function() {
		_shader && (_shader.set("uAppear", 0), _shader.tween("uAppear", 1, 3e3, "easeOutCirc"))
	}, this.hide = function() {
		_shader && _shader.tween("uAppear", 0, 4e3, "easeInOutCubic")
	}
})), Class((function Swirl() {
	let colors, shader, behavior, mesh;
	Inherit(this, BaseInside, {
		scenelayout: "swirl_env"
	});
	const _this = this;
	_this.init = async function() {
		_this.particles = _this.layers.particles, await _this.particles.tubes.ready(), _this.particles.tubes.useColor(), shader = _this.particles.tubes.shader, behavior = _this.particles.behavior.shader, mesh = _this.particles.tubes.mesh, _this.mesh = mesh, _this.particles.mesh.frustumCulled = !1, _this.mesh.frustumCulled = !1, colors = [new Color("#F06449"), new Color("#EDE6E3"), new Color("#DADAD9"), new Color("#36382E"), new Color("#5BC3EB")], updateType("fidenza"), _this.startRender((() => {
			let origin = new Vector3(0, 0, 0);
			origin.cylinder = !0, origin.height = 5, _this.particles.tubes.release(origin, 1, 10, new Vector3(1, 0, 0), colors[Math.floor(colors.length * Math.random())])
		})), Global.PLAYGROUND && _this.onShow()
	}, updateType = type => {
		switch (type) {
			case "fidenza":
				shader.set("useGlowEffect", 0), shader.set("thickness", .7), shader.depthTest = !0, shader.depthWrite = !0, shader.blending = Shader.NORMAL_BLENDING;
				break;
			case "glow":
				shader.set("useGlowEffect", 1), shader.set("thickness", 2.5), shader.depthTest = !0, shader.depthWrite = !1, shader.blending = Shader.ADDITIVE_BLENDING;
				break;
			case "cylinder":
				shader.set("useGlowEffect", 0), shader.set("thickness", 1), behavior.set("uCurlNoiseSpeed", 0), shader.depthTest = !0, shader.depthWrite = !0, shader.blending = Shader.NORMAL_BLENDING
		}
	}, _this.onShow = function(data) {
		_this.visible = !1, shader.set("uTransition", 0), shader.tween("uTransition", 1, 500, "linear", 600).onUpdate((() => {
			_this.visible = !0
		}));
		let info = data?.artPiece?.hotspotDetail?.environmentTemplate;
		if (updateType(info?.type || "fidenza"), info?.colors && info.colors.map(((e, index) => {
				colors[index] = new Color(e.hex)
			})), info?.thickness) switch (info.thickness) {
			case "thick":
				shader.set("thickness", 2.5);
				break;
			case "medium":
				shader.set("thickness", 1);
				break;
			case "thin":
				shader.set("thickness", .7)
		}
		if (info?.speed) switch (info.thickness) {
			case "slow":
				behavior.set("speed", .2);
				break;
			case "medium":
				behavior.set("speed", .6);
				break;
			case "fast":
				behavior.set("speed", 2)
		}
	}, _this.onHide = function() {
		shader.tween("uTransition", 0, 500).onComplete((() => {
			_this.visible = !1
		}))
	}
})), Class((function Kinetic() {
	Inherit(this, Object3D);
	const _this = this;
	!async function() {
		if (_this.layout = _this.initClass(SceneLayout, "kinetic"), _this.layers = await _this.layout.getAllLayers(), !Tests.renderKinetic()) return _this.group.visible = !1, void(_this.layout.group.visible = !1);
		! function init() {
			_this.layers.ring.visible = !1;
			let batch = new MeshBatch;
			batch.static = !0, _this.add(batch.group);
			const TOTAL = 9,
				SCALES = [.01, .015, .022, .033, .048, .068, .095, .13, .19];
			for (let i = 0; i < TOTAL; i++) {
				const mesh = _this.layers.ring.clone(),
					scale = SCALES[i];
				mesh.scale.setScalar(scale), mesh.attributes = {
					id: i / TOTAL
				}, batch.add(mesh)
			}
		}()
	}()
})), Class((function KineticShader(_mesh, _shader, _group, _input) {
	Inherit(this, FBR, _shader);
	_shader.addUniforms({})
})), Class((function Landing() {
	Inherit(this, Component), Inherit(this, StateComponent);
	const _this = this;
	let _env, _ui, _camera;

	function onLoaderOut() {
		TrackAnalytics.track("LoadingFinished"), _this.tweenin = tween(_camera, {
			zoomOffset: 0
		}, 5e3, "easeOutSine"), _ui.animateIn(), GLUIWrapper.instance().show()
	}

	function enterClick() {
		TrackAnalytics.track("LandingClicked"), enterIn(),
			function endLanding() {
				_this.commit(UIStore, "setView", null), _ui.animateOut();
				let cam = _env.player.controls.first;
				cam.transition(2e3, "easeInOutCubic"), _env.player.controls.enable(), _this.delayedCall((() => {
					Camera.instance().lock(_env.player.controls.camera.worldCamera), cam.lock(_env.player.controls.camera)
				}), 2500), tween(_this, {
					forceScale: 0
				}, 900, "easeInCubic", 400).onComplete((() => {
					_this.visible = !1
				}))
			}()
	}

	function enterIn() {
		_this.tweenin && _this.tweenin.stop(), _camera.zoomOffset = -1
	}

	function enterOut() {
		_camera.zoomOffset = 0
	}
	_this.forceScale = 1, async function() {
		Platform.usingVR() || (Utils.query("spawnDebug") || Utils.query("skip") ? _this.commit(UIStore, "setView", null) : (_env = AbstractEnvironment.findParent(_this), _camera = _env.layers.landing_camera, await _this.wait(_env, "player"), await defer(), PlayerSettings.instance().state.camera = "1st", function disablePlayer() {
			_env.player.controls.disable()
		}(), function lockCamera() {
			_camera.lock()
		}(), function initUI() {
			_ui = _this.initClass(LandingUI), GlobalUI.instance().element.add(_ui)
		}(), function addListeners() {
			_this.events.sub(LandingUIEnter.CLICK, enterClick), _this.events.sub(LandingUIEnter.OVER, enterIn), _this.events.sub(LandingUIEnter.OUT, enterOut), _camera.zoomOffset = 5, _this.events.sub(LoaderView.ANIMATING_OUT, onLoaderOut)
		}(), _this.startRender((() => {
			_env.player.group.scale.setScalar(_this.forceScale)
		}), RenderManager.AFTER_LOOPS)))
	}()
})), Class((function LandingGazeCamera(_input, _group) {
	Inherit(this, BaseCamera);
	const _this = this;
	var _strength = {
			v: 1
		},
		_cacheObj = {},
		_move = new Vector3,
		_position = new Vector3,
		_wobble = new Vector3,
		_rotation = 0,
		_wobbleAngle = Math.radians(Math.rand(0, 360)),
		_innerGroup = new Group,
		_viewportFocusOffset = new Vector3,
		_hasViewportFocusOffset = !1,
		_manualRender = !1,
		_quaternion = new Quaternion;

	function loop() {
		if (_hasViewportFocusOffset && _this.camera.position.sub(_viewportFocusOffset), _this.useAccelerometer && Mobile.Accelerometer && Mobile.Accelerometer.connected) _move.x = _this.position.x, _move.z = _this.position.z + Math.range(Mobile.Accelerometer.x, -2, 2, -1, 1, !0) * _strength.v * _this.moveXY.x * _this.strength, _move.y = 0;
		else {
			_move.x = _this.position.x, _move.z = _this.position.z + Math.range(Mouse.x, 0, Stage.width, -1, 1, !0) * _strength.v * _this.moveXY.x * _this.strength, _move.y = _this.position.y + Math.range(Mouse.y, 0, Stage.height, -1, 1, !0) * _strength.v * _this.moveXY.y * _this.strength;
			let rotateStrength = Math.range(Math.abs(Mouse.delta.x) / Stage.width, 0, .02, 0, 1, !0);
			_rotation = Math.lerp(Math.radians(_this.deltaRotate) * rotateStrength * Math.sign(Mouse.delta.x), _rotation, .02 * _this.deltaLerp * _strength.v), _innerGroup.rotation.z = Math.lerp(_rotation, _innerGroup.rotation.z, .07 * _this.deltaLerp)
		}
		if (_position.lerp(_move, _this.lerpSpeed2), _position.x += _this.zoomOffset, _this.camera.position.lerp(_position, _this.lerpSpeed), _this.camera.lookAt(_this.lookAt), (Math.abs(_this.cameraRotation.x) > Base3D.DIRTY_EPSILON || Math.abs(_this.cameraRotation.y) > Base3D.DIRTY_EPSILON || Math.abs(_this.cameraRotation.z) > Base3D.DIRTY_EPSILON) && (_quaternion.setFromEuler(_this.cameraRotation), _this.camera.quaternion.multiply(_quaternion)), function focusViewport() {
				let nextHasViewportFocusOffset = Math.abs(_this.viewportFocus.x) > 1e-4 || Math.abs(_this.viewportFocus.y) > 1e-4;
				nextHasViewportFocusOffset !== _hasViewportFocusOffset && (nextHasViewportFocusOffset || _viewportFocusOffset.setScalar(0), _hasViewportFocusOffset = nextHasViewportFocusOffset);
				if (!_hasViewportFocusOffset) return;
				let localCamera = _cacheObj,
					camera = _this.camera;
				camera.matrixDirty && camera.updateMatrix();
				localCamera.matrixWorld = camera.matrix, localCamera.projectionMatrix = camera.projectionMatrix, _viewportFocusOffset.copy(_this.lookAt).project(localCamera), _viewportFocusOffset.x -= _this.viewportFocus.x, _viewportFocusOffset.y -= _this.viewportFocus.y, _viewportFocusOffset.unproject(localCamera), _viewportFocusOffset.sub(_this.lookAt), _this.camera.position.add(_viewportFocusOffset)
			}(), _this.wobbleStrength > 0) {
			let t = Render.TIME;
			_wobble.x = Math.cos(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed)) * (_wobbleAngle + 200 * Math.sin(t * (95e-5 * _this.wobbleSpeed))), _wobble.y = Math.sin(Math.asin(Math.cos(_wobbleAngle + t * (85e-5 * _this.wobbleSpeed)))) * (150 * Math.sin(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed))), _wobble.x *= 2 * Math.sin(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed)), _wobble.y *= 1.75 * Math.cos(_wobbleAngle + t * (65e-5 * _this.wobbleSpeed)), _wobble.x *= 1.1 * Math.cos(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed)), _wobble.y *= 1.15 * Math.sin(_wobbleAngle + t * (25e-5 * _this.wobbleSpeed)), _wobble.z = Math.sin(_wobbleAngle + .0025 * _wobble.x) * (100 * _this.wobbleZ), _wobble.multiplyScalar(.001 * _this.wobbleStrength * _strength.v), _innerGroup.position.lerp(_wobble, .07)
		}
	}
	this.strength = 1, this.moveXY = new Vector2(4, 4), this.position = new function Position() {
			Inherit(this, Component);
			var _x = 0,
				_y = 0,
				_z = 0;
			this.get("x", (_ => _x)), this.get("y", (_ => _y)), this.get("z", (_ => _z)), this.set("x", (x => {
				_x = x
			})), this.set("y", (y => {
				_y = y
			})), this.set("z", (z => {
				_z = z, _move.z = _z, _this.camera.position.copy(_move), _position.copy(_move)
			})), this.set = function(x, y, z, noCopy) {
				_x = x, _y = y, _z = z, _move.z = z, noCopy || _this.camera.position.copy(_move), _position.copy(_move)
			}, this.toArray = function() {
				return [_x, _y, _z]
			}, this.fromArray = function(array) {
				_x = array[0], _y = array[1], _z = array[2], _move.set(_x, _y, _z), _this.camera.position.copy(_move), _position.copy(_move)
			}, this.copy = function(vec) {
				_x = vec.x, _y = vec.y, _z = vec.z, _move.set(_x, _y, _z), _this.camera.position.copy(_move), _position.copy(_move)
			}
		}, this.lerpSpeed = .05, this.lerpSpeed2 = 1, this.lookAt = new Vector3(0, 0, 0), this.cameraRotation = new Euler, this.viewportFocus = new Vector2(0, 0), this.deltaRotate = 0, this.deltaLerp = 1, this.wobbleSpeed = 1, this.wobbleStrength = 0, this.wobbleZ = 1, this.zoomOffset = 0,
		function() {
			if (_input) {
				_this.prefix = _input.prefix;
				let cameraUIL = CameraUIL.add(_this, _group);
				cameraUIL.setLabel("Camera"), _this.group._cameraUIL = cameraUIL
			}
			_this.startRender(loop), _innerGroup.add(_this.camera), _this.group.add(_innerGroup)
		}(), this.orbit = function(time = 1e3, ease = "easeInOutSine") {
			return tween(_strength, {
				v: 1
			}, time, ease)
		}, this.still = function(time = 300, ease = "easeInOutSine") {
			return tween(_strength, {
				v: 0
			}, time, ease)
		};
	var _v1 = new Vector3,
		_v2 = new Vector3,
		_v3 = new Vector3;
	this.move = function(vec) {
		let moveDiff = _v1.subVectors(_move, _this.position),
			positionDiff = _v2.subVectors(_move, _position),
			cameraPosDiff = _v3.subVectors(_this.camera.position, _position);
		_this.position.set(vec.x, vec.y, vec.z, !0), _move.copy(vec).add(moveDiff), _position.copy(_move).add(positionDiff), _this.camera.position.copy(_position).add(cameraPosDiff)
	}, this.get("manualRender", (() => _manualRender)), this.set("manualRender", (value => {
		(value = !!value) !== _manualRender && ((_manualRender = value) ? _this.stopRender(loop) : _this.startRender(loop))
	})), this.update = function() {
		_manualRender || !Hydra.LOCAL || _this.flag("manualRenderWarned") || (console.warn("Set manualRender to true if using GazeCamera.update()"), _this.flag("manualRenderWarned", !0)), loop()
	}
})), Class((function LandingUI() {
	Inherit(this, Element), Inherit(this, StateComponent);
	const _this = this,
		$this = _this.element;
	let _title, _titleInner, _titleInnerMobile, _subtitle, _desc, _button, _disclaimer;

	function onModalChange(modal) {
		modal ? (_this.animateOut(!1), _button.animateOut(!1)) : !1 === modal && _this.animateIn()
	}
	async function animateIn() {
		await _this.wait(800), $this.tween({
			opacity: 1
		}, 900, "easeOutCubic", 400), _titleInner.tween({
			y: "0%"
		}, 1200, "easeOutCubic"), _titleInnerMobile.tween({
			y: "0%"
		}, 1200, "easeOutCubic"), await _this.wait(800), _subtitle.split.words.forEach(((w, i) => {
			w.tween({
				y: "0%"
			}, 1200, "easeOutCubic", 100 * i)
		})), _disclaimer.split.words.forEach(((w, i) => {
			w.tween({
				y: "0%"
			}, 1200, "easeOutCubic", 100 * i)
		})), _desc.split.words.forEach(((w, i) => {
			w.tween({
				y: "0%"
			}, 1e3, "easeOutCubic", 300 * w.div.__line)
		})), await _this.wait(600), _button.animateIn()
	}
	async function animateOut(shouldDestroy = !0) {
		_titleInner.tween({
			y: "-100%"
		}, 800, "easeInCubic"), _titleInnerMobile.tween({
			y: "-100%"
		}, 800, "easeInCubic"), await _this.wait(100), _disclaimer.split.words.forEach(((w, i) => {
			w.tween({
				y: "-100%"
			}, 800, "easeInCubic", 40 * i)
		})), _subtitle.split.words.forEach(((w, i) => {
			w.tween({
				y: "-100%"
			}, 800, "easeInCubic", 40 * i)
		})), await _this.wait(100), _desc.split.words.forEach(((w, i) => {
			w.tween({
				y: "-100%"
			}, 600, "easeInCubic", 100 * w.div.__line)
		})), $this.tween({
			opacity: 0
		}, 900, "easeOutCubic", 400), await _this.wait(1500), shouldDestroy && _this.destroy()
	}!async function() {
		await AppCMSConfig.ready(), await LandingText.ready(), await defer(),
			function initHTML() {
				_title = $this.create("title", "h1"), _title.attr("aria-label", "Iconic Mints"), _disclaimer = $this.create("disclaimer", "p"), _disclaimer.attr("aria-label", LandingText?.data?.disclaimer), _disclaimer.html(LandingText?.data?.disclaimer), Global.LOADER.add(1), _titleInner = _title.create("title-inner", "img"), _titleInner.bind("load", (() => {
					Global.LOADER.trigger(1)
				})), _titleInner.attr("src", "./assets/images/landing/logo.svg"), _titleInner.transform({
					y: "100%"
				}), Global.LOADER.add(1), _titleInnerMobile = _title.create("title-inner-mobile", "img"), _titleInnerMobile.bind("load", (() => {
					Global.LOADER.trigger(1)
				})), _titleInnerMobile.attr("src", "./assets/images/landing/logo-mobile.svg"), _titleInnerMobile.transform({
					y: "100%"
				}), _subtitle = $this.create("subtitle", "h2"), _subtitle.html(LandingText?.data?.leftCol), _desc = $this.create("desc"), _desc.html(LandingText?.data?.rightCol), SplitText.isFontReady().then((async () => {
					await defer(),
						function splitDisclaimer() {
							_disclaimer.split = _this.initClass(SplitText, _disclaimer), _disclaimer.split.lines.forEach((l => l.css({
								overflow: "hidden"
							}))), _disclaimer.split.words.forEach((w => w.transform({
								y: "100%"
							})))
						}(),
						function splitSubtitle() {
							_subtitle.split = _this.initClass(SplitText, _subtitle), _subtitle.split.lines.forEach((l => l.css({
								overflow: "hidden"
							}))), _subtitle.split.words.forEach((w => w.transform({
								y: "100%"
							})))
						}(),
						function splitDesc() {
							_desc.split = _this.initClass(SplitText, _desc), _desc.split.lines.forEach((l => l.css({
								overflow: "hidden"
							}))), _desc.split.words.forEach((w => w.transform({
								y: "100%"
							})))
						}()
				})), _button = _this.initClass(LandingUIEnter, [$this])
			}(),
			function initStyles() {
				$this.goob(`\n          & {\n            position: fixed;\n            top: 0;\n            left: 0;\n            right: 0;\n            bottom: 0;\n            z-index: 0;\n            color: #fff;\n            background: linear-gradient(180deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0));\n          }\n\n          .title {\n            ${StyleGuide.manropeMedium}\n            ${StyleGuide.fluid("left",StyleGuide.lateralPadding)}\n            ${StyleGuide.fluid("right",StyleGuide.lateralPadding)}\n            width: auto;\n            top: 120px;\n            font-size: 17.5vw;\n            display: flex;\n            justify-content: space-between;\n            line-height: 0.81;\n            transform-origin: 50% 0%;\n            overflow: hidden;\n            will-change: transform;\n\n\n            @media (max-height: 680px) and (orientation: landscape) {\n                top: 80px;\n            }\n          }\n\n          .title-inner {\n            position: relative!important;\n            width: 100%;\n\n            ${StyleGuide.smaller(600,"\n              display: none;\n            ")}\n          }\n\n          .title-inner-mobile {\n            position: relative!important;\n            width: 100%;\n            display: none;\n\n            ${StyleGuide.smaller(600,"\n              display: block;\n            ")}\n          }\n\n          .subtitle {\n            ${StyleGuide.manropeRegular}\n            text-align: left;\n            text-transform: uppercase;\n            line-height: 1.16;\n            ${StyleGuide.fluid("left",StyleGuide.lateralPadding)}\n            top: calc(120px + 17vw);\n            font-size: 1.5vw;\n\n            ${StyleGuide.smaller("l","\n              font-size: 2.4vw;\n            ")}\n\n            ${StyleGuide.smaller(600,"\n              visibility: hidden;\n            ")}\n\n            @media (max-height: 680px) and (orientation: landscape) {\n                top: calc(80px + 17vw);\n            }\n          }\n\n          .disclaimer {\n            ${StyleGuide.manropeRegular}\n            ${StyleGuide.fluid("left",StyleGuide.lateralPadding)}\n            ${StyleGuide.fluid("right",StyleGuide.lateralPadding)}\n            line-height: 1.33;\n            bottom: 30px;\n            text-align: center;\n            ${StyleGuide.fluid("font-size",{mob:9,xl:10})}\n            ${StyleGuide.smaller("l","\n              top: auto;\n              bottom: 60px;\n              font-size: 9px;\n            ")}\n            font-style: italic !important;\n            color: #fff;\n          }\n\n          .desc {\n            ${StyleGuide.manropeMedium}\n            ${StyleGuide.fluid("right",StyleGuide.lateralPadding)}\n            line-height: 1.33;\n            top: calc(120px + 17vw);\n            font-size: 1vw;\n            text-align: right;\n\n            ${StyleGuide.smaller("l","\n              visibility: hidden;\n            ")}\n          }\n\n          .button {\n            left: 50%;\n            transform: translateX(-50%);\n            bottom: 100px;\n            font-size: 40px;\n          }\n        `)
			}(), PortalUtil.isPortal && $this.hide(), _this.isPlayground() && (_this.delayedCall(animateIn, 500), _this.delayedCall(animateOut, 4e3)), _this.bindState(UIStore, "modal", onModalChange)
	}(), this.animateIn = animateIn, this.animateOut = animateOut
})), Class((function LandingUIEnter() {
	Inherit(this, Element);
	const _this = this,
		$this = _this.element;
	let _wrapper, _container0, _container1, _arrow0, _arrow1, _basis = 0,
		_basisLerp = 0;

	function animateOut(shouldFlag = !0) {
		_this.flag("animateOut", shouldFlag), shouldFlag && _arrow1.tween({
			y: -25
		}, 800, "easeInOutCubic", 0), tween(_this, {
			clip: 0
		}, 1400, "easeInOutCubic").onUpdate((() => {
			_wrapper.div && (_wrapper.div.style.clipPath = `ellipse(${_this.clip}% ${_this.clip}% at 50% 50%)`)
		}))
	}

	function loop() {
		_basisLerp = Math.lerp(_basis, _basisLerp, .23), _container1.css({
			flexBasis: `${_basisLerp}%`
		})
	}

	function onHover(e) {
		if (_this.flag("animateOut")) return;
		const isOver = "over" === e.action;
		_basis = isOver ? 102 : 0, _this.events.fire(isOver ? LandingUIEnter.OVER : LandingUIEnter.OUT)
	}
	async function onClick() {
		_this.flag("clicked") || (_this.flag("clicked", !0), _basis = 102, animateOut(), await _this.wait(400), _this.events.fire(LandingUIEnter.CLICK), UITransparentBar.instance().animateIn())
	}!async function() {
		! function initHTML() {
			_wrapper = $this.create("wrapper"), _container0 = _wrapper.create("container"), _container0.classList().add("container0"), _arrow0 = _container0.create("arrow"), _arrow0.html(LandingUIEnter.ARROW), _container1 = _wrapper.create("container"), _container1.classList().add("container1"), _arrow1 = _container1.create("arrow"), _arrow1.html(LandingUIEnter.ARROW)
		}(), await GlobalUI.instance().sponsors.hasData, GlobalUI.instance().sponsors?.sponsors?.length && $this.classList().add("hasSponsors"),
			function initStyles() {
				$this.goob(`\n            & {\n              width: 104px;\n              height: 52px;\n              bottom: 50px;\n\n              left: 50%;\n              transform: translateX(-50%);\n\n              @media (max-height: 680px) and (orientation: landscape) {\n                bottom: 30px;\n              }\n\n              ${StyleGuide.smaller(StyleGuide.mobileBreakpoint,"\n                &.hasSponsors {\n                  bottom: 80px !important;\n                }\n              ")}\n            }\n\n            .wrapper {\n              display: flex;\n              flex-direction: column;\n              /*justify-content: center;\n              align-items: center;*/\n              width: 100%;\n              height: 100%;\n              background: ${StyleGuide.colors.white};\n              clip-path: ellipse(0% 0% at 50% 50%);\n              will-change: transform;\n            }\n\n            .container {\n              position: relative!important;\n              display: flex;\n              align-items: center;\n              justify-content: center;\n            }\n\n            .container0 {\n              background: white;\n              flex: 1;\n            }\n\n            .container1 {\n              background: ${StyleGuide.colors.royalBlue};\n              flex-basis: 0%;\n\n              .arrow path {\n                stroke: ${StyleGuide.colors.white};\n              }\n            }\n\n            .arrow {\n              font-size: 0;\n\n              svg {\n                position: relative!important;\n              }\n            }\n        `)
			}(),
			function addListeners() {
				$this.interact(onHover, onClick)
			}(), _this.startRender(loop)
	}(), this.animateIn = function animateIn() {
		_this.clip = 0, _arrow0.transform({
			y: 35
		}), tween(_this, {
			clip: 50
		}, 1700, "easeOutCubic").onUpdate((() => {
			_wrapper.div && (_wrapper.div.style.clipPath = `ellipse(${_this.clip}% ${_this.clip}% at 50% 50%)`)
		})), _arrow0.tween({
			y: 0
		}, 1400, "easeOutCubic", 200)
	}, this.animateOut = animateOut
}), (_ => {
	LandingUIEnter.ARROW = '<svg width="14" height="17" viewBox="0 0 14 17" fill="none" xmlns="http://www.w3.org/2000/svg">\n      <path d="M7 1L7 16.15" stroke="black" stroke-width="0.85" stroke-linecap="round"/>\n      <path d="M0.5 7.5L7 1L13.5 7.5" stroke="black" stroke-linecap="round" stroke-linejoin="round"/>\n    </svg>', LandingUIEnter.CLICK = "LandingUIEnter.ENTER_CLICK", LandingUIEnter.OVER = "LandingUIEnter.OVER", LandingUIEnter.OUT = "LandingUIEnter.OUT"
})), Class((function LightShaftShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	! function() {
		if (!Tests.renderLightShafts()) return void(_mesh.visible = !1);
		let _tex = Utils3D.getRepeatTexture("assets/images/lightshaft/light-mask.jpg"),
			_noise = Utils3D.getRepeatTexture("assets/images/lightshaft/noise_combined.jpg");
		const nukeCondition = Global.PLAYGROUND || Tests.isVR();
		_shader.addUniforms({
			uScene: {
				value: nukeCondition ? null : World.NUKE.prevFrameRT
			},
			uScene2: {
				value: null
			},
			tMap: {
				value: _tex,
				ignoreUIL: !0
			},
			tNoise: {
				value: _noise,
				ignoreUIL: !0
			},
			uColor: {
				value: new Color("#ffffff")
			}
		}), _shader.transparent = !0, _shader.blending = Shader.ADDITIVE_BLENDING, _shader.side = Shader.DOUBLE_SIDE_TRANSPARENCY, _shader.depthWrite = !1
	}()
})), Class((function PathShader(_mesh, _shader) {
	Inherit(this, Component);
	_shader.addUniforms({
		uColor: {
			value: new Color
		},
		tMap: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uSpeed: {
			value: 2
		},
		uTiling: {
			value: new Vector2(1, 1)
		},
		uDistHSL: {
			value: new Vector3(0, 0, 0)
		},
		depthTest: !0,
		depthWrite: !1
	}), _mesh.renderOrder = RenderOrder.PATH
})), Class((function DreamPortalShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	const _this = this,
		STREAM_RESOLUTION = new Vector2(1920, 1080);
	let _videoTexture;

	function loop() {
		if (_shader.get("uConnected") > .001) {
			const width = _shader.uniforms?.tVideo?.value?._image?.videoWidth,
				height = _shader.uniforms?.tVideo?.value?._image?.videoHeight;
			width && height && _shader.uniforms.uStreamResolution.value.set(width, height)
		}
	}
	_shader.addUniforms({
		tMask: {
			value: null
		},
		tMap: {
			value: null,
			ignoreUIL: !0
		},
		tVideo: {
			value: null,
			ignoreUIL: !0
		},
		uConnected: {
			value: 0,
			ignoreUIL: !0
		},
		uSize: {
			value: new Vector2(_mesh.scale.x, _mesh.scale.y)
		},
		uStreamResolution: {
			value: STREAM_RESOLUTION,
			ignoreUIL: !0
		}
	}), _shader.transparent = !0, _mesh.renderOrder = RenderOrder.DREAM_PORTAL, DreamPortalShader.SHADER = _shader, async function settingsFromCMS() {
		if (await AppCMSConfig.ready(), !AppCMSConfig.portal.visible) return _mesh.visible = !1, void(_mesh.disableCulling = !0);
		let idleTexture;
		if (AppCMSConfig.portal.idleAssetVideo && Tests.portalShowIdleVideo()) {
			const src = AppCMSConfig.portal.idleAssetVideo.asset.url;
			_videoTexture = _this.initClass(VideoTexture, src, {
				mesh: _mesh
			}), _videoTexture.start(), idleTexture = _videoTexture.texture
		} else {
			const width = 512,
				height = parseInt(width * (_mesh.scale.y / _mesh.scale.x)),
				idleAsset = SanityImageUrlBuilder.build(AppCMSConfig.portal.idleAsset).width(width).height(height).quality(90).dpr(World.DPR).url();
			idleTexture = Utils3D.getTexture(idleAsset)
		}
		_shader.set("tMap", idleTexture)
	}(), _this.startRender(loop, 1)
}), (_ => {
	DreamPortalShader.SHADER = null
})), Class((function BlossomLeafShader(_mesh, _shader) {
	Inherit(this, Object3D);
	_shader.addUniforms({
		tMap: {
			value: null
		},
		uBrightness: {
			value: 1
		},
		uSaturation: {
			value: 1
		},
		uHue: {
			value: 0
		},
		uTile: {
			value: new Vector2(1, 1)
		},
		uNoiseStrength: {
			value: .3
		},
		uNoiseScale: {
			value: .3
		},
		uNoiseSpeed: {
			value: 1.3
		},
		uTint1: {
			value: new Color("#00936B")
		},
		uTint2: {
			value: new Color("#71D979")
		},
		uAlphaCutoff: {
			value: .05
		},
		uDistortSpeed: {
			value: 2
		},
		uDistortStrength: {
			value: new Vector3(2, 2, 2)
		},
		uDistortFrequency: {
			value: .04
		},
		uDistortSpeed2: {
			value: 1
		},
		uDistortStrength2: {
			value: new Vector3(1, 1, 1)
		},
		uDistortFrequency2: {
			value: .01
		},
		uGradientRange: {
			value: new Vector2(-1.6, 1)
		},
		uBakeMix: {
			value: 0
		}
	})
})), Class((function BlossomMeshLeafShader(_mesh, _shader) {
	Inherit(this, Object3D);
	_shader.addUniforms({
		tMap: {
			value: null
		},
		uBrightness: {
			value: 1
		},
		uSaturation: {
			value: 1
		},
		uHue: {
			value: 0
		},
		uFresnelColor: {
			value: new Color
		},
		uFresnelStrength: {
			value: 0
		},
		uClampFrom: {
			value: new Vector2(0, 1)
		},
		uClampTo: {
			value: new Vector2(0, 1)
		},
		uTile: {
			value: new Vector2(1, 1)
		},
		uNoiseStrength: {
			value: .3
		},
		uNoiseScale: {
			value: .3
		},
		uNoiseSpeed: {
			value: 1.3
		},
		uAlphaCutoff: {
			value: .05
		},
		uDistortSpeed: {
			value: 2
		},
		uDistortStrength: {
			value: new Vector3(2, 2, 2)
		},
		uDistortFrequency: {
			value: .04
		},
		uDistortSpeed2: {
			value: 1
		},
		uDistortStrength2: {
			value: new Vector3(1, 1, 1)
		},
		uDistortFrequency2: {
			value: .01
		}
	})
})), Class((function FantasyPoolShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tNormal: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		tEnv: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uTiling: {
			value: new Vector2(3, 3)
		},
		uSpeed: {
			value: .05
		},
		uColor: {
			value: new Color("#5294ff")
		},
		uSpecColor: {
			value: new Color("#FFFFFF")
		},
		uParams: {
			value: new Vector3(2, 1.14, 0)
		},
		uNormalIntensity: {
			value: 2.5
		},
		uScrollDirection: {
			value: new Vector3
		},
		uEnv: {
			value: new Vector3(0, 0, -.064)
		},
		uMirrorStrength: {
			value: 1
		},
		uMirrorRoughness: {
			value: 1
		}
	})
})), Class((function GalaxyInfiniteSkyShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tMap: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uHue: {
			value: 0
		},
		uHueSpread: {
			value: .2
		},
		uBrightness: {
			value: new Vector2(1.6, 5)
		},
		depthWrite: !1,
		depthTest: !1
	}), _mesh.renderOrder = RenderOrder.GALAXY_INFINITE_SKY
})), Class((function GalaxyOuterSpace() {
	Inherit(this, FXScene);
	const _this = this;
	_this.meshDestination = null, async function() {
		_this.layout = _this.initClass(SceneLayout, "outerspace_layout"), _this.layout.layers = await _this.layout.getAllLayers(), _this.layout.layers[0] && (_this.scene.add(_this.layout.group), _this.create({
			manualRender: !0
		}), _this.startRender((_ => {
			_this.meshDestination && !_this.meshDestination._drawing || (_this.layout.layers[0].frustumCulled = !1, _this.draw())
		}), RenderManager.BEFORE_RENDER), _this.flag("isReady", !0))
	}(), this.ready = async function() {
		await _this.wait(_this, "isReady")
	}
}), "singleton"), Class((function GalaxySpaceShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	!async function() {
		_shader.addUniforms({
			tMap: {
				value: null,
				ignoreUIL: !0
			},
			tOutside: {
				value: null,
				ignoreUIL: !0
			},
			side: Shader.DOUBLE_SIDE
		}), Platform.usingVR() || (await GalaxyOuterSpace.instance().ready(), GalaxyOuterSpace.instance().meshDestination = _mesh, _shader.set("tMap", GalaxyOuterSpace.instance().rt.texture)), Platform.usingVR() || (await SkyDomeOuter.instance().ready(), _shader.set("tOutside", SkyDomeOuter.instance().rt.texture))
	}()
})), Class((function GardenBirds(_proton, _group) {
	Inherit(this, Object3D);
	const _this = this;
	! function() {
		if (!Tests.renderBirds()) return _proton.mesh.visible = !1, _proton.visible = !1, void _proton.antimatter.stopRender();
		!async function initMesh() {
			_proton.antimatter.storeVelocity = !0;
			let birdGeometry = await GeomThread.loadGeometry(Assets.getPath("assets/geometry/garden/simplebird.json")),
				geom = (new Geometry).instanceFrom(birdGeometry);
			_proton.applyToInstancedGeometry(geom);
			let shader = _this.initClass(Shader, "GardenBirdsShader", {
				tAnimation: {
					value: Utils3D.getLookupTexture(Assets.getPath("assets/images/garden/birdanimation.jpg"))
				},
				uColor1: {
					value: new Color
				},
				uColor2: {
					value: new Color
				},
				uAltColor1: {
					value: new Color
				},
				uAltColor2: {
					value: new Color
				},
				uEnabled: {
					value: 0
				}
			});
			_this.shader = shader, ShaderUIL.add(shader, _group).setLabel("Shader"), _proton.applyToShader(shader);
			let mesh = new Mesh(geom, shader);
			mesh.frustumCulled = !1, _this.add(mesh)
		}()
	}()
})), Class((function GardenBirdsLayout() {
	Inherit(this, Object3D);
	const _this = this;
	var _flock1, _flock2, _flock3, _flock4;
	!async function() {
		Tests.renderBirds() && (await async function initScene() {
			if (!_this) return;
			_this.layout = _this.initClass(SceneLayout, "gardenbirdslayout"), await _this.layout.getAllLayers(), _flock1 = _this.layout.layers.flock_1, _flock2 = _this.layout.layers.flock_2, _flock3 = _this.layout.layers.flock_3, _flock4 = _this.layout.layers.flock_4, _flock1.shader.visible = !1, _flock2.shader.visible = !1, _flock3.shader.visible = !1, _flock4.shader.visible = !1;
			let proton = _this.layout.layers.particles;
			await proton.ready(), proton.behavior.shader.addUniforms({
				uFlock1: {
					value: new Vector3
				},
				uFlock2: {
					value: new Vector3
				},
				uFlock3: {
					value: new Vector3
				},
				uFlock4: {
					value: new Vector3
				}
			}), _this.proton = proton, proton.behavior.shader.uniforms.uFlock1.value = _flock1.position, proton.behavior.shader.uniforms.uFlock2.value = _flock2.position, proton.behavior.shader.uniforms.uFlock3.value = _flock3.position, proton.behavior.shader.uniforms.uFlock4.value = _flock4.position
		}(), _this.startRender((_ => {
			_flock1.position.z = 30 * Math.sin(-15e-5 * Render.TIME + .5), _flock1.position.x = 38 * Math.cos(-15e-5 * Render.TIME + .5), _flock2.position.z = 32 * Math.sin(-15e-5 * Render.TIME + 1), _flock2.position.x = 35 * Math.cos(-15e-5 * Render.TIME + 1), _flock3.position.z = 32 * Math.sin(15e-5 * Render.TIME + 1.5), _flock3.position.x = 38 * Math.cos(15e-5 * Render.TIME + 1.5), _flock4.position.z = 35 * Math.sin(15e-5 * Render.TIME + .75), _flock4.position.x = 35 * Math.cos(15e-5 * Render.TIME + .75)
		})))
	}()
})), Class((function GardenGrassShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	! function() {
		const density = Tests.grassDensity();
		density <= 0 ? _mesh.visible = !1 : _shader.addUniforms({
			tATO: {
				value: null
			},
			tLightmap: {
				value: null
			},
			uLightmapIntensity: {
				value: 1
			},
			uThreshold: {
				value: .5
			},
			uBaseColor: {
				value: new Color("#c2c2c2")
			},
			uTranslucentColor: {
				value: new Color("#f5ffb2")
			},
			uBlendColor: {
				value: new Color("#c2c2c2")
			},
			uGrassScale: {
				value: .8
			},
			uNoiseScale: {
				value: .08
			},
			uNoiseSpeed: {
				value: 1.5
			},
			uNoiseStrength: {
				value: .8
			},
			uNoiseRotation: {
				value: 0
			},
			uLightPosition: {
				value: new Vector3(-100, 10, -80)
			},
			uTranslucentStrength: {
				value: 1
			},
			uTranslucentPower: {
				value: 4
			},
			uDensity: {
				value: density
			},
			uAlpha: {
				value: 1
			}
		})
	}()
})), Class((function GardenSkyShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tFlow: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		tMap: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uColor0: {
			value: new Color("#fffcf0")
		},
		uColor1: {
			value: new Color("#6bceff")
		},
		uColor2: {
			value: new Color("#f894ff")
		},
		uColor3: {
			value: new Color("#f894ff")
		},
		uParams: {
			value: new Vector4(.55, .08, .04, 3)
		}
	})
})), Class((function GardenTerrainShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tMRO: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		tNormal: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		tCaustics: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		tLightmap: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uGrassColor: {
			value: new Color("#66923a")
		},
		uRockColor: {
			value: new Color("#bdbbbf")
		},
		uSandColor: {
			value: new Color("#ededed")
		},
		uSunColor: {
			value: new Color("#d6ddff")
		},
		uShadowColor: {
			value: new Color("#628ad5")
		},
		uTiling: {
			value: 8
		},
		uOffset: {
			value: new Vector2(0, 0)
		},
		uBlend: {
			value: new Vector2(.469, .5)
		},
		uAO: {
			value: new Vector2(1, 1)
		},
		uNormalIntensity: {
			value: 1
		},
		uEnv: {
			value: new Vector3(1, 1, -.03)
		},
		uLightmapIntensity: {
			value: 1
		},
		uLight: {
			value: new Vector3(.38, 1, -.34)
		},
		uFresnelContrast: {
			value: new Vector2(0, 1)
		},
		uFresnelAdd: {
			value: 1
		},
		uWind: {
			value: new Vector4(0, .08, 0, 0)
		},
		uWindContrast: {
			value: new Vector2(0, 1)
		}
	})
})), Class((function GardenPoolShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tNormal: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		tEnv: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uTiling: {
			value: new Vector2(5, 5)
		},
		uSpeed: {
			value: .15
		},
		uColor: {
			value: new Color("#a4b6df")
		},
		uSpecColor: {
			value: new Color("#FFFFFF")
		},
		uParams: {
			value: new Vector3(2, 1, 0)
		},
		uNormalIntensity: {
			value: 2
		},
		uScrollDirection: {
			value: new Vector3
		},
		uEnv: {
			value: new Vector3
		},
		uMirrorStrength: {
			value: 1
		},
		uMirrorRoughness: {
			value: 1
		},
		uRippleTile: {
			value: new Vector2(1, 1)
		},
		uRippleStrength: {
			value: 1
		},
		uRippleSpeed: {
			value: 1
		},
		uAlpha: {
			value: 1
		}
	})
})), Class((function GardenUnderwaterShader(_mesh, _shader, _group, _input) {
	Inherit(this, Component);
	_shader.addUniforms({
		tMap: {
			value: null
		},
		tCaustics: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uCaustics: {
			value: new Vector4(12.8, 1, .07, 1)
		},
		uBrightness: {
			value: 1.68
		},
		tNormal: {
			value: null,
			getTexture: Utils3D.getRepeatTexture
		},
		uMirrorStrength: {
			value: 1
		},
		uMirrorRoughness: {
			value: 1
		},
		uRippleTile: {
			value: new Vector2(1, 1)
		},
		uRippleStrength: {
			value: 1
		},
		uRippleSpeed: {
			value: 1
		}
	})
})), Class((function Main() {
	Inherit(this, DreamWorld);
	const _this = this;
	let _initEnv;
	World.PORTAL_HI = new PlaneGeometry(1, 1, 100, 100), this.init = async function() {
		await AppCMSConfig.ready(), CopyOverrides.instance(), _initEnv = await _this.createGroupEnvironment(GreyboxAvatar, InitEnvironment), AudioController.instance(), VoiceChatController.instance(), SpaceAudioManager.instance(), HotSpotAudioManager.instance(), Platform.usingVR() && _this.events.fire(XRDeviceManager.SESSION_START), Platform.usingVR() && Global.VR_READY.then((() => {
			SpaceAudioManager.instance().initializeAudio()
		})), GLUIWrapper.instance(), await GLUIWrapper.instance().ready, Utils.query("spawnDebug") && GLUIWrapper.instance().show(), PlayerControlsVR.registerWristMenu(VRMainMenu), PlayerControls.CLICK_PATHFINDING = !1;
		let capDPR = Tests.capDPRDown();
		capDPR && _this.capDPR(capDPR);
		let capFPS = Tests.capFPSDown();
		return capFPS && _this.capFPS(capFPS), Utils.query("mute") && _this.events.fire(AudioController.TOGGLE_MUTE, {
			value: !0
		}), _this.onRouteChange(_this.route)
	}, this.onRouteChange = function([route], split) {
		return _initEnv.activate()
	}, this.onDestroy = function() {}, this.extraTransitionTime = function() {
		return _this.delayedCall((() => {
			Global.VR_READY.resolve()
		}), 5e3), 100
	}
}));
window._MINIFIED_ = true;
window._BUILT_ = true;