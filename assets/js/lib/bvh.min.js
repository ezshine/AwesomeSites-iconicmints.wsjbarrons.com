!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).MeshBVHLib=t.MeshBVHLib||{},t.THREE)}(this,function(t,e){"use strict";const n=0,o=1,s=2,r=2,i=1.25,a=1,c=32,l=65535,u=Math.pow(2,-24);class f{constructor(){}}function d(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function h(t){let e=-1,n=-1/0;for(let o=0;o<3;o++){const s=t[o+3]-t[o];s>n&&(n=s,e=o)}return e}function p(t,e){e.set(t)}function y(t,e,n){let o,s;for(let r=0;r<3;r++){const i=r+3;o=t[r],s=e[r],n[r]=o<s?o:s,o=t[i],s=e[i],n[i]=o>s?o:s}}function m(t,e,n){for(let o=0;o<3;o++){const s=e[t+2*o],r=e[t+2*o+1],i=s-r,a=s+r;i<n[o]&&(n[o]=i),a>n[o+3]&&(n[o+3]=a)}}function g(t){const e=t[3]-t[0],n=t[4]-t[1],o=t[5]-t[2];return 2*(e*n+n*o+o*e)}function x(t,e,n,o,s=null){let r=1/0,i=1/0,a=1/0,c=-1/0,l=-1/0,u=-1/0,f=1/0,d=1/0,h=1/0,p=-1/0,y=-1/0,m=-1/0;const g=null!==s;for(let o=6*e,s=6*(e+n);o<s;o+=6){const e=t[o+0],n=t[o+1],s=e-n,x=e+n;s<r&&(r=s),x>c&&(c=x),g&&e<f&&(f=e),g&&e>p&&(p=e);const w=t[o+2],B=t[o+3],b=w-B,T=w+B;b<i&&(i=b),T>l&&(l=T),g&&w<d&&(d=w),g&&w>y&&(y=w);const A=t[o+4],P=t[o+5],M=A-P,V=A+P;M<a&&(a=M),V>u&&(u=V),g&&A<h&&(h=A),g&&A>m&&(m=A)}o[0]=r,o[1]=i,o[2]=a,o[3]=c,o[4]=l,o[5]=u,g&&(s[0]=f,s[1]=d,s[2]=h,s[3]=p,s[4]=y,s[5]=m)}const w=32,B=(t,e)=>t.candidate-e.candidate,b=new Array(w).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),T=new Float32Array(6);function A(t,e){function r(t){F&&F(t/U)}function c(e,l,u,F=null,U=0){if(!E&&U>=M&&(E=!0,V&&(console.warn(`MeshBVH: Max depth of ${M} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),u<=S||U>=M)return r(l),e.offset=l,e.count=u,e;const _=function(t,e,r,c,l,u){let f=-1,d=0;if(u===n)-1!==(f=h(e))&&(d=(e[f]+e[f+3])/2);else if(u===o)-1!==(f=h(t))&&(d=function(t,e,n,o){let s=0;for(let r=e,i=e+n;r<i;r++)s+=t[6*r+2*o];return s/n}(r,c,l,f));else if(u===s){const n=g(t);let o=i*l;const s=6*c,u=6*(c+l);for(let t=0;t<3;t++){const c=e[t],h=(e[t+3]-c)/w;if(l<w/4){const e=[...b];e.length=l;let c=0;for(let n=s;n<u;n+=6,c++){const o=e[c];o.candidate=r[n+2*t],o.count=0;const{bounds:s,leftCacheBounds:i,rightCacheBounds:a}=o;for(let t=0;t<3;t++)a[t]=1/0,a[t+3]=-1/0,i[t]=1/0,i[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;m(n,r,s)}e.sort(B);let h=l;for(let t=0;t<h;t++){const n=e[t];for(;t+1<h&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),h--}for(let n=s;n<u;n+=6){const o=r[n+2*t];for(let t=0;t<h;t++){const s=e[t];o>=s.candidate?m(n,r,s.rightCacheBounds):(m(n,r,s.leftCacheBounds),s.count++)}}for(let s=0;s<h;s++){const r=e[s],c=r.count,u=l-r.count,h=r.leftCacheBounds,p=r.rightCacheBounds;let y=0;0!==c&&(y=g(h)/n);let m=0;0!==u&&(m=g(p)/n);const x=a+i*(y*c+m*u);x<o&&(f=t,o=x,d=r.candidate)}}else{for(let t=0;t<w;t++){const e=b[t];e.count=0,e.candidate=c+h+t*h;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=s;e<u;e+=6){let n=~~((r[e+2*t]-c)/h);n>=w&&(n=w-1);const o=b[n];o.count++,m(e,r,o.bounds)}const e=b[w-1];p(e.bounds,e.rightCacheBounds);for(let t=w-2;t>=0;t--){const e=b[t],n=b[t+1];y(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let x=0;for(let e=0;e<w-1;e++){const s=b[e],r=s.count,c=s.bounds,u=b[e+1].rightCacheBounds;0!==r&&(0===x?p(c,T):y(c,T,T));let h=0,m=0;0!==(x+=r)&&(h=g(T)/n);const w=l-x;0!==w&&(m=g(u)/n);const B=a+i*(h*x+m*w);B<o&&(f=t,o=B,d=s.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${u} used.`);return{axis:f,pos:d}}(e.boundingData,F,A,l,u,v);if(-1===_.axis)return r(l),e.offset=l,e.count=u,e;const I=function(t,e,n,o,s){let r=n,i=n+o-1;const a=s.pos,c=2*s.axis;for(;;){for(;r<=i&&e[6*r+c]<a;)r++;for(;r<=i&&e[6*i+c]>=a;)i--;if(!(r<i))return r;for(let n=0;n<3;n++){let o=t[3*r+n];t[3*r+n]=t[3*i+n],t[3*i+n]=o;let s=e[6*r+2*n+0];e[6*r+2*n+0]=e[6*i+2*n+0],e[6*i+2*n+0]=s;let a=e[6*r+2*n+1];e[6*r+2*n+1]=e[6*i+2*n+1],e[6*i+2*n+1]=a}r++,i--}}(P,A,l,u,_);if(I===l||I===l+u)r(l),e.offset=l,e.count=u;else{e.splitAxis=_.axis;const t=new f,n=l,o=I-l;e.left=t,t.boundingData=new Float32Array(6),x(A,n,o,t.boundingData,d),c(t,n,o,d,U+1);const s=new f,r=I,i=u-o;e.right=s,s.boundingData=new Float32Array(6),x(A,r,i,s.boundingData,d),c(s,r,i,d,U+1)}return e}!function(t,e){if(!t.index){const n=t.attributes.position.count,o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let s;s=n>65535?new Uint32Array(new o(4*n)):new Uint16Array(new o(2*n)),t.index=s;for(let t=0;t<n;t++)s[t]=t}}(t,e);const l=new Float32Array(6),d=new Float32Array(6),A=function(t,e){const n=t.attributes.position,o=n.array,s=t.index,r=s.length/3,i=new Float32Array(6*r),a=n.offset||0;let c=3;n.isInterleavedBufferAttribute&&(c=n.data.stride);for(let t=0;t<r;t++){const n=3*t,r=6*t,l=s[n+0]*c+a,f=s[n+1]*c+a,d=s[n+2]*c+a;for(let t=0;t<3;t++){const n=o[l+t],s=o[f+t],a=o[d+t];let c=n;s<c&&(c=s),a<c&&(c=a);let h=n;s>h&&(h=s),a>h&&(h=a);const p=(h-c)/2,y=2*t;i[r+y+0]=c+p,i[r+y+1]=p+(Math.abs(c)+p)*u,c<e[t]&&(e[t]=c),h>e[t+3]&&(e[t+3]=h)}}return i}(t,l),P=t.index,M=e.maxDepth,V=e.verbose,S=e.maxLeafTris,v=e.strategy,F=e.onProgress,U=t.index.length/3;let E=!1;const _=[],I=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.length/3}];const e=[],n=new Set;for(const e of t.groups)n.add(e.start),n.add(e.start+e.count);const o=Array.from(n.values()).sort((t,e)=>t-e);for(let t=0;t<o.length-1;t++){const n=o[t],s=o[t+1];e.push({offset:n/3,count:(s-n)/3})}return e}(t);if(1===I.length){const t=I[0],e=new f;e.boundingData=l,function(t,e,n,o){let s=1/0,r=1/0,i=1/0,a=-1/0,c=-1/0,l=-1/0;for(let o=6*e,u=6*(e+n);o<u;o+=6){const e=t[o+0];e<s&&(s=e),e>a&&(a=e);const n=t[o+2];n<r&&(r=n),n>c&&(c=n);const u=t[o+4];u<i&&(i=u),u>l&&(l=u)}o[0]=s,o[1]=r,o[2]=i,o[3]=a,o[4]=c,o[5]=l}(A,t.offset,t.count,d),c(e,t.offset,t.count,d),_.push(e)}else for(let t of I){const e=new f;e.boundingData=new Float32Array(6),x(A,t.offset,t.count,e.boundingData,d),c(e,t.offset,t.count,d),_.push(e)}return _}class P{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,o=-1/0;for(let s=0,r=t.length;s<r;s++){const r=t[s][e];n=r<n?r:n,o=r>o?r:o}this.min=n,this.max=o}setFromPoints(t,e){let n=1/0,o=-1/0;for(let s=0,r=e.length;s<r;s++){const r=e[s],i=t.dot(r);n=i<n?i:n,o=i>o?i:o}this.min=n,this.max=o}isSeparated(t){return this.min>t.max||t.min>this.max}}P.prototype.setFromBox=function(){const t=new Vector3;return function(e,n){const o=n.min,s=n.max;let r=1/0,i=-1/0;for(let n=0;n<=1;n++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){t.x=o.x*n+s.x*(1-n),t.y=o.y*a+s.y*(1-a),t.z=o.z*c+s.z*(1-c);const l=e.dot(t);r=Math.min(l,r),i=Math.max(l,i)}this.min=r,this.max=i}}();!function(){const t=new P}();const M=function(){const t=new Vector3,e=new Vector3,n=new Vector3;return function(o,s,r){const i=o.start,a=t,c=s.start,l=e;n.subVectors(i,c),t.subVectors(o.end,s.start),e.subVectors(s.end,s.start);const u=n.dot(l),f=l.dot(a),d=l.dot(l),h=n.dot(a),p=a.dot(a)*d-f*f;let y,m;m=(u+(y=0!==p?(u*f-h*d)/p:0)*f)/d,r.x=y,r.y=m}}(),V=function(){const t=new Vector2,e=new Vector3,n=new Vector3;return function(o,s,r,i){M(o,s,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return o.at(a,r),void s.at(c,i);if(a>=0&&a<=1)return c<0?s.at(0,i):s.at(1,i),void o.closestPointToPoint(i,!0,r);if(c>=0&&c<=1)return a<0?o.at(0,r):o.at(1,r),void s.closestPointToPoint(r,!0,i);{let t,l;t=a<0?o.start:o.end,l=c<0?s.start:s.end;const u=e,f=n;return o.closestPointToPoint(l,!0,e),s.closestPointToPoint(t,!0,n),u.distanceToSquared(l)<=f.distanceToSquared(t)?(r.copy(u),void i.copy(l)):(r.copy(t),void i.copy(f))}}}(),S=function(){const t=new Vector3,e=new Vector3,n=new Plane,o=new Line3;return function(s,r){const{radius:i,center:a}=s,{a:c,b:l,c:u}=r;if(o.start=c,o.end=l,o.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;if(o.start=c,o.end=u,o.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;if(o.start=l,o.end=u,o.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;const f=r.getPlane(n);if(Math.abs(f.distanceToPoint(a))<=i){const t=f.projectPoint(a,e);if(r.containsPoint(t))return!0}return!1}}();class v extends Triangle{constructor(...t){super(...t),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new Vector3),this.satBounds=new Array(4).fill().map(()=>new P),this.points=[this.a,this.b,this.c],this.sphere=new Sphere,this.plane=new Plane,this.needsUpdate=!1}intersectsSphere(t){return S(t,this)}update(){const t=this.a,e=this.b,n=this.c,o=this.points,s=this.satAxes,r=this.satBounds,i=s[0],a=r[0];this.getNormal(i),a.setFromPoints(i,o);const c=s[1],l=r[1];c.subVectors(t,e),l.setFromPoints(c,o);const u=s[2],f=r[2];u.subVectors(e,n),f.setFromPoints(u,o);const d=s[3],h=r[3];d.subVectors(n,t),h.setFromPoints(d,o),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(i,t),this.needsUpdate=!1}}v.prototype.closestPointToSegment=function(){const t=new Vector3,e=new Vector3,n=new Line3;return function(o,s=null,r=null){const{start:i,end:a}=o,c=this.points;let l,u=1/0;for(let i=0;i<3;i++){const a=(i+1)%3;n.start.copy(c[i]),n.end.copy(c[a]),V(n,o,t,e),(l=t.distanceToSquared(e))<u&&(u=l,s&&s.copy(t),r&&r.copy(e))}return this.closestPointToPoint(i,t),(l=i.distanceToSquared(t))<u&&(u=l,s&&s.copy(t),r&&r.copy(i)),this.closestPointToPoint(a,t),(l=a.distanceToSquared(t))<u&&(u=l,s&&s.copy(t),r&&r.copy(a)),Math.sqrt(u)}}(),v.prototype.intersectsTriangle=function(){const t=new v,e=new Array(3),n=new Array(3),o=new P,s=new P,r=new Vector3,i=new Vector3,a=new Vector3,c=new Vector3,l=new Line3,u=new Line3,f=new Line3;return function(d,h=null){this.needsUpdate&&this.update(),d.isSeparatingAxisTriangle?d.needsUpdate&&d.update():(t.copy(d),t.update(),d=t);const p=this.satBounds,y=this.satAxes;n[0]=d.a,n[1]=d.b,n[2]=d.c;for(let t=0;t<4;t++){const e=p[t],s=y[t];if(o.setFromPoints(s,n),e.isSeparated(o))return!1}const m=d.satBounds,g=d.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=m[t],s=g[t];if(o.setFromPoints(s,e),n.isSeparated(o))return!1}for(let t=0;t<4;t++){const i=y[t];for(let t=0;t<4;t++){const a=g[t];if(r.crossVectors(i,a),o.setFromPoints(r,e),s.setFromPoints(r,n),o.isSeparated(s))return!1}}if(h){const t=this.plane,e=d.plane;if(Math.abs(t.normal.dot(e.normal))>1-1e-10)console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),h.start.set(0,0,0),h.end.set(0,0,0);else{const n=this.points;let o=!1;for(let t=0;t<3;t++){const s=n[t],r=n[(t+1)%3];if(l.start.copy(s),l.end.copy(r),e.intersectLine(l,o?u.start:u.end)){if(o)break;o=!0}}const s=d.points;let r=!1;for(let e=0;e<3;e++){const n=s[e],o=s[(e+1)%3];if(l.start.copy(n),l.end.copy(o),t.intersectLine(l,r?f.start:f.end)){if(r)break;r=!0}}if(u.delta(i),f.delta(a),i.dot(a)<0){let t=f.start;f.start=f.end,f.end=t}c.subVectors(u.start,f.start),c.dot(i)>0?h.start.copy(u.start):h.start.copy(f.start),c.subVectors(u.end,f.end),c.dot(i)<0?h.end.copy(u.end):h.end.copy(f.end)}}return!0}}(),v.prototype.distanceToPoint=function(){const t=new Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),v.prototype.distanceToTriangle=function(){const t=new Vector3,e=new Vector3,n=["a","b","c"],o=new Line3,s=new Line3;return function(r,i=null,a=null){const c=i||a?o:null;if(this.intersectsTriangle(r,c))return(i||a)&&(i&&c.getCenter(i),a&&c.getCenter(a)),0;let l=1/0;for(let e=0;e<3;e++){let o;const s=n[e],c=r[s];this.closestPointToPoint(c,t),(o=c.distanceToSquared(t))<l&&(l=o,i&&i.copy(t),a&&a.copy(c));const u=this[s];r.closestPointToPoint(u,t),(o=u.distanceToSquared(t))<l&&(l=o,i&&i.copy(u),a&&a.copy(t))}for(let c=0;c<3;c++){const u=n[c],f=n[(c+1)%3];o.set(this[u],this[f]);for(let c=0;c<3;c++){const u=n[c],f=n[(c+1)%3];s.set(r[u],r[f]),V(o,s,t,e);const d=t.distanceToSquared(e);d<l&&(l=d,i&&i.copy(t),a&&a.copy(e))}}return Math.sqrt(l)}}();class F extends Box3{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new Matrix4,this.invMatrix=new Matrix4,this.points=new Array(8).fill().map(()=>new Vector3),this.satAxes=new Array(3).fill().map(()=>new Vector3),this.satBounds=new Array(3).fill().map(()=>new P),this.alignedSatBounds=new Array(3).fill().map(()=>new P),this.needsUpdate=!1}set(t,e,n){super.set(t,e),this.matrix=n,this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}F.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,o=this.points;for(let s=0;s<=1;s++)for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){const a=o[1*s|2*r|4*i];a.x=s?n.x:e.x,a.y=r?n.y:e.y,a.z=i?n.z:e.z,a.applyMatrix4(t)}const s=this.satBounds,r=this.satAxes,i=o[0];for(let t=0;t<3;t++){const e=r[t],n=s[t],a=o[1<<t];e.subVectors(i,a),n.setFromPoints(e,o)}const a=this.alignedSatBounds;a[0].setFromPointsField(o,"x"),a[1].setFromPointsField(o,"y"),a[2].setFromPointsField(o,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},F.prototype.intersectsBox=function(){const t=new P;return function(e){this.needsUpdate&&this.update();const n=e.min,o=e.max,s=this.satBounds,r=this.satAxes,i=this.alignedSatBounds;if(t.min=n.x,t.max=o.x,i[0].isSeparated(t))return!1;if(t.min=n.y,t.max=o.y,i[1].isSeparated(t))return!1;if(t.min=n.z,t.max=o.z,i[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const o=r[n],i=s[n];if(t.setFromBox(o,e),i.isSeparated(t))return!1}return!0}}(),F.prototype.intersectsTriangle=function(){const t=new v,e=new Array(3),n=new P,o=new P,s=new Vector3;return function(r){this.needsUpdate&&this.update(),r.isSeparatingAxisTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const i=this.satBounds,a=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let t=0;t<3;t++){const o=i[t],s=a[t];if(n.setFromPoints(s,e),o.isSeparated(n))return!1}const c=r.satBounds,l=r.satAxes,u=this.points;for(let t=0;t<3;t++){const e=c[t],o=l[t];if(n.setFromPoints(o,u),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const r=a[t];for(let t=0;t<4;t++){const i=l[t];if(s.crossVectors(r,i),n.setFromPoints(s,e),o.setFromPoints(s,u),n.isSeparated(o))return!1}}return!0}}(),F.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},F.prototype.distanceToPoint=function(){const t=new Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),F.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map(()=>new Line3),n=new Array(12).fill().map(()=>new Line3),o=new Vector3,s=new Vector3;return function(r,i=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(a||c)&&(r.getCenter(s),this.closestPointToPoint(s,o),r.closestPointToPoint(o,s),a&&a.copy(o),c&&c.copy(s)),0;const l=i*i,u=r.min,f=r.max,d=this.points;let h=1/0;for(let t=0;t<8;t++){const e=d[t];s.copy(e).clamp(u,f);const n=e.distanceToSquared(s);if(n<h&&(h=n,a&&a.copy(e),c&&c.copy(s),n<l))return Math.sqrt(n)}let p=0;for(let o=0;o<3;o++)for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){const i=(o+1)%3,a=(o+2)%3,c=1<<o|s<<i|r<<a,l=d[s<<i|r<<a],h=d[c];e[p].set(l,h);const y=t[o],m=t[i],g=t[a],x=n[p],w=x.start,B=x.end;w[y]=u[y],w[m]=s?u[m]:f[m],w[g]=r?u[g]:f[m],B[y]=f[y],B[m]=s?u[m]:f[m],B[g]=r?u[g]:f[m],p++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){s.x=t?f.x:u.x,s.y=e?f.y:u.y,s.z=n?f.z:u.z,this.closestPointToPoint(s,o);const r=s.distanceToSquared(o);if(r<h&&(h=r,a&&a.copy(o),c&&c.copy(s),r<l))return Math.sqrt(r)}for(let t=0;t<12;t++){const r=e[t];for(let t=0;t<12;t++){const e=n[t];V(r,e,o,s);const i=o.distanceToSquared(s);if(i<h&&(h=i,a&&a.copy(o),c&&c.copy(s),i<l))return Math.sqrt(i)}}return Math.sqrt(h)}}();const U=new Vector3,E=new Vector3,_=new Vector3,I=new Vector2,z=new Vector2,C=new Vector2,H=new Vector3;function L(t,e,n,o,s,r,i){U.fromBufferAttribute(e,o),E.fromBufferAttribute(e,s),_.fromBufferAttribute(e,r);const a=function(t,e,n,o,s,r){let i;return null===(i=r===Shader.BACK_SIDE?t.intersectTriangle(o,n,e,!0,s):t.intersectTriangle(e,n,o,r!==Shader.DOUBLE_SIDE,s))?null:{distance:t.origin.distanceTo(s),point:s.clone()}}(t,U,E,_,H,i);if(a){n&&(I.fromBufferAttribute(n,o),z.fromBufferAttribute(n,s),C.fromBufferAttribute(n,r),a.uv=Triangle.getUV(H,U,E,_,I,z,C,new Vector2));const t={a:o,b:s,c:r,normal:new Vector3,materialIndex:0};Triangle.getNormal(U,E,_,t.normal),a.face=t,a.faceIndex=o}return a}function D(t,e,n,o,s){const r=3*o,i=t.index[r],a=t.index[r+1],c=t.index[r+2],l=L(n,t.attributes.position,t.attributes.uv,i,a,c,e);return l?(l.faceIndex=o,s&&s.push(l),l):null}function q(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t.distance<n.near||t.distance>n.far?null:t)}function N(t,e,n,o){const s=t.a,r=t.b,i=t.c;let a=e,c=e+1,l=e+2;n&&(a=n[e],c=n[e+1],l=n[e+2]),s.x=o.getX(a),s.y=o.getY(a),s.z=o.getZ(a),r.x=o.getX(c),r.y=o.getY(c),r.z=o.getZ(c),i.x=o.getX(l),i.y=o.getY(l),i.z=o.getZ(l)}function R(t,e,n,o,s,r,i){const a=n.index,c=n.attributes.position;for(let n=t,l=e+t;n<l;n++)if(N(i,3*n,a,c),i.needsUpdate=!0,o(i,n,s,r))return!0;return!1}const O=new Vector3,k=new Vector3,G=new Vector3,j=new Vector2,W=new Vector2,X=new Vector2;class Y{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function Z(t,e){return 65535===e[t+15]}function $(t,e){return e[t+6]}function J(t,e){return e[t+14]}function K(t){return t+8}function Q(t,e){return e[t+6]}function tt(t,e){return e[t+7]}function et(t){return t}const nt=new Box3,ot=new Vector3,st=["x","y","z"];function rt(t,e,n,o,s){let r=2*t,i=dt,a=ht,c=pt;if(Z(r,a)){!function(t,e,n,o,s,r){for(let i=o,a=o+s;i<a;i++)D(t,e,n,i,r)}(e,n,o,$(t,c),J(r,a),s)}else{const r=K(t);lt(r,i,o,ot)&&rt(r,e,n,o,s);const a=Q(t,c);lt(a,i,o,ot)&&rt(a,e,n,o,s)}}function it(t,e,n,o){let s=2*t,r=dt,i=ht,a=pt;if(Z(s,i)){return function(t,e,n,o,s){let r=1/0,i=null;for(let a=o,c=o+s;a<c;a++){const o=D(t,e,n,a);o&&o.distance<r&&(i=o,r=o.distance)}return i}(e,n,o,$(t,a),J(s,i))}{const s=tt(t,a),i=st[s],c=o.direction[i]>=0;let l,u;c?(l=K(t),u=Q(t,a)):(l=Q(t,a),u=K(t));const f=lt(l,r,o,ot)?it(l,e,n,o):null;if(f){const t=f.point[i];if(c?t<=r[u+s]:t>=r[u+s+3])return f}const d=lt(u,r,o,ot)?it(u,e,n,o):null;return f&&d?f.distance<=d.distance?f:d:f||d||null}}const at=function(){let t,e;const n=[],o=new Y(()=>new Box3);return function(...s){t=o.getPrimitive(),e=o.getPrimitive(),n.push(t,e);const i=function n(o,s,i,a,c=null,l=0,u=0){function f(t){let e=2*t,n=ht,o=pt;for(;!Z(e,n);)t=K(t),e=2*t;return $(t,o)}function h(t){let e=2*t,n=ht,o=pt;for(;!Z(e,n);)t=Q(t,o),e=2*t;return $(t,o)+J(e,n)}let p=2*o,y=dt,m=ht,g=pt;const x=Z(p,m);if(x){const e=$(o,g),n=J(p,m);return d(et(o),y,t),a(e,n,!1,u,l+o,t)}{const p=K(o),x=Q(o,g);let w,B,b,T,A=p,P=x;if(c&&(b=t,T=e,d(et(A),y,b),d(et(P),y,T),w=c(b),(B=c(T))<w)){A=x,P=p;const t=w;w=B,B=t,b=T}b||(b=t,d(et(A),y,b));const M=Z(2*A,m),V=i(b,M,w,u+1,l+A);let S;if(V===r){const t=f(A),e=h(A),n=e-t;S=a(t,n,!0,u+1,l+A,b)}else S=V&&n(A,s,i,a,c,l,u+1);if(S)return!0;T=e,d(et(P),y,T);const v=Z(2*P,m),F=i(T,v,B,u+1,l+P);let U;if(F===r){const t=f(P),e=h(P),n=e-t;U=a(t,n,!0,u+1,l+P,T)}else U=F&&n(P,s,i,a,c,l,u+1);return!!U}}(...s);o.releasePrimitive(t),o.releasePrimitive(e),n.pop(),n.pop();const a=n.length;return a>0&&(e=n[a-1],t=n[a-2]),i}}(),ct=function(){const t=new v,e=new v,n=new Matrix4,o=new F,s=new F;return function r(i,a,c,l,u=null){let f=2*i,h=dt,p=ht,y=pt;if(null===u&&(c.boundingBox||c.computeBoundingBox(),o.set(c.boundingBox.min,c.boundingBox.max,l),u=o),!Z(f,p)){const t=i+8,e=y[i+6];return d(et(t),h,nt),u.intersectsBox(nt)&&r(t,a,c,l,u)?!0:(d(et(e),h,nt),!(!u.intersectsBox(nt)||!r(e,a,c,l,u)))}{const o=a,r=o.index,u=o.attributes.position,m=c.index,g=c.attributes.position,x=$(i,y),w=J(f,p);if(n.copy(l).invert(),c.boundsTree){return d(et(i),h,s),s.matrix.copy(n),s.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:t=>s.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(l),t.b.applyMatrix4(l),t.c.applyMatrix4(l),t.needsUpdate=!0;for(let n=3*x,o=3*(w+x);n<o;n+=3)if(N(e,n,r,u),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}})}for(let o=3*x,s=w+3*x;o<s;o+=3){N(t,o,r,u),t.a.applyMatrix4(n),t.b.applyMatrix4(n),t.c.applyMatrix4(n),t.needsUpdate=!0;for(let n=0,o=m.length/3;n<o;n+=3)if(N(e,n,m,g),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function lt(t,e,n,o){return d(t,e,nt),n.intersectBox(nt,o)}const ut=[];let ft,dt,ht,pt;function yt(t){ft&&ut.push(ft),ft=t,dt=new Float32Array(t),ht=new Uint16Array(t),pt=new Uint32Array(t)}function mt(){ft=null,dt=null,ht=null,pt=null,ut.length&&yt(ut.pop())}const gt=Symbol("skip tree generation"),xt=new Box3,wt=new Box3,Bt=new Matrix4,bt=new F,Tt=new F,At=new Vector3,Pt=new Vector3,Mt=new Vector3,Vt=new Vector3,St=new Vector3,vt=new Box3,Ft=new Y(()=>new v);class Ut{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),Ut.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,o=t._roots,s=n.index;let r;return r=e.cloneBuffers?{roots:o.map(t=>t.slice()),index:s.slice()}:{roots:o,index:s}}static deserialize(t,e,n={}){if("boolean"==typeof n)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),Ut.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});n={setIndex:!0,...n};const{index:o,roots:s}=t,r=new Ut(e,{...n,[gt]:!0});return r._roots=s,e.index=t.index,r}constructor(t,e={}){if((e=Object.assign({strategy:n,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[gt]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[gt]||(this._roots=function(t,e){const n=A(t,e);let o,s,r;const i=[],a=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<n.length;t++){const e=n[t];let l=u(e);const d=new a(c*l);o=new Float32Array(d),s=new Uint32Array(d),r=new Uint16Array(d),f(0,e),i.push(d)}return i;function u(t){return t.count?1:1+u(t.left)+u(t.right)}function f(t,e){const n=t/4,i=t/2,a=!!e.count,u=e.boundingData;for(let t=0;t<6;t++)o[n+t]=u[t];if(a){const o=e.offset,a=e.count;return s[n+6]=o,r[i+14]=a,r[i+15]=l,t+c}{const o=e.left,r=e.right,i=e.splitAxis;let a;if((a=f(t+c,o))/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return s[n+6]=a/4,a=f(a,r),s[n+7]=i,a}}}(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Box3))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index,o=e.attributes.position,s=o.array,r=o.offset||0;let i,a,c,u,f=3;o.isInterleavedBufferAttribute&&(f=o.data.stride);let d=0;const h=this._roots;for(let t=0,e=h.length;t<e;t++)i=h[t],a=new Uint32Array(i),c=new Uint16Array(i),u=new Float32Array(i),p(0,d),d+=i.byteLength;function p(e,o,i=!1){const d=2*e;if(c[d+15]===l){const t=a[e+6];let o=1/0,i=1/0,l=1/0,h=-1/0,p=-1/0,y=-1/0;for(let e=3*t,a=3*(t+c[d+14]);e<a;e++){const t=n[e]*f+r,a=s[t+0],c=s[t+1],u=s[t+2];a<o&&(o=a),a>h&&(h=a),c<i&&(i=c),c>p&&(p=c),u<l&&(l=u),u>y&&(y=u)}return(u[e+0]!==o||u[e+1]!==i||u[e+2]!==l||u[e+3]!==h||u[e+4]!==p||u[e+5]!==y)&&(u[e+0]=o,u[e+1]=i,u[e+2]=l,u[e+3]=h,u[e+4]=p,u[e+5]=y,!0)}{const n=e+8,s=a[e+6],r=n+o,c=s+o;let l=i,f=!1,d=!1;t?l||(f=t.has(r),d=t.has(c),l=!f&&!d):(f=!0,d=!0);const h=l||d;let y=!1;(l||f)&&(y=p(n,o,l));let m=!1;h&&(m=p(s,o,l));const g=y||m;if(g)for(let t=0;t<3;t++){const o=n+t,r=s+t,i=u[o],a=u[o+3],c=u[r],l=u[r+3];u[e+t]=i<c?i:c,u[e+t+3]=a>l?a:l}return g}}}traverse(t,e=0){const n=this._roots[e],o=new Uint32Array(n),s=new Uint16Array(n);!function e(r,i=0){const a=2*r;const u=s[a+15]===l;if(u){const e=o[r+6],c=s[a+14];t(i,u,new Float32Array(n,4*r,6),e,c)}else{const s=r+c/4,a=o[r+6],l=o[r+7],f=t(i,u,new Float32Array(n,4*r,6),l);f||(e(s,i+1),e(a,i+1))}}(0)}raycast(t,e=Shader.FRONT_SIDE){const n=this._roots,o=this.geometry,s=[],r=e.isMaterial,i=Array.isArray(e),a=o.groups,c=r?e.side:e;for(let r=0,l=n.length;r<l;r++){const l=i?e[a[r].materialIndex].side:c,u=s.length;if(yt(n[r]),rt(0,o,l,t,s),mt(),i){const t=a[r].materialIndex;for(let e=u,n=s.length;e<n;e++)s[e].face.materialIndex=t}}return s}raycastFirst(t,e=Shader.FRONT_SIDE){const n=this._roots,o=this.geometry,s=e.isMaterial,r=Array.isArray(e);let i=null;const a=o.groups,c=s?e.side:e;for(let s=0,l=n.length;s<l;s++){const l=r?e[a[s].materialIndex].side:c;yt(n[s]);const u=it(0,o,l,t);mt(),null!=u&&(null==i||u.distance<i.distance)&&(i=u,r&&(u.face.materialIndex=a[s].materialIndex))}return i}intersectsGeometry(t,e){const n=this.geometry;let o=!1;for(const s of this._roots)if(yt(s),o=ct(0,n,t,e),mt(),o)break;return o}shapecast(t,e,n){const o=this.geometry;if(t instanceof Function){if(e){const t=e;e=((e,n,o,s)=>{const r=3*n;return t(e,r,r+1,r+2,o,s)})}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const s=Ft.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:i,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const t=a;a=((e,n,r,i,a)=>!!t(e,n,r,i,a)||R(e,n,o,c,r,i,s))}else a||(a=c?(t,e,n,r)=>R(t,e,o,c,n,r,s):(t,e,n)=>n);let l=!1,u=0;for(const t of this._roots){if(yt(t),l=at(0,o,i,a,r,u),mt(),l)break;u+=t.byteLength}return Ft.releasePrimitive(s),l}bvhcast(t,e,n){let{intersectsRanges:o,intersectsTriangles:s}=n;const r=this.geometry.index,i=this.geometry.attributes.position,a=t.geometry.index,c=t.geometry.attributes.position;Bt.copy(e).invert();const l=Ft.getPrimitive(),u=Ft.getPrimitive();if(s){function f(t,n,o,f,d,h,p,y){for(let m=o,g=o+f;m<g;m++){N(u,3*m,a,c),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=t,o=t+n;e<o;e++)if(N(l,3*e,r,i),l.needsUpdate=!0,s(l,u,e,m,d,h,p,y))return!0}return!1}if(o){const t=o;o=function(e,n,o,s,r,i,a,c){return!!t(e,n,o,s,r,i,a,c)||f(e,n,o,s,r,i,a,c)}}else o=f}this.getBoundingBox(wt),wt.applyMatrix4(e);const d=this.shapecast({intersectsBounds:t=>wt.intersectsBox(t),intersectsRange:(e,n,s,r,i,a)=>(xt.copy(a),xt.applyMatrix4(Bt),t.shapecast({intersectsBounds:t=>xt.intersectsBox(t),intersectsRange:(t,s,a,c,l)=>o(e,n,t,s,r,i,c,l)}))});return Ft.releasePrimitive(l),Ft.releasePrimitive(u),d}intersectsBox(t,e){return bt.set(t.min,t.max,e),bt.needsUpdate=!0,this.shapecast({intersectsBounds:t=>bt.intersectsBox(t),intersectsTriangle:t=>bt.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},o={},s=0,r=1/0){t.boundingBox||t.computeBoundingBox(),bt.set(t.boundingBox.min,t.boundingBox.max,e),bt.needsUpdate=!0;const i=this.geometry,a=i.attributes.position,c=i.index,l=t.attributes.position,u=t.index,f=Ft.getPrimitive(),d=Ft.getPrimitive();let h=Pt,p=Mt,y=null,m=null;o&&(y=Vt,m=St);let g=1/0,x=null,w=null;return Bt.copy(e).invert(),Tt.matrix.copy(Bt),this.shapecast({boundsTraverseOrder:t=>bt.distanceToBox(t,Math.min(g,r)),intersectsBounds:(t,e,n)=>n<g&&n<r&&(e&&(Tt.min.copy(t.min),Tt.max.copy(t.max),Tt.needsUpdate=!0),!0),intersectsRange:(n,o)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>Tt.distanceToBox(t,Math.min(g,r)),intersectsBounds:(t,e,n)=>n<g&&n<r,intersectsRange:(t,r)=>{for(let i=3*t,B=3*(t+r);i<B;i+=3){N(d,i,u,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let t=3*n,e=3*(n+o);t<e;t+=3){N(f,t,c,a),f.needsUpdate=!0;const e=f.distanceToTriangle(d,h,y);if(e<g&&(p.copy(h),m&&m.copy(y),g=e,x=t/3,w=i/3),e<s)return!0}}}});for(let t=0,r=u?u.length/3:l.count;t<r;t+=3){N(d,t,u,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let e=3*n,r=3*(n+o);e<r;e+=3){N(f,e,c,a),f.needsUpdate=!0;const n=f.distanceToTriangle(d,h,y);if(n<g&&(p.copy(h),m&&m.copy(y),g=n,x=e/3,w=t/3),n<s)return!0}}}}),Ft.releasePrimitive(f),Ft.releasePrimitive(d),g===1/0?null:(n.point?n.point.copy(p):n.point=p.clone(),n.distance=g,n.faceIndex=x,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(Bt),p.applyMatrix4(Bt),o.distance=p.sub(o.point).length(),o.faceIndex=w),n)}closestPointToPoint(t,e={},n=0,o=1/0){const s=n*n,r=o*o;let i=1/0,a=null;if(this.shapecast({boundsTraverseOrder:e=>(At.copy(t).clamp(e.min,e.max),At.distanceToSquared(t)),intersectsBounds:(t,e,n)=>n<i&&n<r,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,At);const o=t.distanceToSquared(At);return o<i&&(Pt.copy(At),i=o,a=n),o<s}}),i===1/0)return null;const c=Math.sqrt(i);return e.point?e.point.copy(Pt):e.point=Pt.clone(),e.distance=c,e.faceIndex=a,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(e=>{d(0,new Float32Array(e),vt),t.union(vt)}),t}}const Et=Ut.prototype.raycast;Ut.prototype.raycast=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[e,n,o,s]=t;return Et.call(this,o,e.material).forEach(t=>{(t=q(t,e,n))&&s.push(t)}),s}return Et.apply(this,t)};const _t=Ut.prototype.raycastFirst;Ut.prototype.raycastFirst=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[e,n,o]=t;return q(_t.call(this,o,e.material),e,n)}return _t.apply(this,t)};const It=Ut.prototype.closestPointToPoint;Ut.prototype.closestPointToPoint=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),t.unshift();const e=t[1],n={};return t[1]=n,It.apply(this,t),e&&e.copy(n.point),n.distance}return It.apply(this,t)};const zt=Ut.prototype.closestPointToGeometry;Ut.prototype.closestPointToGeometry=function(...t){const e=t[2],n=t[3];if(e&&e.isVector3||n&&n.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const o={},s={},r=t[1];return t[2]=o,t[3]=s,zt.apply(this,t),e&&e.copy(o.point),n&&n.copy(s.point).applyMatrix4(r),o.distance}return zt.apply(this,t)};const Ct=Ut.prototype.refit;Ut.prototype.refit=function(...t){const e=t[0],n=t[1];if(n&&(n instanceof Set||Array.isArray(n))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const t=new Set;n.forEach(e=>t.add(e)),e&&e.forEach(e=>t.add(e)),Ct.call(this,t)}else Ct.apply(this,t)},["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach(t=>{const e=Ut.prototype[t];Ut.prototype[t]=function(...n){return(null===n[0]||n[0].isMesh)&&(n.shift(),console.warn(`MeshBVH: The function signature for "${t}" has changed and no longer takes Mesh. See docs for new signature.`)),e.apply(this,n)}});const Ht=new Box3;class Lt extends Base3D{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,n=10,o=0){super(),this.material=e,this.geometry=new BufferGeometry,this.name="MeshBVHRootVisualizer",this.depth=n,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=o}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,n=this._group;if(t.dispose(),this.visible=!1,e){const o=this.depth-1,s=this.displayParents;let r=0;e.traverse((t,e)=>{if(t===o||e)return r++,!0;s&&r++},n);let i=0;const a=new Float32Array(24*r);let c,l;e.traverse((t,e,n)=>{const r=t===o||e;if(r||s){d(0,n,Ht);const{min:t,max:e}=Ht;for(let n=-1;n<=1;n+=2){const o=n<0?t.x:e.x;for(let n=-1;n<=1;n+=2){const s=n<0?t.y:e.y;for(let n=-1;n<=1;n+=2){const r=n<0?t.z:e.z;a[i+0]=o,a[i+1]=s,a[i+2]=r,i+=3}}}return r}},n),l=this.displayEdges?new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),c=a.length>65535?new Uint32Array(l.length*r):new Uint16Array(l.length*r);const u=l.length;for(let t=0;t<r;t++){const e=8*t,n=t*u;for(let t=0;t<u;t++)c[n+t]=e+l[t]}t.setIndex(new BufferAttribute(c,1,!1)),t.setAttribute("position",new BufferAttribute(a,3,!1)),this.visible=!0}}}class Dt extends Group{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const n=new LineBasicMaterial({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),o=new MeshBasicMaterial({color:65416,transparent:!0,opacity:.3,depthWrite:!1});o.color=n.color,this.edgeMaterial=n,this.meshMaterial=o,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let t=0;t<e;t++){if(t>=this._roots.length){const e=new Lt(this.mesh,this.edgeMaterial,this.depth,t);this.add(e),this._roots.push(e)}const e=this._roots[t];e.depth=this.depth,e.mesh=this.mesh,e.displayParents=this.displayParents,e.displayEdges=this.displayEdges,e.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,e.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new Dt(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].geometry.dispose()}}const qt=new Box3,Nt=new Box3,Rt=new Vector3;function Ot(t){switch(typeof t){case"number":return 8;case"string":return 2*t.length;case"boolean":return 4;default:return 0}}const kt=new Ray,Gt=new Matrix4,jt=Mesh.prototype.raycast;t.AVERAGE=o,t.CENTER=n,t.CONTAINED=r,t.INTERSECTED=1,t.MeshBVH=Ut,t.MeshBVHVisualizer=Dt,t.NOT_INTERSECTED=0,t.SAH=s,t.acceleratedRaycast=function(t,e){if(this.geometry.boundsTree){Gt.copy(this.matrixWorld).invert(),kt.copy(t.ray).applyMatrix4(Gt);const n=this.geometry.boundsTree;if(!0===t.firstHitOnly){const o=q(n.raycastFirst(kt,this.material),this,t);o&&e.push(o)}else{const o=n.raycast(kt,this.material);for(let n=0,s=o.length;n<s;n++){const s=q(o[n],this,t);s&&e.push(s)}}}else jt.call(this,t,e)},t.computeBoundsTree=function(t){return this.boundsTree=new Ut(this,t),this.boundsTree},t.disposeBoundsTree=function(){this.boundsTree=null},t.estimateMemoryInBytes=function(t){const e=new Set,n=[t];let o=0;for(;n.length;){const t=n.pop();if(!e.has(t)){e.add(t);for(let e in t){if(!t.hasOwnProperty(e))continue;o+=Ot(e);const s=t[e];!s||"object"!=typeof s&&"function"!=typeof s?o+=Ot(s):/(Uint|Int|Float)(8|16|32)Array/.test(s.constructor.name)?o+=s.byteLength:s instanceof ArrayBuffer?o+=s.byteLength:n.push(s)}}}return o},t.getBVHExtremes=function(t){return t._roots.map((e,n)=>(function(t,e){const n={nodeCount:0,leafNodeCount:0,depth:{min:1/0,max:-1/0},tris:{min:1/0,max:-1/0},splits:[0,0,0],surfaceAreaScore:0};return t.traverse((t,e,o,s,r)=>{const c=o[3]-o[0],l=o[4]-o[1],u=o[5]-o[2],f=2*(c*l+l*u+u*c);n.nodeCount++,e?(n.leafNodeCount++,n.depth.min=Math.min(t,n.depth.min),n.depth.max=Math.max(t,n.depth.max),n.tris.min=Math.min(r,n.tris.min),n.tris.max=Math.max(r,n.tris.max),n.surfaceAreaScore+=f*i*r):(n.splits[s]++,n.surfaceAreaScore+=f*a)},e),n.tris.min===1/0&&(n.tris.min=0,n.tris.max=0),n.depth.min===1/0&&(n.depth.min=0,n.depth.max=0),n})(t,n))},t.getJSONStructure=function(t){const e=[];return t.traverse((t,n,o,s,r)=>{const i={bounds:d(0,o,new Box3)};n?(i.count=r,i.offset=s):(i.left=null,i.right=null),e[t]=i;const a=e[t-1];a&&(null===a.left?a.left=i:a.right=i)}),e[0]},t.getTriangleHitPointInfo=function(t,e,n,o){const s=e.index,r=e.getAttribute("position"),i=e.getAttribute("uv"),a=s[3*n],c=s[3*n+1],l=s[3*n+2];O.fromBufferAttribute(r,a),k.fromBufferAttribute(r,c),G.fromBufferAttribute(r,l);let u=0;const f=e.groups,d=3*n;for(let t=0,e=f.length;t<e;t++){const e=f[t],{start:n,count:o}=e;if(d>=n&&d<n+o){u=e.materialIndex;break}}let h=null;return i&&(j.fromBufferAttribute(i,a),W.fromBufferAttribute(i,c),X.fromBufferAttribute(i,l),h=o&&o.uv?o.uv:new Vector2,Triangle.getUV(t,O,k,G,j,W,X,h)),o?(o.face||(o.face={}),o.face.a=a,o.face.b=c,o.face.c=l,o.face.materialIndex=u,o.face.normal||(o.face.normal=new Vector3),Triangle.getNormal(O,k,G,o.face.normal),o.uv||(o.uv=new Vector2),o.uv.copy(h),o):{face:{a:a,b:c,c:l,materialIndex:u,normal:Triangle.getNormal(O,k,G,new Vector3)},uv:h}},t.validateBounds=function(t){const e=t.geometry,n=[],o=e.index,s=e.getAttribute("position");let r=!0;return t.traverse((t,e,i,a,c)=>{const l={depth:t,isLeaf:e,boundingData:i,offset:a,count:c};n[t]=l,d(0,i,qt);const u=n[t-1];if(e)for(let t=3*a,e=3*(a+c);t<e;t+=3){const e=o.getX(t),n=o.getX(t+1),i=o.getX(t+2);let a;Rt.fromBufferAttribute(s,e),a=qt.containsPoint(Rt),Rt.fromBufferAttribute(s,n),a=a&&qt.containsPoint(Rt),Rt.fromBufferAttribute(s,i),a=a&&qt.containsPoint(Rt),console.assert(a,"Leaf bounds does not fully contain triangle."),r=r&&a}if(u){d(0,i,Nt);const t=Nt.containsBox(qt);console.assert(t,"Parent bounds does not fully contain child."),r=r&&t}}),r},Object.defineProperty(t,"__esModule",{value:!0})});